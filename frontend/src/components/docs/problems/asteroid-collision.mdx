import { VStack, HStack, Text } from "@chakra-ui/react"

# Asteroid Collision

**Difficulty:** <span style={{color: "#f59e0b"}}>Medium</span>  
**LeetCode:** [735. Asteroid Collision](https://leetcode.com/problems/asteroid-collision/)

---

## Problem

We are given an array `asteroids` of integers representing asteroids in a row. The indices of the asteroid in the array represent their relative position in space.

For each asteroid, the absolute value represents its size, and the sign represents its direction (positive meaning right, negative meaning left). Each asteroid moves at the same speed.

Find out the state of the asteroids after all collisions. If two asteroids meet, the smaller one will explode. If both are the same size, both will explode. Two asteroids moving in the same direction will never meet.

**Example 1:**
```
Input: asteroids = [5,10,-5]
Output: [5,10]
Explanation: The 10 and -5 collide resulting in 10. The 5 and 10 never collide.
```

**Example 2:**
```
Input: asteroids = [8,-8]
Output: []
Explanation: The 8 and -8 collide exploding each other.
```

**Example 3:**
```
Input: asteroids = [10,2,-5]
Output: [10]
Explanation: The 2 and -5 collide resulting in -5. The 10 and -5 collide resulting in 10.
```

**Constraints:**
- `2 <= asteroids.length <= 10^4`
- `-1000 <= asteroids[i] <= 1000`
- `asteroids[i] != 0`

---

## Simple Explanation

This problem simulates asteroid collisions using a **stack**. The key insight is that collisions only happen when a right-moving asteroid (positive) meets a left-moving asteroid (negative).

**The key insight:** Use a stack to track asteroids moving right, and handle collisions when we encounter left-moving asteroids.

**Collision Rules:**
- Positive asteroid (→) + Negative asteroid (←) = Collision!
- Same direction = No collision
- Left-moving asteroid can only collide with right-moving asteroids in the stack

## Solution

<TabbedCode
  files={[
    {
      title: "Python",
      language: "python",
      code: `def asteroidCollision(asteroids):
    """
    Stack-based simulation of asteroid collisions
    Time: O(n), Space: O(n)
    """
    stack = []
    
    for asteroid in asteroids:
        # Handle left-moving asteroid (negative)
        if asteroid < 0:
            # Keep colliding while there are right-moving asteroids
            # that are smaller than current left-moving asteroid
            while stack and stack[-1] > 0 and stack[-1] < abs(asteroid):
                stack.pop()  # Right-moving asteroid explodes
            
            # Check if collision results in both exploding
            if stack and stack[-1] == abs(asteroid):
                stack.pop()  # Both explode
            # If no right-moving asteroid or left-moving is smaller,
            # add the left-moving asteroid
            elif not stack or stack[-1] < 0:
                stack.append(asteroid)
        else:
            # Right-moving asteroid (positive) - just add to stack
            stack.append(asteroid)
    
    return stack`
    },
    {
      title: "JavaScript",
      language: "javascript",
      code: `function asteroidCollision(asteroids) {
    const stack = [];
    
    for (const asteroid of asteroids) {
        if (asteroid < 0) {
            // Handle left-moving asteroid
            // Keep colliding while there are smaller right-moving asteroids
            while (stack.length > 0 && 
                   stack[stack.length - 1] > 0 && 
                   stack[stack.length - 1] < Math.abs(asteroid)) {
                stack.pop(); // Right-moving asteroid explodes
            }
            
            // Check if collision results in both exploding
            if (stack.length > 0 && stack[stack.length - 1] === Math.abs(asteroid)) {
                stack.pop(); // Both explode
            }
            // Add left-moving asteroid if no collision or it survives
            else if (stack.length === 0 || stack[stack.length - 1] < 0) {
                stack.push(asteroid);
            }
        } else {
            // Right-moving asteroid - just add to stack
            stack.push(asteroid);
        }
    }
    
    return stack;
}`
    },
    {
      title: "Java",
      language: "java",
      code: `import java.util.*;

public class Solution {
    public int[] asteroidCollision(int[] asteroids) {
        Stack<Integer> stack = new Stack<>();
        
        for (int asteroid : asteroids) {
            if (asteroid < 0) {
                // Handle left-moving asteroid
                // Keep colliding while there are smaller right-moving asteroids
                while (!stack.isEmpty() && 
                       stack.peek() > 0 && 
                       stack.peek() < Math.abs(asteroid)) {
                    stack.pop(); // Right-moving asteroid explodes
                }
                
                // Check if collision results in both exploding
                if (!stack.isEmpty() && stack.peek() == Math.abs(asteroid)) {
                    stack.pop(); // Both explode
                }
                // Add left-moving asteroid if no collision or it survives
                else if (stack.isEmpty() || stack.peek() < 0) {
                    stack.push(asteroid);
                }
            } else {
                // Right-moving asteroid - just add to stack
                stack.push(asteroid);
            }
        }
        
        // Convert stack to array
        int[] result = new int[stack.size()];
        for (int i = result.length - 1; i >= 0; i--) {
            result[i] = stack.pop();
        }
        return result;
    }
}`
    },
    {
      title: "C++",
      language: "cpp",
      code: `#include <vector>
#include <stack>
#include <cmath>

class Solution {
public:
    std::vector<int> asteroidCollision(std::vector<int>& asteroids) {
        std::stack<int> stack;
        
        for (int asteroid : asteroids) {
            if (asteroid < 0) {
                // Handle left-moving asteroid
                // Keep colliding while there are smaller right-moving asteroids
                while (!stack.empty() && 
                       stack.top() > 0 && 
                       stack.top() < std::abs(asteroid)) {
                    stack.pop(); // Right-moving asteroid explodes
                }
                
                // Check if collision results in both exploding
                if (!stack.empty() && stack.top() == std::abs(asteroid)) {
                    stack.pop(); // Both explode
                }
                // Add left-moving asteroid if no collision or it survives
                else if (stack.empty() || stack.top() < 0) {
                    stack.push(asteroid);
                }
            } else {
                // Right-moving asteroid - just add to stack
                stack.push(asteroid);
            }
        }
        
        // Convert stack to vector
        std::vector<int> result(stack.size());
        for (int i = result.size() - 1; i >= 0; i--) {
            result[i] = stack.top();
            stack.pop();
        }
        return result;
    }
};`
    }
  ]}
/>

---

## Step-by-Step Walkthrough

### Example 1: asteroids = [5, 10, -5]

```
asteroid = 5:  Right-moving → stack = [5]
asteroid = 10: Right-moving → stack = [5, 10]
asteroid = -5: Left-moving, size 5
    - Top of stack is 10 (right-moving, size 10)
    - 10 > 5, so -5 explodes
    - stack remains [5, 10]

Final result: [5, 10]
```

### Example 2: asteroids = [8, -8]

```
asteroid = 8:  Right-moving → stack = [8]
asteroid = -8: Left-moving, size 8
    - Top of stack is 8 (right-moving, size 8)
    - 8 == 8, so both explode
    - stack becomes []

Final result: []
```

### Example 3: asteroids = [10, 2, -5]

```
asteroid = 10: Right-moving → stack = [10]
asteroid = 2:  Right-moving → stack = [10, 2]
asteroid = -5: Left-moving, size 5
    - Top is 2 (right-moving, size 2)
    - 2 < 5, so 2 explodes → stack = [10]
    - Top is now 10 (right-moving, size 10)
    - 10 > 5, so -5 explodes
    - stack remains [10]

Final result: [10]
```

### Example 4: asteroids = [-2, -1, 1, 2]

```
asteroid = -2: Left-moving → stack = [-2]
asteroid = -1: Left-moving → stack = [-2, -1]  
asteroid = 1:  Right-moving → stack = [-2, -1, 1]
asteroid = 2:  Right-moving → stack = [-2, -1, 1, 2]

Final result: [-2, -1, 1, 2] (no collisions)
```

---

## Edge Cases

```python
# Test cases:
print(asteroidCollision([5, 10, -5]))      # [5, 10]
print(asteroidCollision([8, -8]))          # []
print(asteroidCollision([10, 2, -5]))      # [10]
print(asteroidCollision([-2, -1, 1, 2]))   # [-2, -1, 1, 2]
print(asteroidCollision([1, -1, -2, -2]))  # [-2, -2]
print(asteroidCollision([2, 1, -1, -2]))   # []
print(asteroidCollision([1, 2, 3, -3]))    # [1, 2]
print(asteroidCollision([-1, -2, 3, 4]))   # [-1, -2, 3, 4]
```

---

## Complexity Analysis

<Text color="green.400" fontWeight="bold">Time Complexity:</Text>
<Text ml={4} as="li">**O(n)** - Each asteroid is pushed and popped at most once</Text>
<Text ml={4} as="li">Even with the while loop, total operations are linear</Text>

<Text color="green.400" fontWeight="bold" mt={2}>Space Complexity:</Text>
<Text ml={4} as="li">**O(n)** - Stack can hold up to n asteroids in worst case</Text>
<Text ml={4} as="li">Example: All asteroids moving right: [1, 2, 3, 4, 5]</Text>

---

## Key Insights

**When do collisions occur?**
- Only when right-moving asteroid (positive) meets left-moving asteroid (negative)
- Asteroids moving in same direction never collide
- Left-moving asteroids can only collide with right-moving ones

**Stack behavior:**
- Right-moving asteroids: Always added to stack
- Left-moving asteroids: May cause chain of explosions with right-moving asteroids in stack

**Collision outcomes:**
1. Left-moving wins: Right-moving asteroid(s) explode
2. Right-moving wins: Left-moving asteroid explodes  
3. Tie: Both asteroids explode
4. No collision: Different directions or separated

---

## Pattern Recognition

This problem demonstrates key patterns:
- **Stack for Simulation**: Using LIFO structure to track state changes
- **Collision Detection**: Identifying when interactions occur
- **Chain Reactions**: One event triggering multiple subsequent events
- **State Management**: Tracking and updating system state over time

You'll see similar patterns in:
- Game physics simulations
- Event processing systems
- Undo/Redo operations with cascading effects
- Compiler parsing with precedence rules
- Traffic flow simulations

---