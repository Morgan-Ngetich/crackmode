import { VStack, HStack, Text } from "@chakra-ui/react"

# Contains Duplicate

**Difficulty:** <span style={{color: "#4ade80"}}>Easy</span>  
**LeetCode:** [217. Contains Duplicate](https://leetcode.com/problems/contains-duplicate/)

---

## Problem

Given an integer array `nums`, return `true` if any value appears **at least twice** in the array, and return `false` if every element is distinct.

**Example 1:**
```
Input: nums = [1,2,3,1]
Output: true
Explanation: The element 1 occurs at the indices 0 and 3.
```

**Example 2:**
```
Input: nums = [1,2,3,4]
Output: false
Explanation: All elements are distinct.
```

**Example 3:**
```
Input: nums = [1,1,1,3,3,4,3,2,4,2]
Output: true
```

**Constraints:**
- `1 <= nums.length <= 10^5`
- `-10^9 <= nums[i] <= 10^9`

---

## Simple Explanation

Think of this like **checking if you've seen a number before in your journey through the array**!

- Walk through the array: `[1, 2, 3, 1]`
- Keep track of numbers you've seen: `{1, 2, 3}`
- When you see `1` again, you know there's a duplicate!

**The Key:** Use a hash set to track seen elements - if you try to add something that already exists, you found a duplicate.

---

## Optimal Solutions

<TabbedCode
  files={[
    {
      title: "Python",
      language: "python",
      code: `def containsDuplicate(nums):
    """
    Hash Set Approach - Most Efficient
    Time: O(n), Space: O(n)
    """
    seen = set()
    
    for num in nums:
        if num in seen:
            return True
        seen.add(num)
    
    return False

def containsDuplicate_pythonic(nums):
    """
    Pythonic One-Liner
    Time: O(n), Space: O(n)
    """
    return len(nums) != len(set(nums))

def containsDuplicate_sorting(nums):
    """
    Sorting Approach
    Time: O(n log n), Space: O(1) if in-place sort
    """
    nums.sort()
    
    for i in range(1, len(nums)):
        if nums[i] == nums[i - 1]:
            return True
    
    return False

def containsDuplicate_brute_force(nums):
    """
    Brute Force Approach
    Time: O(n²), Space: O(1)
    """
    for i in range(len(nums)):
        for j in range(i + 1, len(nums)):
            if nums[i] == nums[j]:
                return True
    return False`
    },
    {
      title: "JavaScript",
      language: "javascript",
      code: `function containsDuplicate(nums) {
    // Hash Set Approach
    const seen = new Set();
    
    for (const num of nums) {
        if (seen.has(num)) {
            return true;
        }
        seen.add(num);
    }
    
    return false;
}

function containsDuplicate_onePass(nums) {
    // One-liner using Set size comparison
    return nums.length !== new Set(nums).size;
}

function containsDuplicate_sorting(nums) {
    // Sorting Approach
    nums.sort((a, b) => a - b);
    
    for (let i = 1; i < nums.length; i++) {
        if (nums[i] === nums[i - 1]) {
            return true;
        }
    }
    
    return false;
}

function containsDuplicate_map(nums) {
    // Using Map for frequency counting
    const frequency = new Map();
    
    for (const num of nums) {
        if (frequency.has(num)) {
            return true;
        }
        frequency.set(num, 1);
    }
    
    return false;
}`
    },
    {
      title: "Java",
      language: "java",
      code: `import java.util.HashSet;
import java.util.Set;
import java.util.Arrays;

public class Solution {
    public boolean containsDuplicate(int[] nums) {
        // Hash Set Approach
        Set<Integer> seen = new HashSet<>();
        
        for (int num : nums) {
            if (seen.contains(num)) {
                return true;
            }
            seen.add(num);
        }
        
        return false;
    }
    
    public boolean containsDuplicate_optimized(int[] nums) {
        // Optimized Set approach
        Set<Integer> seen = new HashSet<>();
        
        for (int num : nums) {
            if (!seen.add(num)) {  // add() returns false if element already exists
                return true;
            }
        }
        
        return false;
    }
    
    public boolean containsDuplicate_sorting(int[] nums) {
        // Sorting Approach
        Arrays.sort(nums);
        
        for (int i = 1; i < nums.length; i++) {
            if (nums[i] == nums[i - 1]) {
                return true;
            }
        }
        
        return false;
    }
    
    public boolean containsDuplicate_bruteForce(int[] nums) {
        // Brute Force Approach
        for (int i = 0; i < nums.length; i++) {
            for (int j = i + 1; j < nums.length; j++) {
                if (nums[i] == nums[j]) {
                    return true;
                }
            }
        }
        return false;
    }
}`
    },
    {
      title: "C++",
      language: "cpp",
      code: `#include <vector>
#include <unordered_set>
#include <algorithm>

class Solution {
public:
    bool containsDuplicate(std::vector<int>& nums) {
        // Hash Set Approach
        std::unordered_set<int> seen;
        
        for (int num : nums) {
            if (seen.find(num) != seen.end()) {
                return true;
            }
            seen.insert(num);
        }
        
        return false;
    }

    bool containsDuplicate_optimized(std::vector<int>& nums) {
        // Optimized Set approach
        std::unordered_set<int> seen;
        
        for (int num : nums) {
            if (seen.insert(num).second == false) {  // insert returns pair<iterator, bool>
                return true;
            }
        }
        
        return false;
    }

    bool containsDuplicate_sorting(std::vector<int>& nums) {
        // Sorting Approach
        std::sort(nums.begin(), nums.end());
        
        for (int i = 1; i < nums.size(); i++) {
            if (nums[i] == nums[i - 1]) {
                return true;
            }
        }
        
        return false;
    }

    bool containsDuplicate_bruteForce(std::vector<int>& nums) {
        // Brute Force Approach
        for (int i = 0; i < nums.size(); i++) {
            for (int j = i + 1; j < nums.size(); j++) {
                if (nums[i] == nums[j]) {
                    return true;
                }
            }
        }
        return false;
    }
};`
    }
  ]}
/>

---

## Step-by-Step Walkthrough

### Hash Set Approach for nums = [1,2,3,1]

```
Step 1: num = 1
        1 not in seen
        seen = {1}

Step 2: num = 2
        2 not in seen  
        seen = {1, 2}

Step 3: num = 3
        3 not in seen
        seen = {1, 2, 3}

Step 4: num = 1
        1 found in seen ✓
        Return true (duplicate found!)
```

### Sorting Approach for nums = [1,1,1,3,3,4,3,2,4,2]

```
Step 1: Sort array
        Original: [1,1,1,3,3,4,3,2,4,2]  
        Sorted:   [1,1,1,2,2,3,3,3,4,4]

Step 2: Compare adjacent elements
        Compare nums[0] and nums[1]: 1 == 1 ✓
        Return true (duplicate found!)
```

---

## Why Hash Set Works Best

<VStack align="start" spacing={2}>
  <HStack spacing={2}>
    <Text color="green.400" fontWeight="extrabold">Constant lookup</Text>
    <Text>- Hash set provides O(1) average time for contains/add operations</Text>
  </HStack>

  <HStack spacing={2}>
    <Text color="green.400" fontWeight="extrabold">Early termination</Text>
    <Text>- Returns immediately upon finding first duplicate</Text>
  </HStack>

  <HStack spacing={2}>
    <Text color="green.400" fontWeight="extrabold">Single pass</Text>
    <Text>- Only needs to iterate through array once</Text>
  </HStack>

  <HStack spacing={2}>
    <Text color="green.400" fontWeight="extrabold">Memory efficient</Text>
    <Text>- In worst case (no duplicates), stores each element once</Text>
  </HStack>
</VStack>

---

## Algorithm Comparison

### Performance Analysis:

```
Hash Set Approach:
✅ Time: O(n) - single pass
✅ Space: O(n) - set storage
✅ Early termination possible
Best for: Most cases, optimal time complexity

Sorting Approach:
⚠️ Time: O(n log n) - sorting dominates
✅ Space: O(1) - if in-place sort
✅ Early termination possible
Best for: Memory-constrained environments

One-liner Set Size:
⚠️ Time: O(n) - but always processes entire array
⚠️ Space: O(n) - creates complete set
❌ No early termination
Best for: Code golf, when you need the set anyway

Brute Force:
❌ Time: O(n²) - nested loops
✅ Space: O(1) - no extra storage
✅ Early termination possible
Best for: Tiny arrays only
```

---

## Edge Cases

```python
# Test cases:
print(containsDuplicate([1, 2, 3, 1]))           # True - basic duplicate
print(containsDuplicate([1, 2, 3, 4]))           # False - all unique
print(containsDuplicate([1, 1, 1, 3, 3, 4]))     # True - multiple duplicates
print(containsDuplicate([1]))                     # False - single element
print(containsDuplicate([0, 0]))                  # True - duplicate zeros
print(containsDuplicate([-1, -1]))                # True - negative duplicates
print(containsDuplicate([1000000000, 1000000000])) # True - large numbers
print(containsDuplicate([2147483647, -2147483648])) # False - boundary values
```

---

## Common Mistakes to Avoid

1. **Modifying input array:** Be careful with sorting approach if you need to preserve original array

2. **Hash collision assumptions:** Modern hash sets handle collisions well, don't over-optimize

3. **Integer overflow:** With constraints up to 10^9, standard int types are sufficient

4. **Early vs complete processing:** Choose hash set for early termination, size comparison for other use cases

5. **Memory considerations:** For very large arrays, consider sorting approach to save space

---

## Complexity Analysis

<Text color="green.400" fontWeight="bold">Hash Set Approach (Optimal):</Text>
<Text ml={4} as="li">**Time:** O(n) - Single pass through array, O(1) set operations</Text>
<Text ml={4} as="li">**Space:** O(n) - Worst case stores all n elements in set</Text>

<Text color="green.400" fontWeight="bold" mt={2}>Sorting Approach:</Text>
<Text ml={4} as="li">**Time:** O(n log n) - Sorting dominates, O(n) for comparison</Text>
<Text ml={4} as="li">**Space:** O(1) - If using in-place sort like heapsort</Text>

<Text color="green.400" fontWeight="bold" mt={2}>Brute Force Approach:</Text>
<Text ml={4} as="li">**Time:** O(n²) - Nested loops check all pairs</Text>
<Text ml={4} as="li">**Space:** O(1) - No extra space used</Text>

<Text color="green.400" fontWeight="bold" mt={2}>Set Size Comparison:</Text>
<Text ml={4} as="li">**Time:** O(n) - Creates set from entire array</Text>
<Text ml={4} as="li">**Space:** O(n) - Set stores all unique elements</Text>

---

## Pattern Recognition

This problem demonstrates key patterns:
- **Hash Set for Uniqueness**: Using set data structure to track seen elements
- **Early Termination Optimization**: Returning as soon as duplicate is found
- **Space-Time Tradeoffs**: Hash set vs sorting vs brute force approaches
- **Duplicate Detection**: Core pattern used in many algorithms

You'll see similar patterns in:
- Finding missing numbers in arrays
- Intersection of two arrays
- Remove duplicates from arrays
- Checking for anagrams
- Cycle detection in linked lists (Floyd's algorithm)
- Finding unique elements

---

## Real-World Applications

- **Data Validation**: Ensuring unique IDs, usernames, or email addresses
- **Database Systems**: Checking constraint violations before insertion
- **File Processing**: Detecting duplicate files or records
- **User Input**: Validating unique selections in forms
- **Security**: Detecting replay attacks or duplicate tokens
- **Analytics**: Finding unique visitors, events, or transactions

---

## Visual Representation

```
Array: [1, 2, 3, 1]

Hash Set Approach Visualization:
┌─────┬─────┬─────┬─────┐
│  1  │  2  │  3  │  1  │
└─────┴─────┴─────┴─────┘
  ↓     ↓     ↓     ↓
 Add   Add   Add  Found!
  ↓     ↓     ↓     ↓
Set: {1} → {1,2} → {1,2,3} → Duplicate!

Timeline:
Step 1: seen={}, num=1 → seen={1}
Step 2: seen={1}, num=2 → seen={1,2}  
Step 3: seen={1,2}, num=3 → seen={1,2,3}
Step 4: seen={1,2,3}, num=1 → DUPLICATE FOUND!

Result: Return true after checking 4/4 elements
```

---


## Follow-up Questions

**Q: What if the array is sorted?**
A: You can solve in O(n) time, O(1) space by just checking adjacent elements.

**Q: What if you need to find the duplicate element, not just detect it?**
A: Modify hash set approach to return the element instead of True.

**Q: What if you need to count all duplicates?**
A: Use a frequency map (HashMap) instead of a set.

**Q: Can you solve it without extra space?**
A: Yes, with sorting approach O(n log n) time, or O(n²) brute force.

**Q: What about floating point numbers?**
A: Same approaches work, but be careful with floating point precision issues.