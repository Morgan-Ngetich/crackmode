import { VStack, HStack, Text } from "@chakra-ui/react"

# Check if Number Has Equal Digit Count and Digit Value

**Difficulty:** <span style={{color: "#4ade80"}}>Easy</span>  
**LeetCode:** [2283. Check if Number Has Equal Digit Count and Digit Value](https://leetcode.com/problems/check-if-number-has-equal-digit-count-and-digit-value/)

---

## Problem

You are given a **0-indexed** string `num` of length `n` consisting of digits.

Return `true` *if for **every** index* `i` *in the range* `0 <= i < n`*, the digit* `i` *occurs* `num[i]` *times in* `num`*, otherwise return* `false`.

**Example 1:**
```
Input: num = "1210"
Output: true
Explanation:
num[0] = '1'. The digit 0 occurs once in num.
num[1] = '2'. The digit 1 occurs twice in num.
num[2] = '1'. The digit 2 occurs once in num.
num[3] = '0'. The digit 3 occurs zero times in num.
The condition holds true for every index in "1210", so return true.
```

**Example 2:**
```
Input: num = "030"
Output: false
Explanation:
num[0] = '0'. The digit 0 should occur zero times, but actually occurs twice in num.
num[1] = '3'. The digit 1 should occur three times, but actually occurs zero times in num.
num[2] = '0'. The digit 2 occurs zero times in num.
The indices 0 and 1 both violate the condition, so return false.
```

**Constraints:**
- `n == num.length`
- `1 <= n <= 10`
- `num` consists of digits

---

## Simple Explanation

Think of this like **checking a self-describing number**:

1. Each position `i` tells you how many times digit `i` should appear
2. You need to verify if the actual count matches the expected count
3. There are multiple ways to solve this:
   - **Brute force approach:** For each index, count occurrences of that digit
   - **Frequency map approach:** Count all digits once, then verify expectations
   - **Array counting approach:** Use a fixed-size array to track digit frequencies

The key insight is that we're dealing with a **self-referential** constraint!

---

## Solution Approaches

### Approach 1: Brute Force (Most Straightforward)
- For each index `i`, count how many times digit `i` appears in the string
- Compare with the value at position `i`

### Approach 2: Frequency Array (Most Efficient)
- Count all digit frequencies in one pass
- Verify each position's requirement in a second pass

---

## Solution

<TabbedCode
  files={[
    {
      title: "JavaScript",
      language: "javascript",
      code: `// Approach 1: Brute Force
var digitCount = function(num) {
    for (let i = 0; i < num.length; i++) {
        let counter = 0;
        for (let j = 0; j < num.length; j++) {
            if (i === parseInt(num[j])) {
                counter++;
            }
        }
        if (counter !== parseInt(num[i])) {
            return false;
        }
    }
    return true;
};

// Approach 2: Frequency Array
var digitCountOptimized = function(num) {
    const count = new Array(10).fill(0);
    
    // Count frequency of each digit
    for (let char of num) {
        const digit = parseInt(char)
        count[digit]++;
    }
    
    // Check if each position's requirement is met
    for (let i = 0; i < num.length; i++) {
        if (count[i] !== parseInt(num[i])) {
            return false;
        }
    }
    return true;
};`
    },
    {
      title: "Python",
      language: "python",
      code: `class Solution:
    # Approach 1: Brute Force (Given Solution)
    def digitCount(self, num: str) -> bool:
        for i in range(len(num)):
            counter = 0
            for j in range(len(num)):
                if i == int(num[j]):
                    counter += 1
            if counter != int(num[i]):
                return False
        return True
    
    # Approach 2: Frequency Array
    def digitCountOptimized(self, num: str) -> bool:
        count = [0] * 10
        
        # Count frequency of each digit
        for char in num:
            count[int(char)] += 1
        
        # Check if each position's requirement is met
        for i in range(len(num)):
            if count[i] != int(num[i]):
                return False
        return True
    
    # Approach 3: Using Counter from collections
    def digitCountCounter(self, num: str) -> bool:
        from collections import Counter
        count = Counter(num)
        
        for i in range(len(num)):
            digit_count = count.get(str(i), 0)
            if digit_count != int(num[i]):
                return False
        return True`
    },
    {
      title: "C++",
      language: "cpp",
      code: `#include <string>
#include <vector>
using namespace std;

class Solution {
public:
    // Approach 1: Brute Force
    bool digitCount(string num) {
        int n = num.length();
        for (int i = 0; i < n; i++) {
            int counter = 0;
            for (int j = 0; j < n; j++) {
                if (i == (num[j] - '0')) {
                    counter++;
                }
            }
            if (counter != (num[i] - '0')) {
                return false;
            }
        }
        return true;
    }
    
    // Approach 2: Frequency Array
    bool digitCountOptimized(string num) {
        vector<int> count(10, 0);
        
        // Count frequency of each digit
        for (char c : num) {
            count[c - '0']++;
        }
        
        // Check if each position's requirement is met
        for (int i = 0; i < num.length(); i++) {
            if (count[i] != (num[i] - '0')) {
                return false;
            }
        }
        return true;
    }
};`
    },
    {
      title: "Java",
      language: "java",
      code: `class Solution {
    // Approach 1: Brute Force
    public boolean digitCount(String num) {
        int n = num.length();
        for (int i = 0; i < n; i++) {
            int counter = 0;
            for (int j = 0; j < n; j++) {
                if (i == Character.getNumericValue(num.charAt(j))) {
                    counter++;
                }
            }
            if (counter != Character.getNumericValue(num.charAt(i))) {
                return false;
            }
        }
        return true;
    }
    
    // Approach 2: Frequency Array
    public boolean digitCountOptimized(String num) {
        int[] count = new int[10];
        
        // Count frequency of each digit
        for (char c : num.toCharArray()) {
            count[c - '0']++;
        }
        
        // Check if each position's requirement is met
        for (int i = 0; i < num.length(); i++) {
            if (count[i] != num.charAt(i) - '0') {
                return false;
            }
        }
        return true;
    }
}`
    },
  ]}
/>

---

## Step-by-Step Walkthrough

Let's trace through **Example 1** with `num = "1210"` using different approaches:

### Brute Force Approach:
```
Index 0: Count digit 0 in "1210" → appears 1 time, num[0] = '1' ✓
Index 1: Count digit 1 in "1210" → appears 2 times, num[1] = '2' ✓  
Index 2: Count digit 2 in "1210" → appears 1 time, num[2] = '1' ✓
Index 3: Count digit 3 in "1210" → appears 0 times, num[3] = '0' ✓
All conditions satisfied → Return true
```

### Frequency Array Approach:
```
Step 1: Count frequencies
count[0] = 1 (digit '0' appears once)
count[1] = 2 (digit '1' appears twice)  
count[2] = 1 (digit '2' appears once)
count[3] = 0 (digit '3' never appears)

Step 2: Verify conditions
i=0: count[0]=1, num[0]='1' → 1==1 ✓
i=1: count[1]=2, num[1]='2' → 2==2 ✓
i=2: count[2]=1, num[2]='1' → 1==1 ✓
i=3: count[3]=0, num[3]='0' → 0==0 ✓
All conditions satisfied → Return true
```

Let's trace through **Example 2** with `num = "030"`:
```
Index 0: Count digit 0 in "030" → appears 2 times, num[0] = '0' → 2≠0 ✗
Return false immediately
```

---

## Algorithm Intuition

The problem is asking us to verify a **self-describing** property:

> "At position `i`, the digit tells us how many times digit `i` should appear in the entire string"

This creates a constraint system where:
- Position 0 contains the count of digit 0
- Position 1 contains the count of digit 1
- And so on...

The constraint `1 <= n <= 10` is crucial because it limits us to digits 0-9, making a frequency array feasible.

---

## Complexity Analysis

### Brute Force:
<Text color="green.400" fontWeight="bold">Time Complexity: O(n²)</Text>
<Text ml={4} as="li">For each of n positions, we count through entire string</Text>

<Text color="green.400" fontWeight="bold">Space Complexity: O(1)</Text>
<Text ml={4} as="li">Only using counter variable</Text>

### Frequency Array:
<Text color="green.400" fontWeight="bold">Time Complexity: O(n)</Text>
<Text ml={4} as="li">One pass to count + one pass to verify</Text>

<Text color="green.400" fontWeight="bold">Space Complexity: O(1)</Text>
<Text ml={4} as="li">Fixed array of size 10 (constant space)</Text>

---

## Key Insights

<VStack align="start" gap={2}>
  <HStack gap={2}>
    <Text color="orange.400" fontWeight="extrabold">Self-reference</Text>
    <Text>- each position describes the count of its own index</Text>
  </HStack>

  <HStack gap={2}>
    <Text color="orange.400" fontWeight="extrabold">Constraint bounds</Text>
    <Text>- length ≤ 10 makes frequency array practical</Text>
  </HStack>

  <HStack gap={2}>
    <Text color="orange.400" fontWeight="extrabold">Early termination</Text>
    <Text>- return false as soon as any condition fails</Text>
  </HStack>

  <HStack gap={2}>
    <Text color="orange.400" fontWeight="extrabold">Trade-offs</Text>
    <Text>- O(n²) simplicity vs O(n) efficiency</Text>
  </HStack>
</VStack>

---

## Edge Cases to Consider

1. **Single digit**: `"1"` → digit 0 should appear 1 time, but it appears 0 times → `false`

2. **All zeros**: `"00"` → both positions expect 0 occurrences of digits 0 and 1, but digit 0 appears twice → `false`

3. **Valid single**: `"10"` → digit 0 appears 1 time (✓), digit 1 appears 0 times (✓) → `true`

---

## Follow-up Questions

1. **What if the string could be longer than 10?**
   - We'd need to handle digits > 9, possibly using a hash map instead of array

2. **What if we wanted to find all valid self-describing numbers of length n?**
   - This becomes a constraint satisfaction problem with backtracking

3. **Is there a mathematical pattern for valid numbers?**
   - Yes! Valid numbers have specific structural properties based on their length

---

This problem beautifully demonstrates how **constraint verification** and **frequency counting** work together in a self-referential system!