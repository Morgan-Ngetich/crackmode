import { VStack, HStack, Text } from "@chakra-ui/react"

# Two Sum

**Difficulty:** <span style={{color: "#4ade80"}}>Easy</span>  
**LeetCode:** [1. Two Sum](https://leetcode.com/problems/two-sum/)

---

## Problem

Given an array of integers `nums` and an integer `target`, return indices of the two numbers such that they add up to target.

You may assume that each input would have **exactly one solution**, and you may not use the same element twice.

You can return the answer in any order.

**Example 1:**
```
Input: nums = [2,7,11,15], target = 9
Output: [0,1]
Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].
```

**Example 2:**
```
Input: nums = [3,2,4], target = 6
Output: [1,2]
Explanation: Because nums[1] + nums[2] == 6, we return [1, 2].
```

**Example 3:**
```
Input: nums = [3,3], target = 6
Output: [0,1]
Explanation: Because nums[0] + nums[1] == 6, we return [0, 1].
```

---

## Simple Explanation

Think of this like **finding a pair of numbers that add up to your target**!

- You have a list of numbers: `[2, 7, 11, 15]`
- You want to find two that add up to `9`
- `2 + 7 = 9`, so return their positions `[0, 1]`

**The Key:** Use a hash map to store numbers you've seen and their indices, then check if the complement exists.

---

## Optimal Solutions

<TabbedCode
  files={[
    {
      title: "Python",
      language: "python",
      code: `def twoSum(nums, target):
    """
    Hash Map Approach - Most Efficient
    Time: O(n), Space: O(n)
    """
    num_map = {}  # Dictionary to store {value: index}
    
    for i, num in enumerate(nums):
        complement = target - num
        
        # Check if complement exists in our map
        if complement in num_map:
            return [num_map[complement], i]
        
        # Store current number and its index
        num_map[num] = i
    
    return []  # No solution found (shouldn't happen per problem statement)

def twoSum_brute_force(nums, target):
    """
    Brute Force Approach
    Time: O(n²), Space: O(1)
    """
    for i in range(len(nums)):
        for j in range(i + 1, len(nums)):
            if nums[i] + nums[j] == target:
                return [i, j]
    return []

def twoSum_two_pass(nums, target):
    """
    Two Pass Hash Map
    Time: O(n), Space: O(n)
    """
    # First pass: build the hash map
    num_map = {num: i for i, num in enumerate(nums)}
    
    # Second pass: find complement
    for i, num in enumerate(nums):
        complement = target - num
        if complement in num_map and num_map[complement] != i:
            return [i, num_map[complement]]
    return []`
    },
    {
      title: "JavaScript",
      language: "javascript",
      code: `function twoSum(nums, target) {
    // Hash Map Approach
    const numMap = new Map(); // Map to store {value: index}
    
    for (let i = 0; i < nums.length; i++) {
        const complement = target - nums[i];
        
        // Check if complement exists in our map
        if (numMap.has(complement)) {
            return [numMap.get(complement), i];
        }
        
        // Store current number and its index
        numMap.set(nums[i], i);
    }
    
    return []; // No solution found
}

function twoSum_bruteForce(nums, target) {
    // Brute Force Approach
    for (let i = 0; i < nums.length; i++) {
        for (let j = i + 1; j < nums.length; j++) {
            if (nums[i] + nums[j] === target) {
                return [i, j];
            }
        }
    }
    return [];
}

function twoSum_object(nums, target) {
    // Using plain object instead of Map
    const numMap = {};
    
    for (let i = 0; i < nums.length; i++) {
        const complement = target - nums[i];
        
        if (numMap.hasOwnProperty(complement)) {
            return [numMap[complement], i];
        }
        
        numMap[nums[i]] = i;
    }
    
    return [];
}`
    },
    {
      title: "Java",
      language: "java",
      code: `import java.util.HashMap;
import java.util.Map;

public class Solution {
    public int[] twoSum(int[] nums, int target) {
        // Hash Map Approach
        Map<Integer, Integer> numMap = new HashMap<>();
        
        for (int i = 0; i < nums.length; i++) {
            int complement = target - nums[i];
            
            // Check if complement exists in our map
            if (numMap.containsKey(complement)) {
                return new int[]{numMap.get(complement), i};
            }
            
            // Store current number and its index
            numMap.put(nums[i], i);
        }
        
        return new int[]{}; // No solution found
    }
    
    public int[] twoSum_bruteForce(int[] nums, int target) {
        // Brute Force Approach
        for (int i = 0; i < nums.length; i++) {
            for (int j = i + 1; j < nums.length; j++) {
                if (nums[i] + nums[j] == target) {
                    return new int[]{i, j};
                }
            }
        }
        return new int[]{};
    }
    
    public int[] twoSum_twoPass(int[] nums, int target) {
        // Two Pass Hash Map
        Map<Integer, Integer> numMap = new HashMap<>();
        
        // First pass: build the hash map
        for (int i = 0; i < nums.length; i++) {
            numMap.put(nums[i], i);
        }
        
        // Second pass: find complement
        for (int i = 0; i < nums.length; i++) {
            int complement = target - nums[i];
            if (numMap.containsKey(complement) && numMap.get(complement) != i) {
                return new int[]{i, numMap.get(complement)};
            }
        }
        
        return new int[]{};
    }
}`
    },
    {
      title: "C++",
      language: "cpp",
      code: `#include <vector>
#include <unordered_map>

class Solution {
public:
    std::vector<int> twoSum(std::vector<int>& nums, int target) {
        // Hash Map Approach
        std::unordered_map<int, int> numMap; // {value: index}
        
        for (int i = 0; i < nums.size(); i++) {
            int complement = target - nums[i];
            
            // Check if complement exists in our map
            if (numMap.find(complement) != numMap.end()) {
                return {numMap[complement], i};
            }
            
            // Store current number and its index
            numMap[nums[i]] = i;
        }
        
        return {}; // No solution found
    }

    std::vector<int> twoSum_bruteForce(std::vector<int>& nums, int target) {
        // Brute Force Approach
        for (int i = 0; i < nums.size(); i++) {
            for (int j = i + 1; j < nums.size(); j++) {
                if (nums[i] + nums[j] == target) {
                    return {i, j};
                }
            }
        }
        return {};
    }

    std::vector<int> twoSum_twoPass(std::vector<int>& nums, int target) {
        // Two Pass Hash Map
        std::unordered_map<int, int> numMap;
        
        // First pass: build the hash map
        for (int i = 0; i < nums.size(); i++) {
            numMap[nums[i]] = i;
        }
        
        // Second pass: find complement
        for (int i = 0; i < nums.size(); i++) {
            int complement = target - nums[i];
            if (numMap.find(complement) != numMap.end() && numMap[complement] != i) {
                return {i, numMap[complement]};
            }
        }
        
        return {};
    }
};`
    }
  ]}
/>

---

## Step-by-Step Walkthrough

### Hash Map Approach for nums = [2,7,11,15], target = 9

```
Step 1: i=0, num=2
        complement = 9 - 2 = 7
        7 not in numMap
        Store: numMap[2] = 0
        numMap = {2: 0}

Step 2: i=1, num=7
        complement = 9 - 7 = 2
        2 found in numMap at index 0
        Return [0, 1] ✓
```

### Brute Force Approach for nums = [3,2,4], target = 6

```
Step 1: i=0, j=1
        nums[0] + nums[1] = 3 + 2 = 5 ≠ 6

Step 2: i=0, j=2  
        nums[0] + nums[2] = 3 + 4 = 7 ≠ 6

Step 3: i=1, j=2
        nums[1] + nums[2] = 2 + 4 = 6 = 6 ✓
        Return [1, 2]
```

---

## Why Hash Map Works

<VStack align="start" spacing={2}>
  <HStack spacing={2}>
    <Text color="green.400" fontWeight="extrabold">Constant lookup</Text>
    <Text>- Hash map provides O(1) average time for lookups</Text>
  </HStack>

  <HStack spacing={2}>
    <Text color="green.400" fontWeight="extrabold">Complement search</Text>
    <Text>- Instead of checking all pairs, find what's needed: target - current</Text>
  </HStack>

  <HStack spacing={2}>
    <Text color="green.400" fontWeight="extrabold">Single pass</Text>
    <Text>- Build map and search simultaneously in one iteration</Text>
  </HStack>

  <HStack spacing={2}>
    <Text color="green.400" fontWeight="extrabold">Index preservation</Text>
    <Text>- Store both value and index to return positions, not values</Text>
  </HStack>
</VStack>

---

## Algorithm Comparison

### Hash Map vs Brute Force:

```
Hash Map Approach:
- Time: O(n) - single pass through array
- Space: O(n) - hash map storage
- Best for: Most cases, especially larger arrays

nums = [2, 7, 11, 15], target = 9
Iteration 1: Check if 7 exists → No, store 2→0
Iteration 2: Check if 2 exists → Yes! Return [0,1]

Brute Force Approach:  
- Time: O(n²) - nested loops
- Space: O(1) - no extra storage
- Best for: Very small arrays or memory-constrained systems

nums = [2, 7, 11, 15], target = 9
Check: 2+7=9 ✓ Return [0,1]
(Would check 2+11, 2+15, 7+11, 7+15, 11+15 if needed)
```

---

## Edge Cases

```python
# Test cases:
print(twoSum([2, 7, 11, 15], 9))     # [0, 1] - normal case
print(twoSum([3, 2, 4], 6))          # [1, 2] - middle elements  
print(twoSum([3, 3], 6))             # [0, 1] - duplicate numbers
print(twoSum([-1, -2, -3, -4, -5], -8)) # [2, 4] - negative numbers
print(twoSum([0, 4, 3, 0], 0))       # [0, 3] - zeros
print(twoSum([-3, 4, 3, 90], 0))     # [0, 2] - sum to zero
```

---

## Common Mistakes to Avoid

1. **Using same element twice:** Make sure indices are different when complement equals current number

2. **Wrong return format:** Return indices, not the actual values

3. **Hash collision handling:** Use proper hash map implementation, not naive approaches

4. **Index out of bounds:** Ensure you're not accessing invalid array indices

5. **Assuming sorted input:** The array is not necessarily sorted

---

## Complexity Analysis

<Text color="green.400" fontWeight="bold">Hash Map Approach (Optimal):</Text>
<Text ml={4} as="li">**Time:** O(n) - Single pass through array</Text>
<Text ml={4} as="li">**Space:** O(n) - Hash map can store up to n elements</Text>

<Text color="green.400" fontWeight="bold" mt={2}>Brute Force Approach:</Text>
<Text ml={4} as="li">**Time:** O(n²) - Nested loops check all pairs</Text>
<Text ml={4} as="li">**Space:** O(1) - No extra space used</Text>

<Text color="green.400" fontWeight="bold" mt={2}>Two Pass Hash Map:</Text>
<Text ml={4} as="li">**Time:** O(n) - Two separate O(n) passes</Text>
<Text ml={4} as="li">**Space:** O(n) - Hash map storage</Text>

---

## Pattern Recognition

This problem demonstrates key patterns:
- **Hash Map for Lookups**: Trading space for time complexity
- **Complement Search**: Finding pairs by searching for target - current
- **Index Tracking**: Storing both values and positions
- **Early Termination**: Returning as soon as solution is found

You'll see similar patterns in:
- Three Sum / Four Sum problems
- Subarray sum problems
- Finding pairs with specific properties
- Anagram detection
- Frequency counting problems

---

## Real-World Applications

- **Financial Systems**: Finding transactions that sum to specific amounts
- **Inventory Management**: Pairing items to meet weight/value targets  
- **Gaming**: Finding combinations of items/skills that reach targets
- **Data Analysis**: Identifying correlated data points
- **Recommendation Systems**: Finding complementary products/content

---

## Visual Representation

```
Array: [2, 7, 11, 15], Target: 9

Hash Map Approach Visualization:
Step 1: num=2, complement=7
        numMap: {2: 0}
        
Step 2: num=7, complement=2  
        Check numMap: 2 exists at index 0
        Found pair: indices [0, 1]

Index:  0  1  2   3
Array: [2, 7, 11, 15]
        ↑  ↑
        |  |
        └──┘ → Sum = 9 ✓

Time taken: 2 iterations instead of checking all 6 possible pairs
```

---

## Follow-up Questions

**Q: Can you solve it in less than O(n) time complexity?**
A: No, we need to examine each element at least once, so O(n) is optimal.

**Q: What if the array is sorted?**
A: Use two pointers (left=0, right=n-1) moving towards each other based on sum comparison.

**Q: What if there are multiple valid pairs?**
A: The problem guarantees exactly one solution, but you could return the first found or all pairs.

**Q: What if no solution exists?**
A: Return empty array or throw exception (problem states solution always exists).