import { VStack, HStack, Text } from "@chakra-ui/react"

# Greatest Common Divisor of Strings

**Difficulty:** <span style={{color: "#4ade80"}}>Easy</span>  
**LeetCode:** [1071. Greatest Common Divisor of Strings](https://leetcode.com/problems/greatest-common-divisor-of-strings/)

---

## Problem

For two strings `s` and `t`, we say `t` divides `s` if and only if `s = t + t + t + ... + t` (i.e., `t` is concatenated with itself one or more times).

Given two strings `str1` and `str2`, return the **largest** string `x` such that `x` divides both `str1` and `str2`.

**Example 1:**
```
Input: str1 = "ABCABC", str2 = "ABC"
Output: "ABC"
Explanation: "ABC" divides "ABCABC" (ABC + ABC) and divides "ABC" (ABC).
```

**Example 2:**
```
Input: str1 = "ABABAB", str2 = "ABAB"
Output: "AB"
Explanation: "AB" divides "ABABAB" (AB+AB+AB) and "ABAB" (AB+AB).
```

**Example 3:**
```
Input: str1 = "LEET", str2 = "CODE"
Output: ""
Explanation: There is no string that divides both "LEET" and "CODE".
```

---

## Simple Explanation

Think of this like finding the **greatest common factor** but for strings!

Just like numbers have common factors:
- 12 = 3 × 4, 18 = 3 × 6 → GCD is 3
- "ABCABC" = "ABC" × 2, "ABC" = "ABC" × 1 → GCD is "ABC"

**Key insight:** If two strings share a common divisor, then concatenating them in different orders should give the same result!

---

## Solution

<TabbedCode
  files={[
    {
      title: "JavaScript",
      language: "javascript",
      code: `function gcdOfStrings(str1, str2) {
  // Check if concatenation works both ways
  if (str1 + str2 !== str2 + str1) {
    return '';
  }
  
  // Helper function to find GCD of two numbers
  const gcd = (a, b) => b === 0 ? a : gcd(b, a % b);
  
  // Find GCD of the lengths
  const gcdLength = gcd(str1.length, str2.length);
  
  // Return the substring of that length
  return str1.substring(0, gcdLength);
}`
    },
    {
      title: "Python",
      language: "python",
      code: `def gcd_of_strings(str1, str2):
    # Check if concatenation works both ways
    if str1 + str2 != str2 + str1:
        return ""
    
    # Helper function to find GCD of two numbers
    def gcd(a, b):
        return a if b == 0 else gcd(b, a % b)
    
    # Find GCD of the lengths
    gcd_length = gcd(len(str1), len(str2))
    
    # Return the substring of that length
    return str1[:gcd_length]`
    },
    {
      title: "C++",
      language: "cpp",
      code: `#include <string>
using namespace std;

class Solution {
public:
    string gcdOfStrings(string str1, string str2) {
        // Check if concatenation works both ways
        if (str1 + str2 != str2 + str1) {
            return "";
        }
        
        // Find GCD of the lengths
        int gcdLength = gcd(str1.length(), str2.length());
        
        // Return the substring of that length
        return str1.substr(0, gcdLength);
    }
    
private:
    int gcd(int a, int b) {
        return b == 0 ? a : gcd(b, a % b);
    }
};`
    },
    {
      title: "Java",
      language: "java",
      code: `public class GCDOfStrings {
    public static String gcdOfStrings(String str1, String str2) {
        // Check if concatenation works both ways
        if (!(str1 + str2).equals(str2 + str1)) {
            return "";
        }
        
        // Find GCD of the lengths
        int gcdLength = gcd(str1.length(), str2.length());
        
        // Return the substring of that length
        return str1.substring(0, gcdLength);
    }
    
    private static int gcd(int a, int b) {
        return b == 0 ? a : gcd(b, a % b);
    }
}`
    },
  ]}
/>

---

## Step-by-Step Walkthrough

Let's trace through `str1 = "ABCABC"`, `str2 = "ABC"`:

```
Step 1: Check if common divisor exists
        str1 + str2 = "ABCABC" + "ABC" = "ABCABCABC"
        str2 + str1 = "ABC" + "ABCABC" = "ABCABCABC"
        ✓ They are equal, so common divisor exists

Step 2: Find GCD of lengths
        str1.length = 6, str2.length = 3
        gcd(6, 3) = gcd(3, 6%3) = gcd(3, 0) = 3

Step 3: Return substring
        str1.substring(0, 3) = "ABC"

Result: "ABC"
Let's verify: "ABCABC" = "ABC" + "ABC" ✓ and "ABC" = "ABC" ✓
```


---

## Why the Concatenation Check Works

This is the **key insight**: If strings have a common divisor, then:

```
str1 = pattern × m
str2 = pattern × n

Therefore:
str1 + str2 = (pattern × m) + (pattern × n) = pattern × (m + n)
str2 + str1 = (pattern × n) + (pattern × m) = pattern × (n + m)

Since addition is commutative: m + n = n + m
So: str1 + str2 = str2 + str1
```

If concatenation gives different results, no common pattern exists!

---

## Complexity Analysis

<Text color="green.400" fontWeight="bold">Time Complexity: O(min(m, n))</Text>
<Text ml={4} as="li">Concatenation check: O(m + n)</Text>
<Text ml={4} as="li"> GCD calculation: O(log(min(m, n))) </Text>
<Text ml={4} as="li"> Overall: O(m + n) for the concatenation dominates </Text>

<Text color="green.400" fontWeight="bold" mt={4}>Space Complexity: O(m + n)</Text>
<Text ml={4}  as="li"> We build a new string containing all characters</Text>

---

## Key Insights

<VStack align="start" gap={2}>
  <HStack gap={2}>
    <Text color="orange.400" fontWeight="extrabold">Mathematical insight</Text>
    <Text>- GCD concept applies to strings through repetition</Text>
  </HStack>

  <HStack gap={2}>
    <Text color="orange.400" fontWeight="extrabold">Concatenation test</Text>
    <Text>- str1+str2 == str2+str1 iff common divisor exists</Text>
  </HStack>

  <HStack gap={2}>
    <Text color="orange.400" fontWeight="extrabold">Length relationship</Text>
    <Text>- GCD length = GCD of string lengths</Text>
  </HStack>

  <HStack gap={2}>
    <Text color="orange.400" fontWeight="extrabold">Early termination</Text>
    <Text>- Concatenation check eliminates impossible cases</Text>
  </HStack>
</VStack>

---

This problem beautifully combines string manipulation with number theory concepts!