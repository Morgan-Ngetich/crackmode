import { VStack, HStack, Text } from "@chakra-ui/react"


# Product of Array Except Self

**Difficulty:** <span style={{color: "#fbbf24"}}>Medium</span>  
**LeetCode:** [238. Product of Array Except Self](https://leetcode.com/problems/product-of-array-except-self/)

---

## Problem

Given an integer array `nums`, return an array `answer` such that `answer[i]` is equal to the **product of all the elements** of `nums` except `nums[i]`.

The product of any prefix or suffix of `nums` is **guaranteed** to fit in a **32-bit** integer.

You must write an algorithm that runs in **O(n)** time and without using the **division operator**.

**Example 1:**
```
Input: nums = [1,2,3,4]
Output: [24,12,8,6]
Explanation:
- answer[0] = 2*3*4 = 24
- answer[1] = 1*3*4 = 12
- answer[2] = 1*2*4 = 8
- answer[3] = 1*2*3 = 6
```

**Example 2:**
```
Input: nums = [-1,1,0,-3,3]
Output: [0,0,9,0,0]
Explanation:
- answer[0] = 1*0*(-3)*3 = 0
- answer[1] = (-1)*0*(-3)*3 = 0
- answer[2] = (-1)*1*(-3)*3 = 9
- answer[3] = (-1)*1*0*3 = 0
- answer[4] = (-1)*1*0*(-3) = 0
```

---

## Simple Explanation

Think of this as **"what's the product if I remove this element?"**

**Key insight:** For each position, we need:
- **Left side product** × **Right side product**

```
Array: [1, 2, 3, 4]
Index:  0  1  2  3

For index 1 (value 2):
- Left product:  1 (just 1)
- Right product: 3*4 = 12
- Result: 1 * 12 = 12
```

We can do this in **two passes**: left-to-right, then right-to-left!

---

## Solution

<TabbedCode
  files={[
    {
      title: "JavaScript",
      language: "javascript",
      code: `function productExceptSelf(nums) {
  const result = new Array(nums.length);
  
  // First pass: calculate left products
  result[0] = 1;
  for (let i = 1; i < nums.length; i++) {
    result[i] = result[i - 1] * nums[i - 1];
  }
  
  // Second pass: multiply by right products
  let rightProduct = 1;
  for (let i = nums.length - 1; i >= 0; i--) {
    result[i] *= rightProduct;
    rightProduct *= nums[i];
  }
  
  return result;
}`
    },
    {
      title: "Python",
      language: "python",
      code: `def product_except_self(nums):
    n = len(nums)
    result = [0] * n
    
    # First pass: calculate left products
    result[0] = 1
    for i in range(1, n):
        result[i] = result[i - 1] * nums[i - 1]
    
    # Second pass: multiply by right products
    right_product = 1
    for i in range(n - 1, -1, -1):
        result[i] *= right_product
        right_product *= nums[i]
    
    return result`
    },
    {
      title: "C++",
      language: "cpp",
      code: `#include <vector>
using namespace std;

vector<int> productExceptSelf(vector<int>& nums) {
    int n = nums.size();
    vector<int> result(n);
    
    // First pass: calculate left products
    result[0] = 1;
    for (int i = 1; i < n; i++) {
        result[i] = result[i - 1] * nums[i - 1];
    }
    
    // Second pass: multiply by right products
    int rightProduct = 1;
    for (int i = n - 1; i >= 0; i--) {
        result[i] *= rightProduct;
        rightProduct *= nums[i];
    }
    
    return result;
}`
    },
    {
      title: "Java",
      language: "java",
      code: `public class ProductExceptSelf {
    public static int[] productExceptSelf(int[] nums) {
        int n = nums.length;
        int[] result = new int[n];
        
        // First pass: calculate left products
        result[0] = 1;
        for (int i = 1; i < n; i++) {
            result[i] = result[i - 1] * nums[i - 1];
        }
        
        // Second pass: multiply by right products
        int rightProduct = 1;
        for (int i = n - 1; i >= 0; i--) {
            result[i] *= rightProduct;
            rightProduct *= nums[i];
        }
        
        return result;
    }
}`
    },
  ]}
/>

---

## Step-by-Step Walkthrough

Let's trace through `nums = [1,2,3,4]`:

```
Initial: nums = [1, 2, 3, 4]
         result = [_, _, _, _]

PASS 1 - Left products:
result[0] = 1                    → [1, _, _, _]
result[1] = result[0] * nums[0] = 1 * 1 = 1  → [1, 1, _, _]
result[2] = result[1] * nums[1] = 1 * 2 = 2  → [1, 1, 2, _]
result[3] = result[2] * nums[2] = 2 * 3 = 6  → [1, 1, 2, 6]

PASS 2 - Multiply by right products:
rightProduct = 1

i=3: result[3] *= rightProduct = 6 * 1 = 6   → [1, 1, 2, 6]
     rightProduct *= nums[3] = 1 * 4 = 4

i=2: result[2] *= rightProduct = 2 * 4 = 8   → [1, 1, 8, 6]
     rightProduct *= nums[2] = 4 * 3 = 12

i=1: result[1] *= rightProduct = 1 * 12 = 12 → [1, 12, 8, 6]
     rightProduct *= nums[1] = 12 * 2 = 24

i=0: result[0] *= rightProduct = 1 * 24 = 24 → [24, 12, 8, 6]
     rightProduct *= nums[0] = 24 * 1 = 24

Final result: [24, 12, 8, 6]
```

---

## Visual Understanding

For `nums = [1, 2, 3, 4]`:

```
Index:     0   1   2   3
Values:   [1] [2] [3] [4]

Left products (what's to the left):
result[0] = 1           (nothing to left)
result[1] = 1           (1)
result[2] = 1*2 = 2     (1,2)  
result[3] = 1*2*3 = 6   (1,2,3)

Right products (what's to the right):
result[3] *= 1          (nothing to right)
result[2] *= 4 = 2*4 = 8    (4)
result[1] *= 3*4 = 1*12 = 12   (3,4)
result[0] *= 2*3*4 = 1*24 = 24 (2,3,4)
```

---

## Alternative Solution (With Extra Arrays)

<TabbedCode
  files={[
    {
      title: "JavaScript",
      language: "javascript",
      code: `function productExceptSelf(nums) {
  const n = nums.length;
  const leftProducts = new Array(n);
  const rightProducts = new Array(n);
  const result = new Array(n);
  
  // Calculate left products
  leftProducts[0] = 1;
  for (let i = 1; i < n; i++) {
    leftProducts[i] = leftProducts[i - 1] * nums[i - 1];
  }
  
  // Calculate right products
  rightProducts[n - 1] = 1;
  for (let i = n - 2; i >= 0; i--) {
    rightProducts[i] = rightProducts[i + 1] * nums[i + 1];
  }
  
  // Multiply left and right products
  for (let i = 0; i < n; i++) {
    result[i] = leftProducts[i] * rightProducts[i];
  }
  
  return result;
}`
    },
    {
      title: "Python",
      language: "python",
      code: `def product_except_self(nums):
    n = len(nums)
    left_products = [0] * n
    right_products = [0] * n
    result = [0] * n
    
    # Calculate left products
    left_products[0] = 1
    for i in range(1, n):
        left_products[i] = left_products[i - 1] * nums[i - 1]
    
    # Calculate right products
    right_products[n - 1] = 1
    for i in range(n - 2, -1, -1):
        right_products[i] = right_products[i + 1] * nums[i + 1]
    
    # Multiply left and right products
    for i in range(n):
        result[i] = left_products[i] * right_products[i]
    
    return result`
    },
  ]}
/>

---

## Complexity Analysis

**Time Complexity: O(n)**
- First pass through array: O(n)
- Second pass through array: O(n)
- Total: O(n)

**Space Complexity: O(1)**
- Only using the output array and a single variable
- Output array doesn't count toward space complexity

---

## Key Insights

<VStack align="start" spacing={2}>
  <HStack spacing={2}>
    <Text color="orange.400" fontWeight="extrabold">Two-pass technique</Text>
    <Text>- Left products, then right products</Text>
  </HStack>

  <HStack spacing={2}>
    <Text color="orange.400" fontWeight="extrabold">Space optimization</Text>
    <Text>- Use output array to store intermediate results</Text>
  </HStack>

  <HStack spacing={2}>
    <Text color="orange.400" fontWeight="extrabold">No division needed</Text>
    <Text>- Handles zeros naturally without special cases</Text>
  </HStack>

  <HStack spacing={2}>
    <Text color="orange.400" fontWeight="extrabold">Prefix/suffix pattern</Text>
    <Text>- Common technique for "except self" problems</Text>
  </HStack>
</VStack>

---

This problem demonstrates the powerful **prefix/suffix sum** pattern that appears in many array problems!