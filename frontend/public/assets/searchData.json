[
  {
    "id": "introduction",
    "title": "Introduction",
    "content": "CRACK MODE ACTIVE  Welcome to CrackMode! The ultimate community for crushing LeetCode and mastering algorithms. Join elite coders who don t just solve problems they dominate them!    Start Grinding Join Community    What Makes CrackMode Different? CrackMode isn t just another coding community   it s a movement. We believe consistent practice and accountability are the fastest ways to grow as a developer. Why We re Different - Community-Driven Members push each other to solve LeetCode problems daily. Everyone is both a learner and a motivator. - Accountability First Progress comes from discipline, not just motivation. The community ensures no one falls off track. - Practical Problem-Solving Beyond streaks, we discuss patterns, optimization, and real-world applications. - Growth-Oriented Perfect for FAANG prep or sharpening DSA skills with peers who keep you consistent. The CrackMode Mindset - Fail fast, learn faster. - Celebrate progress, not perfection. - One problem a day compounds into mastery. --- CrackMode Daily Grinding Schedule Daily Grinding Sessions We run structured sessions every day   join live or catch up with recordings anytime.   This Week s Themes      This Week s Themes   Community Progress      Community Progress",
    "excerpt": "CRACK MODE ACTIVE Welcome to CrackMode! The ultimate community for crushing LeetCode and mastering algorithms.",
    "url": "/docs/introduction",
    "canonicalUrl": "https://crackmode.vercel.app/docs/introduction",
    "section": "Documentation",
    "tags": [
      "leetcode",
      "algorithm",
      "optimization",
      "coding",
      "problem-solving",
      "pattern"
    ],
    "headings": [
      {
        "level": 1,
        "text": "ðŸŒŸ What Makes CrackMode Different?",
        "id": "what-makes-crackmode-different"
      },
      {
        "level": 2,
        "text": "Why Weâ€™re Different",
        "id": "why-were-different"
      },
      {
        "level": 2,
        "text": "The CrackMode Mindset",
        "id": "the-crackmode-mindset"
      },
      {
        "level": 1,
        "text": "CrackMode Daily Grinding Schedule",
        "id": "crackmode-daily-grinding-schedule"
      }
    ],
    "publishedAt": "2026-01-04T04:18:51.301Z",
    "updatedAt": "2026-01-04T04:18:51.301Z",
    "author": "Morgan Ngetich",
    "readingTime": 1,
    "seo": {
      "title": "Introduction | Crackmode Documentation",
      "description": "CRACK MODE ACTIVE Welcome to CrackMode! The ultimate community for crushing LeetCode and mastering algorithms.",
      "keywords": "introduction, leetcode, algorithm, optimization, coding, problem-solving, pattern, community, crackmode, grinding, progress",
      "robots": "index,follow",
      "jsonLd": "{\"@context\":\"https://schema.org\",\"@type\":\"Article\",\"headline\":\"Introduction\",\"description\":\"CRACK MODE ACTIVE Welcome to CrackMode! The ultimate community for crushing LeetCode and mastering algorithms.\",\"url\":\"https://crackmode.vercel.app/docs/introduction\",\"datePublished\":\"2026-01-04T04:18:51.301Z\",\"dateModified\":\"2026-01-04T04:18:51.301Z\",\"author\":{\"@type\":\"Person\",\"name\":\"Morgan Ngetich\"},\"publisher\":{\"@type\":\"Organization\",\"name\":\"CrackMode\",\"logo\":{\"@type\":\"ImageObject\",\"url\":\"https://crackmode.vercel.app/group.png\"}},\"mainEntityOfPage\":{\"@type\":\"WebPage\",\"@id\":\"https://crackmode.vercel.app/docs/introduction\"},\"wordCount\":105,\"timeRequired\":\"PT1M\",\"inLanguage\":\"en-US\",\"isAccessibleForFree\":true}"
    },
    "socialMedia": {
      "ogTitle": "Introduction | Crackmode Documentation",
      "ogDescription": "The ultimate community for crushing LeetCode</Text> and mastering algorithms</Text>. Join elite coders who don't just solve problemsâ€”they dominate</Text> them!",
      "ogImage": "https://crackmode.vercel.app/api/v1/og?title=Introduction&description=The+ultimate+community+for+crushing+LeetCode%3C%2FText%3E+and+mastering+algorithms%3C%2FText%3E.+Join+elite+coders+who+don%27t+just+so...&section=Documentation&theme=crackmode",
      "twitterTitle": "Introduction | Crackmode Documentation",
      "twitterDescription": "The ultimate community for crushing LeetCode</Text> and mastering algorithms</Text>. Join elite coders who don't just solve problemsâ€”they dominate</Text> them!",
      "twitterImage": "https://crackmode.vercel.app/api/v1/og?title=Introduction&description=The+ultimate+community+for+crushing+LeetCode%3C%2FText%3E+and+mastering+algorithms%3C%2FText%3E.+Join+elite+coders+who+don%27t+just+so...&section=Documentation&theme=crackmode"
    }
  },
  {
    "id": "leetcode75/arrays-strings",
    "title": "Arrays Strings",
    "content": "Arrays   Strings Overview  LeetCode 75  Welcome to the Arrays   Strings section! This foundational module introduces you to the most essential data structures in programming and sets the stage for everything that follows in your coding journey. --- What You ll Learn Arrays and strings form the backbone of algorithmic problem-solving. In this section, you ll develop intuition around the most fundamental patterns that appear across countless coding interviews and real-world applications. Core Concepts String Manipulation - Character-by-character processing - Pattern matching and recognition - Building and transforming strings efficiently Array Traversal Techniques - Single and multiple pointer approaches - Forward and backward iteration strategies - Efficient element comparison methods Optimization Strategies - When to use extra space vs. in-place solutions - Recognizing opportunities for early termination - Balancing time and space complexity trade-offs --- Key Patterns You ll Master Two Pointers Technique Learn to use dual index tracking to solve problems that would otherwise require nested loops. This elegant approach helps you: - Compare elements from different positions - Process data from both ends simultaneously - Avoid redundant comparisons You ll see this pattern in palindrome checking, merging operations, and array reversal problems. Sliding Window Approach Discover how to handle dynamic subarray and substring problems by maintaining a  window  of elements: - Process contiguous elements efficiently - Expand and contract your focus area - Avoid recalculating overlapping regions Perfect for problems involving consecutive elements or substring analysis. Hash Maps for Smart Counting Master the art of frequency counting and fast lookups: - Track character or element occurrences - Enable O 1  retrieval of previously seen data - Solve  two sum  style problems elegantly Essential for anagram detection, duplicate finding, and optimization challenges. --- Problem Categories You ll Encounter String Processing Challenges - Alternating Operations: Learn to merge and interweave strings using systematic approaches - Mathematical String Properties: Explore how mathematical concepts like GCD apply to string patterns - Pattern Recognition: Develop skills to identify repeating structures and divisibility Array Analysis Problems - Comparative Analysis: Determine relative standings and maximum potential outcomes - Element Relationships: Understand how individual elements relate to the whole dataset - Conditional Logic: Master boolean array generation based on specific criteria Optimization Scenarios - Space vs. Time Trade-offs: Learn when to use additional memory for faster execution - Single vs. Multiple Passes: Understand when one traversal is sufficient vs. when multiple passes are needed - Early Termination: Recognize opportunities to stop processing early --- Skills You ll Develop Pattern Recognition By the end of this section, you ll quickly identify: - When a problem calls for two pointers vs. sliding window - Whether hash maps will provide the optimal solution - How to break down complex string operations into manageable steps Problem-Solving Approach You ll develop a systematic method for tackling new challenges: 1. Pattern Identification: Quickly categorize the problem type 2. Edge Case Consideration: Automatically think about boundary conditions 3. Complexity Analysis: Evaluate solutions before implementation 4. Iterative Optimization: Start simple, then enhance Interview Readiness These fundamentals prepare you for more advanced topics while building confidence in: - Clear problem decomposition - Efficient algorithm selection - Code organization and readability - Time and space complexity discussions --- What Makes This Section Special Building Block Approach Every concept here serves as a foundation for more advanced algorithms. The two-pointer technique you learn here will be crucial for tree traversals later. Hash map usage here prepares you for graph algorithms. Real-World Relevance These aren t just interview problems they re practical skills used daily in software development: - String processing for data validation - Array manipulation for data transformation - Pattern matching for search functionality Progressive Difficulty Start with straightforward problems that build confidence, then gradually tackle more nuanced challenges that combine multiple patterns. --- Getting the Most From This Section Focus on Understanding, Not Memorization Rather than memorizing solutions, concentrate on: - Why certain patterns work for specific problem types - How to recognize when to apply each technique - The trade-offs between different approaches Practice Pattern Recognition Before jumping into coding: - Read the problem statement carefully - Identify which pattern s  might apply - Consider multiple approaches before choosing one Build Your Intuition Ask yourself: - What makes this problem unique? - Have I seen similar patterns before? - What would happen with edge cases? --- Ready to Begin? This section sets you up for success in the entire LeetCode 75 journey. The patterns you ll learn here appear throughout the remaining categories from linked lists to dynamic programming. Take your time with each concept. Mastery here pays dividends later! --- Next up: Dive into the first problem and start building your pattern recognition skills!",
    "excerpt": "Arrays Strings Overview LeetCode 75 Welcome to the Arrays Strings section! This foundational module introduces you to the most essential data structures in...",
    "url": "/docs/leetcode75/arrays-strings",
    "canonicalUrl": "https://crackmode.vercel.app/docs/leetcode75/arrays-strings",
    "section": "LeetCode 75",
    "tags": [
      "advanced",
      "array",
      "arrays",
      "string",
      "strings",
      "tree"
    ],
    "headings": [
      {
        "level": 1,
        "text": "Arrays & Strings Overview (LeetCode 75)",
        "id": "arrays-strings-overview-leetcode-75"
      },
      {
        "level": 2,
        "text": "What You'll Learn",
        "id": "what-youll-learn"
      },
      {
        "level": 3,
        "text": "Core Concepts",
        "id": "core-concepts"
      },
      {
        "level": 2,
        "text": "Key Patterns You'll Master",
        "id": "key-patterns-youll-master"
      },
      {
        "level": 3,
        "text": "Two Pointers Technique",
        "id": "two-pointers-technique"
      },
      {
        "level": 3,
        "text": "Sliding Window Approach",
        "id": "sliding-window-approach"
      },
      {
        "level": 3,
        "text": "Hash Maps for Smart Counting",
        "id": "hash-maps-for-smart-counting"
      },
      {
        "level": 2,
        "text": "Problem Categories You'll Encounter",
        "id": "problem-categories-youll-encounter"
      },
      {
        "level": 3,
        "text": "String Processing Challenges",
        "id": "string-processing-challenges"
      },
      {
        "level": 3,
        "text": "Array Analysis Problems",
        "id": "array-analysis-problems"
      },
      {
        "level": 3,
        "text": "Optimization Scenarios",
        "id": "optimization-scenarios"
      },
      {
        "level": 2,
        "text": "Skills You'll Develop",
        "id": "skills-youll-develop"
      },
      {
        "level": 3,
        "text": "Pattern Recognition",
        "id": "pattern-recognition"
      },
      {
        "level": 3,
        "text": "Problem-Solving Approach",
        "id": "problem-solving-approach"
      },
      {
        "level": 3,
        "text": "Interview Readiness",
        "id": "interview-readiness"
      },
      {
        "level": 2,
        "text": "What Makes This Section Special",
        "id": "what-makes-this-section-special"
      },
      {
        "level": 3,
        "text": "Building Block Approach",
        "id": "building-block-approach"
      },
      {
        "level": 3,
        "text": "Real-World Relevance",
        "id": "real-world-relevance"
      },
      {
        "level": 3,
        "text": "Progressive Difficulty",
        "id": "progressive-difficulty"
      },
      {
        "level": 2,
        "text": "Getting the Most From This Section",
        "id": "getting-the-most-from-this-section"
      },
      {
        "level": 3,
        "text": "Focus on Understanding, Not Memorization",
        "id": "focus-on-understanding-not-memorization"
      },
      {
        "level": 3,
        "text": "Practice Pattern Recognition",
        "id": "practice-pattern-recognition"
      },
      {
        "level": 3,
        "text": "Build Your Intuition",
        "id": "build-your-intuition"
      },
      {
        "level": 2,
        "text": "Ready to Begin?",
        "id": "ready-to-begin"
      }
    ],
    "publishedAt": "2026-01-04T04:18:51.309Z",
    "updatedAt": "2026-01-04T04:18:51.309Z",
    "author": "Morgan Ngetich",
    "readingTime": 4,
    "seo": {
      "title": "Arrays Strings | Crackmode Documentation",
      "description": "Arrays Strings Overview LeetCode 75 Welcome to the Arrays Strings section! This foundational module introduces you to the most essential data structures in...",
      "keywords": "arrays, strings, advanced, array, string, tree, pattern, problem, problems, learn, patterns, crackmode, leetcode, algorithm",
      "robots": "index,follow",
      "jsonLd": "{\"@context\":\"https://schema.org\",\"@type\":\"Article\",\"headline\":\"Arrays Strings\",\"description\":\"Arrays Strings Overview LeetCode 75 Welcome to the Arrays Strings section! This foundational module introduces you to the most essential data structures in...\",\"url\":\"https://crackmode.vercel.app/docs/leetcode75/arrays-strings\",\"datePublished\":\"2026-01-04T04:18:51.309Z\",\"dateModified\":\"2026-01-04T04:18:51.309Z\",\"author\":{\"@type\":\"Person\",\"name\":\"Morgan Ngetich\"},\"publisher\":{\"@type\":\"Organization\",\"name\":\"CrackMode\",\"logo\":{\"@type\":\"ImageObject\",\"url\":\"https://crackmode.vercel.app/group.png\"}},\"mainEntityOfPage\":{\"@type\":\"WebPage\",\"@id\":\"https://crackmode.vercel.app/docs/leetcode75/arrays-strings\"},\"wordCount\":161,\"timeRequired\":\"PT4M\",\"inLanguage\":\"en-US\",\"isAccessibleForFree\":true}"
    },
    "socialMedia": {
      "ogTitle": "Arrays Strings | Crackmode Documentation",
      "ogDescription": "Arrays Strings Overview LeetCode 75 Welcome to the Arrays Strings section! This foundational module introduces you to the most essential data structures in...",
      "ogImage": "https://crackmode.vercel.app/api/v1/og?title=Arrays+Strings&description=Arrays+Strings+Overview+LeetCode+75+Welcome+to+the+Arrays+Strings+section%21+This+foundational+module+introduces+you+to+th...&section=Documentation&theme=crackmode",
      "twitterTitle": "Arrays Strings | Crackmode Documentation",
      "twitterDescription": "Arrays Strings Overview LeetCode 75 Welcome to the Arrays Strings section! This foundational module introduces you to the most essential data structures in...",
      "twitterImage": "https://crackmode.vercel.app/api/v1/og?title=Arrays+Strings&description=Arrays+Strings+Overview+LeetCode+75+Welcome+to+the+Arrays+Strings+section%21+This+foundational+module+introduces+you+to+th...&section=Documentation&theme=crackmode"
    }
  },
  {
    "id": "leetcode75/arrays-strings/gcd-of-strings",
    "title": "Gcd Of Strings",
    "content": "Greatest Common Divisor of Strings Difficulty: Easy LeetCode: 1071. Greatest Common Divisor of Strings --- Problem For two strings s and t, we say t divides s if and only if s   t   t   t   ...   t  i.e., t is concatenated with itself one or more times . Given two strings str1 and str2, return the largest string x such that x divides both str1 and str2. Example 1:    Input: str1    ABCABC , str2    ABC  Output:  ABC  Explanation:  ABC  divides  ABCABC   ABC   ABC  and divides  ABC   ABC .   Example 2:   Input: str1    ABABAB , str2    ABAB  Output:  AB  Explanation:  AB  divides  ABABAB   AB AB AB  and  ABAB   AB AB .   Example 3:   Input: str1    LEET , str2    CODE  Output:    Explanation: There is no string that divides both  LEET  and  CODE .   --- Simple Explanation Think of this like finding the greatest common factor but for strings! Just like numbers have common factors: - 12   3   4, 18   3   6   GCD is 3 -  ABCABC     ABC    2,  ABC     ABC    1   GCD is  ABC  Key insight: If two strings share a common divisor, then concatenating them in different orders should give the same result! --- Solution b     0 ? a : gcd b, a   b ;    Find GCD of the lengths const gcdLength   gcd str1.length, str2.length ;    Return the substring of that length return str1.substring 0, gcdLength ; , title:  Python , language:  python , code: def gcd_of_strings str1, str2 :   Check if concatenation works both ways if str1   str2 !  str2   str1: return      Helper function to find GCD of two numbers def gcd a, b : return a if b    0 else gcd b, a   b    Find GCD of the lengths gcd_length   gcd len str1 , len str2     Return the substring of that length return str1 :gcd_length  , title:  C   , language:  cpp , code:  include using namespace std; class Solution public: string gcdOfStrings string str1, string str2     Check if concatenation works both ways if  str1   str2 !  str2   str1  return   ;    Find GCD of the lengths int gcdLength   gcd str1.length  , str2.length   ;    Return the substring of that length return str1.substr 0, gcdLength ; private: int gcd int a, int b  return b    0 ? a : gcd b, a   b ; ; , title:  Java , language:  java , code: public class GCDOfStrings public static String gcdOfStrings String str1, String str2     Check if concatenation works both ways if  ! str1   str2 .equals str2   str1   return   ;    Find GCD of the lengths int gcdLength   gcd str1.length  , str2.length   ;    Return the substring of that length return str1.substring 0, gcdLength ; private static int gcd int a, int b  return b    0 ? a : gcd b, a   b ; ,      --- Step-by-Step Walkthrough Let s trace through str1    ABCABC , str2    ABC :    Step 1: Check if common divisor exists str1   str2    ABCABC     ABC     ABCABCABC  str2   str1    ABC     ABCABC     ABCABCABC    They are equal, so common divisor exists Step 2: Find GCD of lengths str1.length   6, str2.length   3 gcd 6, 3    gcd 3, 6 3    gcd 3, 0    3 Step 3: Return substring str1.substring 0, 3     ABC  Result:  ABC  Let s verify:  ABCABC     ABC     ABC    and  ABC     ABC      --- Why the Concatenation Check Works This is the key insight: If strings have a common divisor, then:   str1   pattern   m str2   pattern   n Therefore: str1   str2    pattern   m     pattern   n    pattern    m   n  str2   str1    pattern   n     pattern   m    pattern    n   m  Since addition is commutative: m   n   n   m So: str1   str2   str2   str1    If concatenation gives different results, no common pattern exists! --- Complexity Analysis Time Complexity: O min m, n   Concatenation check: O m   n  GCD calculation: O log min m, n    Overall: O m   n  for the concatenation dominates Space Complexity: O m   n  We build a new string containing all characters --- Key Insights Mathematical insight - GCD concept applies to strings through repetition Concatenation test - str1 str2    str2 str1 iff common divisor exists Length relationship - GCD length   GCD of string lengths Early termination - Concatenation check eliminates impossible cases --- This problem beautifully combines string manipulation with number theory concepts!",
    "excerpt": "Greatest Common Divisor of Strings Difficulty: Easy LeetCode: 1071. Greatest Common Divisor of Strings --- Problem For two strings s and t, we say t divides s...",
    "url": "/docs/leetcode75/arrays-strings/gcd-of-strings",
    "canonicalUrl": "https://crackmode.vercel.app/docs/leetcode75/arrays-strings/gcd-of-strings",
    "section": "LeetCode 75",
    "tags": [
      "easy",
      "array",
      "arrays",
      "string",
      "strings",
      "leetcode"
    ],
    "headings": [
      {
        "level": 1,
        "text": "Greatest Common Divisor of Strings",
        "id": "greatest-common-divisor-of-strings"
      },
      {
        "level": 2,
        "text": "Problem",
        "id": "problem"
      },
      {
        "level": 2,
        "text": "Simple Explanation",
        "id": "simple-explanation"
      },
      {
        "level": 2,
        "text": "Solution",
        "id": "solution"
      },
      {
        "level": 2,
        "text": "Step-by-Step Walkthrough",
        "id": "step-by-step-walkthrough"
      },
      {
        "level": 2,
        "text": "Why the Concatenation Check Works",
        "id": "why-the-concatenation-check-works"
      },
      {
        "level": 2,
        "text": "Complexity Analysis",
        "id": "complexity-analysis"
      },
      {
        "level": 2,
        "text": "Key Insights",
        "id": "key-insights"
      }
    ],
    "publishedAt": "2026-01-04T04:18:51.305Z",
    "updatedAt": "2026-01-04T04:18:51.305Z",
    "author": "Morgan Ngetich",
    "readingTime": 4,
    "seo": {
      "title": "Gcd Of Strings | Crackmode Documentation",
      "description": "Greatest Common Divisor of Strings Difficulty: Easy LeetCode: 1071. Greatest Common Divisor of Strings --- Problem For two strings s and t, we say t divides s...",
      "keywords": "strings, easy, array, arrays, string, leetcode, return, common, concatenation, pattern, crackmode, algorithm",
      "robots": "index,follow",
      "jsonLd": "{\"@context\":\"https://schema.org\",\"@type\":\"Article\",\"headline\":\"Gcd Of Strings\",\"description\":\"Greatest Common Divisor of Strings Difficulty: Easy LeetCode: 1071. Greatest Common Divisor of Strings --- Problem For two strings s and t, we say t divides s...\",\"url\":\"https://crackmode.vercel.app/docs/leetcode75/arrays-strings/gcd-of-strings\",\"datePublished\":\"2026-01-04T04:18:51.305Z\",\"dateModified\":\"2026-01-04T04:18:51.305Z\",\"author\":{\"@type\":\"Person\",\"name\":\"Morgan Ngetich\"},\"publisher\":{\"@type\":\"Organization\",\"name\":\"CrackMode\",\"logo\":{\"@type\":\"ImageObject\",\"url\":\"https://crackmode.vercel.app/group.png\"}},\"mainEntityOfPage\":{\"@type\":\"WebPage\",\"@id\":\"https://crackmode.vercel.app/docs/leetcode75/arrays-strings/gcd-of-strings\"},\"wordCount\":189,\"timeRequired\":\"PT4M\",\"inLanguage\":\"en-US\",\"isAccessibleForFree\":true}"
    },
    "socialMedia": {
      "ogTitle": "Gcd Of Strings | Crackmode Documentation",
      "ogDescription": "For two strings s and t, we say t divides s if and only if s = t + t + t + ... + t (i.e., t is concatenated with itself one or more times). Given two strings str1 and str2, return the largest string x such that x divides both str1 and str2.",
      "ogImage": "https://crackmode.vercel.app/api/v1/og?title=Gcd+Of+Strings&description=For+two+strings+s+and+t%2C+we+say+t+divides+s+if+and+only+if+s+%3D+t+%2B+t+%2B+t+%2B+...+%2B+t+%28i.e.%2C+t+is+concatenated+with+itself...&section=Documentation&theme=crackmode",
      "twitterTitle": "Gcd Of Strings | Crackmode Documentation",
      "twitterDescription": "For two strings s and t, we say t divides s if and only if s = t + t + t + ... + t (i.e., t is concatenated with itself one or more times). Given two strings str1 and str2, return the largest string x such that x divides both str1 and str2.",
      "twitterImage": "https://crackmode.vercel.app/api/v1/og?title=Gcd+Of+Strings&description=For+two+strings+s+and+t%2C+we+say+t+divides+s+if+and+only+if+s+%3D+t+%2B+t+%2B+t+%2B+...+%2B+t+%28i.e.%2C+t+is+concatenated+with+itself...&section=Documentation&theme=crackmode"
    }
  },
  {
    "id": "leetcode75/arrays-strings/increasing-triplet-subsequence",
    "title": "Increasing Triplet Subsequence",
    "content": "Increasing Triplet Subsequence Difficulty: Medium LeetCode: 334. Increasing Triplet Subsequence --- Problem Given an integer array nums, return true if there exists a triple of indices  i, j, k  such that i second   first return false; , title:  Python , language:  python , code: def increasing_triplet nums : first   float  inf     Smallest number so far second   float  inf     Second smallest number so far for num in nums: if num second   first return False , title:  C   , language:  cpp , code:  include  include using namespace std; bool increasingTriplet vector  nums  int first   INT_MAX;    Smallest number so far int second   INT_MAX;    Second smallest number so far for  int num : nums  if  num second   first return false; , title:  Java , language:  java , code: public class IncreasingTriplet public static boolean increasingTriplet int   nums  int first   Integer.MAX_VALUE;    Smallest number so far int second   Integer.MAX_VALUE;    Second smallest number so far for  int num : nums  if  num second   first return false; ,      --- Step-by-Step Walkthrough Let s trace through nums    2,1,5,0,4,6 :    Initial: first    , second     num   2: 2 1  first , 5 0  first , 4 0  first , 6   4  second    return true! Found triplet:  0, 4, 6  at positions  3, 4, 5    --- Why This Algorithm Works The magic: Even though we update first and second, we maintain the relationship:   When we find a number   second: - We know second was set when first 5, so triplet exists!   --- Visual Understanding   Array:  2, 1, 5, 0, 4, 6  Index: 0 1 2 3 4 5 Step by step: 2: first 2, second   1: first 1, second    1 is smaller than 2  5: first 1, second 5  5   1, so becomes second  0: first 0, second 5  0 is smaller than 1  4: first 0, second 4  4 is between 0 and 5  6: FOUND! 6   4   0  indices: some i nums i   for  let k   j   1; k nums j   return true;    Found increasing triplet return false;    Time: O n  , Space: O 1     This works but is too slow for large inputs , title:  Python , language:  python , code: def increasing_triplet nums : n   len nums    Try all possible triplets for i in range n - 2 : for j in range i   1, n - 1 : if nums j    nums i : for k in range j   1, n : if nums k    nums j : return True   Found increasing triplet return False Time: O n  , Space: O 1  This works but is too slow for large inputs ,      --- Edge Cases   javascript    Empty or small arrays increasingTriplet        false increasingTriplet  1      false increasingTriplet  1,2      false    Decreasing sequence increasingTriplet  5,4,3,2,1      false    All equal elements increasingTriplet  1,1,1,1,1      false    Minimum valid case increasingTriplet  1,2,3      true    With duplicates increasingTriplet  1,1,1,2,2,3      true    --- Complexity Analysis Time Complexity: O n  - Single pass through the array - Constant time operations for each element Space Complexity: O 1  - Only using two variables regardless of input size --- Key Insights Greedy approach - Always keep the smallest possible first and second Temporal relationships - Variables remember when relationships were established Early termination - Return true as soon as we find the third element State tracking - Two variables track the  best so far  candidates --- This problem showcases an elegant greedy algorithm that s both intuitive and mathematically sound!",
    "excerpt": "Increasing Triplet Subsequence Difficulty: Medium LeetCode: 334. Increasing Triplet Subsequence --- Problem Given an integer array nums, return true if there...",
    "url": "/docs/leetcode75/arrays-strings/increasing-triplet-subsequence",
    "canonicalUrl": "https://crackmode.vercel.app/docs/leetcode75/arrays-strings/increasing-triplet-subsequence",
    "section": "LeetCode 75",
    "tags": [
      "medium",
      "array",
      "arrays",
      "string",
      "strings",
      "greedy"
    ],
    "headings": [
      {
        "level": 1,
        "text": "Increasing Triplet Subsequence",
        "id": "increasing-triplet-subsequence"
      },
      {
        "level": 2,
        "text": "Problem",
        "id": "problem"
      },
      {
        "level": 2,
        "text": "Simple Explanation",
        "id": "simple-explanation"
      },
      {
        "level": 2,
        "text": "Solution",
        "id": "solution"
      },
      {
        "level": 2,
        "text": "Step-by-Step Walkthrough",
        "id": "step-by-step-walkthrough"
      },
      {
        "level": 2,
        "text": "Why This Algorithm Works",
        "id": "why-this-algorithm-works"
      },
      {
        "level": 2,
        "text": "Visual Understanding",
        "id": "visual-understanding"
      },
      {
        "level": 2,
        "text": "Alternative Solution (Brute Force)",
        "id": "alternative-solution-brute-force"
      },
      {
        "level": 1,
        "text": "Time: O(nÂ³), Space: O(1)",
        "id": "time-on-space-o1"
      },
      {
        "level": 1,
        "text": "This works but is too slow for large inputs`",
        "id": "this-works-but-is-too-slow-for-large-inputs"
      },
      {
        "level": 2,
        "text": "Edge Cases",
        "id": "edge-cases"
      },
      {
        "level": 2,
        "text": "Complexity Analysis",
        "id": "complexity-analysis"
      },
      {
        "level": 2,
        "text": "Key Insights",
        "id": "key-insights"
      }
    ],
    "publishedAt": "2026-01-04T04:18:51.305Z",
    "updatedAt": "2026-01-04T04:18:51.305Z",
    "author": "Morgan Ngetich",
    "readingTime": 3,
    "seo": {
      "title": "Increasing Triplet Subsequence | Crackmode Documentation",
      "description": "Increasing Triplet Subsequence Difficulty: Medium LeetCode: 334. Increasing Triplet Subsequence --- Problem Given an integer array nums, return true if there...",
      "keywords": "increasing, triplet, subsequence, medium, array, arrays, string, strings, greedy, second, return, increasingtriplet, smallest, number, crackmode, leetcode, algorithm",
      "robots": "index,follow",
      "jsonLd": "{\"@context\":\"https://schema.org\",\"@type\":\"Article\",\"headline\":\"Increasing Triplet Subsequence\",\"description\":\"Increasing Triplet Subsequence Difficulty: Medium LeetCode: 334. Increasing Triplet Subsequence --- Problem Given an integer array nums, return true if there...\",\"url\":\"https://crackmode.vercel.app/docs/leetcode75/arrays-strings/increasing-triplet-subsequence\",\"datePublished\":\"2026-01-04T04:18:51.305Z\",\"dateModified\":\"2026-01-04T04:18:51.305Z\",\"author\":{\"@type\":\"Person\",\"name\":\"Morgan Ngetich\"},\"publisher\":{\"@type\":\"Organization\",\"name\":\"CrackMode\",\"logo\":{\"@type\":\"ImageObject\",\"url\":\"https://crackmode.vercel.app/group.png\"}},\"mainEntityOfPage\":{\"@type\":\"WebPage\",\"@id\":\"https://crackmode.vercel.app/docs/leetcode75/arrays-strings/increasing-triplet-subsequence\"},\"wordCount\":147,\"timeRequired\":\"PT3M\",\"inLanguage\":\"en-US\",\"isAccessibleForFree\":true}"
    },
    "socialMedia": {
      "ogTitle": "Increasing Triplet Subsequence | Crackmode Documentation",
      "ogDescription": "Given an integer array nums, return true if there exists a triple of indices (i, j, k) such that i < j < k and nums[i] < nums[j] < nums[k]. If no such indices exists, return false.",
      "ogImage": "https://crackmode.vercel.app/api/v1/og?title=Increasing+Triplet+Subsequence&description=Given+an+integer+array+nums%2C+return+true+if+there+exists+a+triple+of+indices+%28i%2C+j%2C+k%29+such+that+i+%3C+j+%3C+k+and+nums%5Bi%5D+%3C...&section=Documentation&theme=crackmode",
      "twitterTitle": "Increasing Triplet Subsequence | Crackmode Documentation",
      "twitterDescription": "Given an integer array nums, return true if there exists a triple of indices (i, j, k) such that i < j < k and nums[i] < nums[j] < nums[k]. If no such indices exists, return false.",
      "twitterImage": "https://crackmode.vercel.app/api/v1/og?title=Increasing+Triplet+Subsequence&description=Given+an+integer+array+nums%2C+return+true+if+there+exists+a+triple+of+indices+%28i%2C+j%2C+k%29+such+that+i+%3C+j+%3C+k+and+nums%5Bi%5D+%3C...&section=Documentation&theme=crackmode"
    }
  },
  {
    "id": "leetcode75/arrays-strings/intro",
    "title": "Intro",
    "content": "What are Arrays   Strings? Before diving into problems, let s understand what we re working with. --- Array An array is a collection of items stored together and accessed by index. Think of it like a row of numbered boxes, each holding a value:   javascript numbers    5, 10, 15    - numbers 0    5 - numbers 1    10 - numbers 2    15 Arrays are great for: - Storing multiple items of the same type - Looping through data - Mathematical operations on lists - Keeping data organized in order --- String A string is a sequence of characters - like a word or sentence. Internally, it works like an array of characters:  javascript text    hello    - text 0     h  - text 1     e  - text 4     o  Strings are perfect for: - Handling names, messages, or any text - Text searching and manipulation - Pattern matching - Building user interfaces --- Key Similarities Both arrays and strings: - Use zero-based indexing  start counting from 0  - Have a length property - Can be iterated through with loops - Support many of the same operations  javascript    Both have length numbers.length    3 text.length    5    Both can be looped through for  let i   0; i Quick Comparison of Arrays vs Strings Feature Array String Data Type Any values Characters only Use Case Lists of items Words   sentences Access By index arr 0  By index str 0  Mutable Yes  can change  No  immutable  --- In Simple Terms - Array   List of values  1, 2, 3  - String   List of characters  abc   Think of a string as a special type of array that only holds characters! --- Ready to solve some problems? Let s start with the fundamentals!",
    "excerpt": "What are Arrays Strings? Before diving into problems, let s understand what we re working with. --- Array An array is a collection of items stored together and...",
    "url": "/docs/leetcode75/arrays-strings/intro",
    "canonicalUrl": "https://crackmode.vercel.app/docs/leetcode75/arrays-strings/intro",
    "section": "LeetCode 75",
    "tags": [
      "array",
      "arrays",
      "string",
      "strings",
      "searching",
      "leetcode"
    ],
    "headings": [
      {
        "level": 1,
        "text": "What are Arrays & Strings?",
        "id": "what-are-arrays-strings"
      },
      {
        "level": 2,
        "text": "Array",
        "id": "array"
      },
      {
        "level": 2,
        "text": "String",
        "id": "string"
      },
      {
        "level": 2,
        "text": "Key Similarities",
        "id": "key-similarities"
      },
      {
        "level": 2,
        "text": "Quick Comparison",
        "id": "quick-comparison"
      },
      {
        "level": 2,
        "text": "In Simple Terms",
        "id": "in-simple-terms"
      }
    ],
    "publishedAt": "2026-01-04T04:18:51.305Z",
    "updatedAt": "2026-01-04T04:18:51.305Z",
    "author": "Morgan Ngetich",
    "readingTime": 2,
    "seo": {
      "title": "Intro | Crackmode Documentation",
      "description": "What are Arrays Strings? Before diving into problems, let s understand what we re working with. --- Array An array is a collection of items stored together and...",
      "keywords": "intro, array, arrays, string, strings, searching, leetcode, numbers, items, crackmode, algorithm",
      "robots": "index,follow",
      "jsonLd": "{\"@context\":\"https://schema.org\",\"@type\":\"Article\",\"headline\":\"Intro\",\"description\":\"What are Arrays Strings? Before diving into problems, let s understand what we re working with. --- Array An array is a collection of items stored together and...\",\"url\":\"https://crackmode.vercel.app/docs/leetcode75/arrays-strings/intro\",\"datePublished\":\"2026-01-04T04:18:51.305Z\",\"dateModified\":\"2026-01-04T04:18:51.305Z\",\"author\":{\"@type\":\"Person\",\"name\":\"Morgan Ngetich\"},\"publisher\":{\"@type\":\"Organization\",\"name\":\"CrackMode\",\"logo\":{\"@type\":\"ImageObject\",\"url\":\"https://crackmode.vercel.app/group.png\"}},\"mainEntityOfPage\":{\"@type\":\"WebPage\",\"@id\":\"https://crackmode.vercel.app/docs/leetcode75/arrays-strings/intro\"},\"wordCount\":196,\"timeRequired\":\"PT2M\",\"inLanguage\":\"en-US\",\"isAccessibleForFree\":true}"
    },
    "socialMedia": {
      "ogTitle": "Intro | Crackmode Documentation",
      "ogDescription": "What are Arrays Strings? Before diving into problems, let s understand what we re working with. --- Array An array is a collection of items stored together and...",
      "ogImage": "https://crackmode.vercel.app/api/v1/og?title=Intro&description=What+are+Arrays+Strings%3F+Before+diving+into+problems%2C+let+s+understand+what+we+re+working+with.+---+Array+An+array+is+a...&section=Documentation&theme=crackmode",
      "twitterTitle": "Intro | Crackmode Documentation",
      "twitterDescription": "What are Arrays Strings? Before diving into problems, let s understand what we re working with. --- Array An array is a collection of items stored together and...",
      "twitterImage": "https://crackmode.vercel.app/api/v1/og?title=Intro&description=What+are+Arrays+Strings%3F+Before+diving+into+problems%2C+let+s+understand+what+we+re+working+with.+---+Array+An+array+is+a...&section=Documentation&theme=crackmode"
    }
  },
  {
    "id": "leetcode75/arrays-strings/kids-with-greatest-candies",
    "title": "Kids With Greatest Candies",
    "content": "Kids With the Greatest Number of Candies Difficulty: Easy LeetCode: 1431. Kids With the Greatest Number of Candies --- Problem There are n kids with candies. You are given an integer array candies, where each candies i  represents the number of candies the ith kid has, and an integer extraCandies, denoting the number of extra candies that you have. Return a boolean array result of length n, where result i  is true if, after giving the ith kid all the extraCandies, they will have the greatest number of candies among all the kids, or false otherwise. Note that multiple kids can have the greatest number of candies. Example 1:    Input: candies    2,3,5,1,3 , extraCandies   3 Output:  true,true,true,false,true  Explanation: If you give all extraCandies to: - Kid 1: 2   3   5 candies, which is the greatest among the kids - Kid 2: 3   3   6 candies, which is the greatest among the kids - Kid 3: 5   3   8 candies, which is the greatest among the kids - Kid 4: 1   3   4 candies, which is not the greatest among the kids - Kid 5: 3   3   6 candies, which is the greatest among the kids   Example 2:   Input: candies    4,2,1,1,2 , extraCandies   1 Output:  true,false,false,false,false  Explanation: There is only one kid who can have the greatest number of candies.   --- Simple Explanation Think of this as a  what if  game: 1. Find the kid who currently has the most candies 2. For each kid, ask:  If I give them ALL extra candies, will they have at least as many as the current leader?  3. If yes   true, if no   false It s like checking if each player can become the champion with a power-up! --- Solution candy   extraCandies    maxCandies ; , title:  Python , language:  python , code: def kids_with_candies candies, extra_candies :   Find the maximum candies any kid currently has max_candies   max candies    Check if each kid can reach or exceed the maximum return  candy   extra_candies    max_candies for candy in candies  , title:  C   , language:  cpp , code:  include  include using namespace std; vector kidsWithCandies vector  candies, int extraCandies     Find the maximum candies any kid currently has int maxCandies   max_element candies.begin  , candies.end   ; vector result; for  int candy : candies  result.push_back candy   extraCandies    maxCandies ; return result; , title:  Java , language:  java , code: import java.util.; public class KidsWithCandies public static List kidsWithCandies int   candies, int extraCandies     Find the maximum candies any kid currently has int maxCandies   Arrays.stream candies .max  .getAsInt  ; List result   new ArrayList    ; for  int candy : candies  result.add candy   extraCandies    maxCandies ; return result; ,      --- Step-by-Step Walkthrough Let s trace through candies    2,3,5,1,3 , extraCandies   3:    Step 1: Find maximum candies max 2,3,5,1,3    5 Step 2: Check each kid Kid 0: 2   3   5    5?   true Kid 1: 3   3   6    5?   true Kid 2: 5   3   8    5?   true Kid 3: 1   3   4    5?   false Kid 4: 3   3   6    5?   true Result:  true, true, true, false, true    --- Alternative Solution  Manual Loop    maxCandies ; return result; , title:  Python , language:  python , code: def kids_with_candies candies, extra_candies :   Find maximum manually max_candies   0 for candy in candies: max_candies   max max_candies, candy    Build result array result      for candy in candies: result.append candy   extra_candies    max_candies  return result , title:  C   , language:  cpp , code:  include using namespace std; vector kidsWithCandies vector  candies, int extraCandies     Find maximum manually int maxCandies   0; for  int candy : candies  maxCandies   max maxCandies, candy ;    Build result array vector result; for  int candy : candies  result.push_back candy   extraCandies    maxCandies ; return result; ,      --- Complexity Analysis Time Complexity: O n  - Finding maximum: O n  - Building result array: O n  - Total: O n  where n   number of kids Space Complexity: O 1  - Only using constant extra space - Output array doesn t count toward space complexity --- Key Insights Single pass optimization - Find max and build result in one go if needed Comparison logic - Use    instead of    ties are allowed  Array transformation - Map transform pattern is perfect here Edge cases - All kids equal, single kid, zero extra candies --- This problem introduces array transformation patterns and comparative logic - essential skills for many algorithm problems!",
    "excerpt": "Kids With the Greatest Number of Candies Difficulty: Easy LeetCode: 1431. Kids With the Greatest Number of Candies --- Problem There are n kids with candies.",
    "url": "/docs/leetcode75/arrays-strings/kids-with-greatest-candies",
    "canonicalUrl": "https://crackmode.vercel.app/docs/leetcode75/arrays-strings/kids-with-greatest-candies",
    "section": "LeetCode 75",
    "tags": [
      "easy",
      "array",
      "arrays",
      "string",
      "strings",
      "leetcode"
    ],
    "headings": [
      {
        "level": 1,
        "text": "Kids With the Greatest Number of Candies",
        "id": "kids-with-the-greatest-number-of-candies"
      },
      {
        "level": 2,
        "text": "Problem",
        "id": "problem"
      },
      {
        "level": 2,
        "text": "Simple Explanation",
        "id": "simple-explanation"
      },
      {
        "level": 2,
        "text": "Solution",
        "id": "solution"
      },
      {
        "level": 2,
        "text": "Step-by-Step Walkthrough",
        "id": "step-by-step-walkthrough"
      },
      {
        "level": 2,
        "text": "Alternative Solution (Manual Loop)",
        "id": "alternative-solution-manual-loop"
      },
      {
        "level": 2,
        "text": "Complexity Analysis",
        "id": "complexity-analysis"
      },
      {
        "level": 2,
        "text": "Key Insights",
        "id": "key-insights"
      }
    ],
    "publishedAt": "2026-01-04T04:18:51.305Z",
    "updatedAt": "2026-01-04T04:18:51.305Z",
    "author": "Morgan Ngetich",
    "readingTime": 4,
    "seo": {
      "title": "Kids With Greatest Candies | Crackmode Documentation",
      "description": "Kids With the Greatest Number of Candies Difficulty: Easy LeetCode: 1431. Kids With the Greatest Number of Candies --- Problem There are n kids with candies.",
      "keywords": "kids, with, greatest, candies, easy, array, arrays, string, strings, leetcode, candy, extracandies, result, crackmode, algorithm",
      "robots": "index,follow",
      "jsonLd": "{\"@context\":\"https://schema.org\",\"@type\":\"Article\",\"headline\":\"Kids With Greatest Candies\",\"description\":\"Kids With the Greatest Number of Candies Difficulty: Easy LeetCode: 1431. Kids With the Greatest Number of Candies --- Problem There are n kids with candies.\",\"url\":\"https://crackmode.vercel.app/docs/leetcode75/arrays-strings/kids-with-greatest-candies\",\"datePublished\":\"2026-01-04T04:18:51.305Z\",\"dateModified\":\"2026-01-04T04:18:51.305Z\",\"author\":{\"@type\":\"Person\",\"name\":\"Morgan Ngetich\"},\"publisher\":{\"@type\":\"Organization\",\"name\":\"CrackMode\",\"logo\":{\"@type\":\"ImageObject\",\"url\":\"https://crackmode.vercel.app/group.png\"}},\"mainEntityOfPage\":{\"@type\":\"WebPage\",\"@id\":\"https://crackmode.vercel.app/docs/leetcode75/arrays-strings/kids-with-greatest-candies\"},\"wordCount\":182,\"timeRequired\":\"PT4M\",\"inLanguage\":\"en-US\",\"isAccessibleForFree\":true}"
    },
    "socialMedia": {
      "ogTitle": "Kids With Greatest Candies | Crackmode Documentation",
      "ogDescription": "There are n kids with candies.",
      "ogImage": "https://crackmode.vercel.app/api/v1/og?title=Kids+With+Greatest+Candies&description=There+are+n+kids+with+candies.&section=Documentation&theme=crackmode",
      "twitterTitle": "Kids With Greatest Candies | Crackmode Documentation",
      "twitterDescription": "There are n kids with candies.",
      "twitterImage": "https://crackmode.vercel.app/api/v1/og?title=Kids+With+Greatest+Candies&description=There+are+n+kids+with+candies.&section=Documentation&theme=crackmode"
    }
  },
  {
    "id": "leetcode75/leetcode75",
    "title": "Leetcode75",
    "content": "LeetCode 75: Your Fast-Track Coding Interview Guide LeetCode 75 is a curated list of 75 problems designed to help you master core coding patterns and ace tech interviews   without grinding 1,000  problems. Why LeetCode 75? Covers 90  of common interview questions Builds knowledge step-by-step Focuses on repeatable patterns Efficient and structured for fast learning The 5-Phase Learning Plan Phase 1: Foundations  1 25  Arrays, Strings, Two Pointers Master the basics Build core logic and efficiency Learn problem patterns that appear in most interviews What you gain: Confidence with fundamentals. Phase 2: Core Techniques  26 45  Sliding Window, Prefix Sum, Hash Maps Spot optimization patterns Learn how to reduce time complexity Solve tricky substring array problems What you gain: Pattern recognition and smarter solutions. Phase 3: Data Structures  46 60  Stacks, Linked Lists, Trees  DFS  Build comfort with recursive logic and pointers Learn stack-based problem solving What you gain: Strong grasp of classic structures. Phase 4: Traversals   Graphs  61 70  BFS, DFS, Graphs, BSTs Tackle tree   graph problems Learn to navigate complex structures What you gain: Confidence with trees and graph traversal. Phase 5: Master Level  71 75  Dynamic Programming, Intervals, Graphs  BFS  Solve the toughest problems Learn to break problems into subproblems Handle advanced scheduling   optimization What you gain: Interview-ready skills for any challenge. Skills You ll Build Technical Algorithm design   efficiency Pattern spotting Clean, optimized code Interview Skills Clear communication Edge case handling Real-time problem-solving Professional Growth Problem-solving mindset Confidence under pressure Debugging   optimization 10-Week Success Timeline 10-Week Success Timeline Week Focus 1 2 Arrays, Strings, Two Pointers 3 4 Sliding Window, Hash Maps, Stack 5 6 Linked Lists, Trees 7 8 BSTs, Graphs 9 10 DP, Intervals, BFS Why It Works All patterns, no fluff Structured progression Used by thousands to land jobs at FAANG   startups Teaches you how to think, not just code How to Get Started 1. Be consistent   daily practice beats cramming 2. Learn patterns, not just solutions 3. Write notes   build your own cheat sheet 4. Mock interviews   practice explaining out loud Final Thought LeetCode 75   your fast lane to interview success. Start solving. Build confidence. Land the job.",
    "excerpt": "LeetCode 75: Your Fast-Track Coding Interview Guide LeetCode 75 is a curated list of 75 problems designed to help you master core coding patterns and ace tech...",
    "url": "/docs/leetcode75/leetcode75",
    "canonicalUrl": "https://crackmode.vercel.app/docs/leetcode75/leetcode75",
    "section": "LeetCode 75",
    "tags": [
      "advanced",
      "array",
      "arrays",
      "string",
      "strings",
      "tree"
    ],
    "headings": [
      {
        "level": 1,
        "text": "LeetCode 75: Your Fast-Track Coding Interview Guide",
        "id": "leetcode-75-your-fast-track-coding-interview-guide"
      },
      {
        "level": 2,
        "text": "Why LeetCode 75?",
        "id": "why-leetcode-75"
      },
      {
        "level": 2,
        "text": "The 5-Phase Learning Plan",
        "id": "the-5-phase-learning-plan"
      },
      {
        "level": 3,
        "text": "Phase 1: Foundations (1â€“25)",
        "id": "phase-1-foundations-125"
      },
      {
        "level": 3,
        "text": "Phase 2: Core Techniques (26â€“45)",
        "id": "phase-2-core-techniques-2645"
      },
      {
        "level": 3,
        "text": "Phase 3: Data Structures (46â€“60)",
        "id": "phase-3-data-structures-4660"
      },
      {
        "level": 3,
        "text": "Phase 4: Traversals & Graphs (61â€“70)",
        "id": "phase-4-traversals-graphs-6170"
      },
      {
        "level": 3,
        "text": "Phase 5: Master Level (71â€“75)",
        "id": "phase-5-master-level-7175"
      },
      {
        "level": 2,
        "text": "Skills You'll Build",
        "id": "skills-youll-build"
      },
      {
        "level": 3,
        "text": "Technical",
        "id": "technical"
      },
      {
        "level": 3,
        "text": "Interview Skills",
        "id": "interview-skills"
      },
      {
        "level": 3,
        "text": "Professional Growth",
        "id": "professional-growth"
      },
      {
        "level": 2,
        "text": "10-Week Success Timeline",
        "id": "10-week-success-timeline"
      },
      {
        "level": 2,
        "text": "Why It Works",
        "id": "why-it-works"
      },
      {
        "level": 2,
        "text": "How to Get Started",
        "id": "how-to-get-started"
      },
      {
        "level": 2,
        "text": "Final Thought",
        "id": "final-thought"
      }
    ],
    "publishedAt": "2026-01-04T04:18:51.309Z",
    "updatedAt": "2026-01-04T04:18:51.309Z",
    "author": "Morgan Ngetich",
    "readingTime": 2,
    "seo": {
      "title": "Leetcode75 | Crackmode Documentation",
      "description": "LeetCode 75: Your Fast-Track Coding Interview Guide LeetCode 75 is a curated list of 75 problems designed to help you master core coding patterns and ace tech...",
      "keywords": "leetcode75, advanced, array, arrays, string, strings, tree, learn, problems, phase, build, leetcode, crackmode, algorithm",
      "robots": "index,follow",
      "jsonLd": "{\"@context\":\"https://schema.org\",\"@type\":\"Article\",\"headline\":\"Leetcode75\",\"description\":\"LeetCode 75: Your Fast-Track Coding Interview Guide LeetCode 75 is a curated list of 75 problems designed to help you master core coding patterns and ace tech...\",\"url\":\"https://crackmode.vercel.app/docs/leetcode75/leetcode75\",\"datePublished\":\"2026-01-04T04:18:51.309Z\",\"dateModified\":\"2026-01-04T04:18:51.309Z\",\"author\":{\"@type\":\"Person\",\"name\":\"Morgan Ngetich\"},\"publisher\":{\"@type\":\"Organization\",\"name\":\"CrackMode\",\"logo\":{\"@type\":\"ImageObject\",\"url\":\"https://crackmode.vercel.app/group.png\"}},\"mainEntityOfPage\":{\"@type\":\"WebPage\",\"@id\":\"https://crackmode.vercel.app/docs/leetcode75/leetcode75\"},\"wordCount\":189,\"timeRequired\":\"PT2M\",\"inLanguage\":\"en-US\",\"isAccessibleForFree\":true}"
    },
    "socialMedia": {
      "ogTitle": "Leetcode75 | Crackmode Documentation",
      "ogDescription": "LeetCode 75: Your Fast-Track Coding Interview Guide LeetCode 75 is a curated list of 75 problems designed to help you master core coding patterns and ace tech...",
      "ogImage": "https://crackmode.vercel.app/api/v1/og?title=Leetcode75&description=LeetCode+75%3A+Your+Fast-Track+Coding+Interview+Guide+LeetCode+75+is+a+curated+list+of+75+problems+designed+to+help+you+ma...&section=Documentation&theme=crackmode",
      "twitterTitle": "Leetcode75 | Crackmode Documentation",
      "twitterDescription": "LeetCode 75: Your Fast-Track Coding Interview Guide LeetCode 75 is a curated list of 75 problems designed to help you master core coding patterns and ace tech...",
      "twitterImage": "https://crackmode.vercel.app/api/v1/og?title=Leetcode75&description=LeetCode+75%3A+Your+Fast-Track+Coding+Interview+Guide+LeetCode+75+is+a+curated+list+of+75+problems+designed+to+help+you+ma...&section=Documentation&theme=crackmode"
    }
  },
  {
    "id": "leetcode75/arrays-strings/merge-strings-alternately",
    "title": "Merge Strings Alternately",
    "content": "Merge Strings Alternately Difficulty: Easy LeetCode: 1768. Merge Strings Alternately --- Problem You are given two strings   word and word2. Merge the strings by adding letters in alternating order, starting with word1. If a string is longer than the other, append the additional letters onto the end of the merged string. Example 1:   Input: word1    abc , word2    pqr  Output:  apbqcr  Explanation: The merged string will be merged as so: word1: a b c word2: p q r merged: a p b q c r   Example 2:   Input: word1    ab , word2    pqrs  Output:  apbqrs  Explanation: Notice that as word2 is longer,  rs  is appended to the end. word1: a b word2: p q r s merged: a p b q r s   --- Simple Explanation Think of this like taking turns: 1. Take a letter from word1 2. Take a letter from word2 3. Repeat until one string runs out 4. Add any remaining letters from the longer string It s like merging two lines of people, alternating between each line! --- Solution using namespace std; string mergeAlternately string word1, string word2  string result; int i   0, j   0; while  i --- Step-by-Step Walkthrough Let s trace through word1    abc , word2    pqr :   Step 1: result     , i   0, j   0 Add word1 0     a    result    a  Add word2 0     p    result    ap  Step 2: result    ap , i   1, j   1 Add word1 1     b    result    apb  Add word2 1     q    result    apbq  Step 3: result    apbq , i   2, j   2 Add word1 2     c    result    apbqc  Add word2 2     r    result    apbqcr  Final: Both strings exhausted   return  apbqcr    --- Alternative Solution  Cleaner  using namespace std; string mergeAlternately string word1, string word2  string result; int maxLength   max word1.size  , word2.size   ; for  int i   0; i --- Complexity Analysis Time Complexity: O m   n  We visit each character in both strings exactly once m   length of word1, n   length of word2 Space Complexity: O m   n  We build a new string containing all characters --- Key Insights Two pointers pattern - track position in each string independently Handle unequal lengths - don t forget the remaining characters String building - concatenate characters one by one Index bounds - always check i --- This is a great warm-up problem that introduces the two-pointers technique in its simplest form!",
    "excerpt": "Merge Strings Alternately Difficulty: Easy LeetCode: 1768. Merge Strings Alternately --- Problem You are given two strings word and word2.",
    "url": "/docs/leetcode75/arrays-strings/merge-strings-alternately",
    "canonicalUrl": "https://crackmode.vercel.app/docs/leetcode75/arrays-strings/merge-strings-alternately",
    "section": "LeetCode 75",
    "tags": [
      "easy",
      "array",
      "arrays",
      "string",
      "strings",
      "two-pointers"
    ],
    "headings": [
      {
        "level": 1,
        "text": "Merge Strings Alternately",
        "id": "merge-strings-alternately"
      },
      {
        "level": 2,
        "text": "Problem",
        "id": "problem"
      },
      {
        "level": 2,
        "text": "Simple Explanation",
        "id": "simple-explanation"
      },
      {
        "level": 2,
        "text": "Solution",
        "id": "solution"
      },
      {
        "level": 2,
        "text": "Step-by-Step Walkthrough",
        "id": "step-by-step-walkthrough"
      },
      {
        "level": 2,
        "text": "Alternative Solution (Cleaner)",
        "id": "alternative-solution-cleaner"
      },
      {
        "level": 2,
        "text": "Complexity Analysis",
        "id": "complexity-analysis"
      },
      {
        "level": 2,
        "text": "Key Insights",
        "id": "key-insights"
      }
    ],
    "publishedAt": "2026-01-04T04:18:51.305Z",
    "updatedAt": "2026-01-04T04:18:51.305Z",
    "author": "Morgan Ngetich",
    "readingTime": 2,
    "seo": {
      "title": "Merge Strings Alternately | Crackmode Documentation",
      "description": "Merge Strings Alternately Difficulty: Easy LeetCode: 1768. Merge Strings Alternately --- Problem You are given two strings word and word2.",
      "keywords": "merge, strings, alternately, easy, array, arrays, string, two-pointers, result, letters, crackmode, leetcode, algorithm",
      "robots": "index,follow",
      "jsonLd": "{\"@context\":\"https://schema.org\",\"@type\":\"Article\",\"headline\":\"Merge Strings Alternately\",\"description\":\"Merge Strings Alternately Difficulty: Easy LeetCode: 1768. Merge Strings Alternately --- Problem You are given two strings word and word2.\",\"url\":\"https://crackmode.vercel.app/docs/leetcode75/arrays-strings/merge-strings-alternately\",\"datePublished\":\"2026-01-04T04:18:51.305Z\",\"dateModified\":\"2026-01-04T04:18:51.305Z\",\"author\":{\"@type\":\"Person\",\"name\":\"Morgan Ngetich\"},\"publisher\":{\"@type\":\"Organization\",\"name\":\"CrackMode\",\"logo\":{\"@type\":\"ImageObject\",\"url\":\"https://crackmode.vercel.app/group.png\"}},\"mainEntityOfPage\":{\"@type\":\"WebPage\",\"@id\":\"https://crackmode.vercel.app/docs/leetcode75/arrays-strings/merge-strings-alternately\"},\"wordCount\":140,\"timeRequired\":\"PT2M\",\"inLanguage\":\"en-US\",\"isAccessibleForFree\":true}"
    },
    "socialMedia": {
      "ogTitle": "Merge Strings Alternately | Crackmode Documentation",
      "ogDescription": "You are given two strings ` word and word2. Merge the strings by adding letters in alternating order, starting with word1`. If a string is longer than the other, append the additional letters onto the end of the merged string.",
      "ogImage": "https://crackmode.vercel.app/api/v1/og?title=Merge+Strings+Alternately&description=You+are+given+two+strings+%60+word+and+word2.+Merge+the+strings+by+adding+letters+in+alternating+order%2C+starting+with+word...&section=Documentation&theme=crackmode",
      "twitterTitle": "Merge Strings Alternately | Crackmode Documentation",
      "twitterDescription": "You are given two strings ` word and word2. Merge the strings by adding letters in alternating order, starting with word1`. If a string is longer than the other, append the additional letters onto the end of the merged string.",
      "twitterImage": "https://crackmode.vercel.app/api/v1/og?title=Merge+Strings+Alternately&description=You+are+given+two+strings+%60+word+and+word2.+Merge+the+strings+by+adding+letters+in+alternating+order%2C+starting+with+word...&section=Documentation&theme=crackmode"
    }
  },
  {
    "id": "leetcode75/arrays-strings/product-of-array-except-self",
    "title": "Product Of Array Except Self",
    "content": "Product of Array Except Self Difficulty: Medium LeetCode: 238. Product of Array Except Self --- Problem Given an integer array nums, return an array answer such that answer i  is equal to the product of all the elements of nums except nums i . The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer. You must write an algorithm that runs in O n  time and without using the division operator. Example 1:    Input: nums    1,2,3,4  Output:  24,12,8,6  Explanation: - answer 0    234   24 - answer 1    134   12 - answer 2    124   8 - answer 3    123   6   Example 2:   Input: nums    -1,1,0,-3,3  Output:  0,0,9,0,0  Explanation: - answer 0    10 -3 3   0 - answer 1     -1 0 -3 3   0 - answer 2     -1 1 -3 3   9 - answer 3     -1 103   0 - answer 4     -1 10 -3    0   --- Simple Explanation Think of this as  what s the product if I remove this element?  Key insight: For each position, we need: - Left side product   Right side product   Array:  1, 2, 3, 4  Index: 0 1 2 3 For index 1  value 2 : - Left product: 1  just 1  - Right product: 34   12 - Result: 1 12   12   We can do this in two passes: left-to-right, then right-to-left! --- Solution   0; i--  result i    rightProduct; rightProduct   nums i ; return result; , title:  Python , language:  python , code: def product_except_self nums : n   len nums  result    0  n   First pass: calculate left products result 0    1 for i in range 1, n : result i    result i - 1  nums i - 1    Second pass: multiply by right products right_product   1 for i in range n - 1, -1, -1 : result i    right_product right_product   nums i  return result , title:  C   , language:  cpp , code:  include using namespace std; vector productExceptSelf vector  nums  int n   nums.size  ; vector result n ;    First pass: calculate left products result 0    1; for  int i   1; i   0; i--  result i    rightProduct; rightProduct   nums i ; return result; , title:  Java , language:  java , code: public class ProductExceptSelf public static int   productExceptSelf int   nums  int n   nums.length; int   result   new int n ;    First pass: calculate left products result 0    1; for  int i   1; i   0; i--  result i    rightProduct; rightProduct   nums i ; return result; ,      --- Step-by-Step Walkthrough Let s trace through nums    1,2,3,4 :    Initial: nums    1, 2, 3, 4  result    _, _, _, _  PASS 1 - Left products: result 0    1    1, _, _, _  result 1    result 0  nums 0    1 1   1    1, 1, _, _  result 2    result 1  nums 1    1 2   2    1, 1, 2, _  result 3    result 2  nums 2    2 3   6    1, 1, 2, 6  PASS 2 - Multiply by right products: rightProduct   1 i 3: result 3    rightProduct   6 1   6    1, 1, 2, 6  rightProduct   nums 3    1 4   4 i 2: result 2    rightProduct   2 4   8    1, 1, 8, 6  rightProduct   nums 2    4 3   12 i 1: result 1    rightProduct   1 12   12    1, 12, 8, 6  rightProduct   nums 1    12 2   24 i 0: result 0    rightProduct   1 24   24    24, 12, 8, 6  rightProduct   nums 0    24 1   24 Final result:  24, 12, 8, 6    --- Visual Understanding For nums    1, 2, 3, 4 :   Index: 0 1 2 3 Values:  1   2   3   4  Left products  what s to the left : result 0    1  nothing to left  result 1    1  1  result 2    12   2  1,2  result 3    123   6  1,2,3  Right products  what s to the right : result 3    1  nothing to right  result 2    4   24   8  4  result 1    34   112   12  3,4  result 0    234   124   24  2,3,4     --- Alternative Solution  With Extra Arrays    0; i--  rightProducts i    rightProducts i   1    nums i   1 ;    Multiply left and right products for  let i   0; i --- Complexity Analysis Time Complexity: O n  - First pass through array: O n  - Second pass through array: O n  - Total: O n  Space Complexity: O 1  - Only using the output array and a single variable - Output array doesn t count toward space complexity --- Key Insights Two-pass technique - Left products, then right products Space optimization - Use output array to store intermediate results No division needed - Handles zeros naturally without special cases Prefix suffix pattern - Common technique for  except self  problems --- This problem demonstrates the powerful prefix suffix sum pattern that appears in many array problems!",
    "excerpt": "Product of Array Except Self Difficulty: Medium LeetCode: 238. Product of Array Except Self --- Problem Given an integer array nums, return an array answer...",
    "url": "/docs/leetcode75/arrays-strings/product-of-array-except-self",
    "canonicalUrl": "https://crackmode.vercel.app/docs/leetcode75/arrays-strings/product-of-array-except-self",
    "section": "LeetCode 75",
    "tags": [
      "medium",
      "intermediate",
      "array",
      "arrays",
      "string",
      "strings"
    ],
    "headings": [
      {
        "level": 1,
        "text": "Product of Array Except Self",
        "id": "product-of-array-except-self"
      },
      {
        "level": 2,
        "text": "Problem",
        "id": "problem"
      },
      {
        "level": 2,
        "text": "Simple Explanation",
        "id": "simple-explanation"
      },
      {
        "level": 2,
        "text": "Solution",
        "id": "solution"
      },
      {
        "level": 2,
        "text": "Step-by-Step Walkthrough",
        "id": "step-by-step-walkthrough"
      },
      {
        "level": 2,
        "text": "Visual Understanding",
        "id": "visual-understanding"
      },
      {
        "level": 2,
        "text": "Alternative Solution (With Extra Arrays)",
        "id": "alternative-solution-with-extra-arrays"
      },
      {
        "level": 2,
        "text": "Complexity Analysis",
        "id": "complexity-analysis"
      },
      {
        "level": 2,
        "text": "Key Insights",
        "id": "key-insights"
      }
    ],
    "publishedAt": "2026-01-04T04:18:51.305Z",
    "updatedAt": "2026-01-04T04:18:51.305Z",
    "author": "Morgan Ngetich",
    "readingTime": 4,
    "seo": {
      "title": "Product Of Array Except Self | Crackmode Documentation",
      "description": "Product of Array Except Self Difficulty: Medium LeetCode: 238. Product of Array Except Self --- Problem Given an integer array nums, return an array answer...",
      "keywords": "product, array, except, self, medium, intermediate, arrays, string, strings, result, rightproduct, answer, right, crackmode, leetcode, algorithm",
      "robots": "index,follow",
      "jsonLd": "{\"@context\":\"https://schema.org\",\"@type\":\"Article\",\"headline\":\"Product Of Array Except Self\",\"description\":\"Product of Array Except Self Difficulty: Medium LeetCode: 238. Product of Array Except Self --- Problem Given an integer array nums, return an array answer...\",\"url\":\"https://crackmode.vercel.app/docs/leetcode75/arrays-strings/product-of-array-except-self\",\"datePublished\":\"2026-01-04T04:18:51.305Z\",\"dateModified\":\"2026-01-04T04:18:51.305Z\",\"author\":{\"@type\":\"Person\",\"name\":\"Morgan Ngetich\"},\"publisher\":{\"@type\":\"Organization\",\"name\":\"CrackMode\",\"logo\":{\"@type\":\"ImageObject\",\"url\":\"https://crackmode.vercel.app/group.png\"}},\"mainEntityOfPage\":{\"@type\":\"WebPage\",\"@id\":\"https://crackmode.vercel.app/docs/leetcode75/arrays-strings/product-of-array-except-self\"},\"wordCount\":175,\"timeRequired\":\"PT4M\",\"inLanguage\":\"en-US\",\"isAccessibleForFree\":true}"
    },
    "socialMedia": {
      "ogTitle": "Product Of Array Except Self | Crackmode Documentation",
      "ogDescription": "Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i].",
      "ogImage": "https://crackmode.vercel.app/api/v1/og?title=Product+Of+Array+Except+Self&description=Given+an+integer+array+nums%2C+return+an+array+answer+such+that+answer%5Bi%5D+is+equal+to+the+product+of+all+the+elements+of+n...&section=Documentation&theme=crackmode",
      "twitterTitle": "Product Of Array Except Self | Crackmode Documentation",
      "twitterDescription": "Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i].",
      "twitterImage": "https://crackmode.vercel.app/api/v1/og?title=Product+Of+Array+Except+Self&description=Given+an+integer+array+nums%2C+return+an+array+answer+such+that+answer%5Bi%5D+is+equal+to+the+product+of+all+the+elements+of+n...&section=Documentation&theme=crackmode"
    }
  },
  {
    "id": "leetcode75/arrays-strings/string-compression",
    "title": "String Compression",
    "content": "String Compression Difficulty: Medium LeetCode: 443. String Compression --- Problem Given an array of characters chars, compress it using the following algorithm: Begin with an empty string s. For each group of consecutive repeating characters in chars: - If the group s length is 1, append the character to s. - Otherwise, append the character followed by the group s length. After you finish the algorithm above, return the new length of the string. You must write an algorithm that uses only constant extra space. Example 1:    Input: chars     a , a , b , b , c , c , c   Output: Return 6, and the first 6 characters of the input array should be:   a , 2 , b , 2 , c , 3   Explanation: The groups are  aa ,  bb , and  ccc . This compresses to  a2b2c3 .   Example 2:   Input: chars     a   Output: Return 1, and the first character of the input array should be:   a   Explanation: The only group is  a , which remains uncompressed since it s a single character.   Example 3:   Input: chars     a , b , b , b , b , b , b , b , b , b , b , b , b   Output: Return 4, and the first 4 characters of the input array should be:   a , b , 1 , 2   Explanation: The groups are  a  and  bbbbbbbbbbbb . This compresses to  ab12 .   --- Simple Explanation Think of this as  counting consecutive characters : 1. Group consecutive characters:  aaa    character  a , count 3 2. Write compressed form:  a     3  if count   1, just  a  if count   1 3. Do this in-place: overwrite the original array to save space It s like shorthand notation: instead of writing  aaabbb , write  a3b3 ! --- Solution 1 if  count   1  const countStr   count.toString  ; for  let digit of countStr  chars write      digit; return write; , title:  Python , language:  python , code: def compress chars : write   0   Where to write the compressed result read   0   Where to read the current group while read 1 if count   1: count_str   str count  for digit in count_str: chars write    digit write    1 return write , title:  C   , language:  cpp , code:  include  include using namespace std; int compress vector  chars  int write   0;    Where to write the compressed result int read   0;    Where to read the current group while  read 1 if  count   1  string countStr   to_string count ; for  char digit : countStr  chars write      digit; return write; , title:  Java , language:  java , code: public class StringCompression public static int compress char   chars  int write   0;    Where to write the compressed result int read   0;    Where to read the current group while  read 1 if  count   1  String countStr   Integer.toString count ; for  char digit : countStr.toCharArray    chars write      digit; return write; ,      --- Step-by-Step Walkthrough Let s trace through chars     a , a , b , b , c , c , c  :    Initial: chars     a , a , b , b , c , c , c   write   0, read   0 ITERATION 1 - Process  a  group: read 0: chars 0   a , currentChar  a  Count consecutive  a s: read 0 1 2  stopped at  b  , count 2 Write  a  at position 0: chars     a , a , b , b , c , c , c   write   1 Count   1, so write  2 : chars     a , 2 , b , b , c , c , c   write   2 ITERATION 2 - Process  b  group: read 2: chars 2   b , currentChar  b  Count consecutive  b s: read 2 3 4  stopped at  c  , count 2 Write  b  at position 2: chars     a , 2 , b , b , c , c , c   write   3 Count   1, so write  2 : chars     a , 2 , b , 2 , c , c , c   write   4 ITERATION 3 - Process  c  group: read 4: chars 4   c , currentChar  c  Count consecutive  c s: read 4 5 6 7  end , count 3 Write  c  at position 4: chars     a , 2 , b , 2 , c , c , c   write   5 Count   1, so write  3 : chars     a , 2 , b , 2 , c , 3 , c   write   6 Final: Return write   6 First 6 characters:   a , 2 , b , 2 , c , 3     --- Handling Large Counts For counts   10, we need multiple digits:  javascript    Example:  aaaaaaaaaaaa   12 a s     a12  chars     a , a , a , a , a , a , a , a , a , a , a , a   After compression: chars 0     a  chars 1     1     First digit of 12 chars 2     2     Second digit of 12 Result length: 3   --- Alternative Solution  More Explicit  1  let countDigits   count.toString  .split    ; for  let digit of countDigits  chars writeIndex    digit; writeIndex  ;    Move to next group i    count; return writeIndex; ,      --- Edge Cases   javascript    Single character compress   a       Return 1:   a      No compression needed compress   a , b , c       Return 3:   a , b , c      All same characters compress   a , a , a , a       Return 2:   a , 4      Large count compress   a  .repeat 100      Return 4:   a , 1 , 0 , 0      Mixed groups compress   a , a , a , b , b , a , a       Return 6:   a , 3 , b , 2 , a , 2      --- Complexity Analysis Time Complexity: O n  - Single pass through the array - Each character is read and written at most once Space Complexity: O 1  - Only using a constant amount of extra space - Modifying the input array in-place --- Key Insights Two pointers technique - Read pointer and write pointer move independently In-place modification - Overwrite original array to save space Count to string conversion - Handle multi-digit counts properly Group processing - Process one group of consecutive characters at a time --- This problem combines two pointers, string manipulation, and in-place algorithms - essential skills for many coding challenges!",
    "excerpt": "String Compression Difficulty: Medium LeetCode: 443. String Compression --- Problem Given an array of characters chars, compress it using the following...",
    "url": "/docs/leetcode75/arrays-strings/string-compression",
    "canonicalUrl": "https://crackmode.vercel.app/docs/leetcode75/arrays-strings/string-compression",
    "section": "LeetCode 75",
    "tags": [
      "medium",
      "array",
      "arrays",
      "string",
      "strings",
      "leetcode"
    ],
    "headings": [
      {
        "level": 1,
        "text": "String Compression",
        "id": "string-compression"
      },
      {
        "level": 2,
        "text": "Problem",
        "id": "problem"
      },
      {
        "level": 2,
        "text": "Simple Explanation",
        "id": "simple-explanation"
      },
      {
        "level": 2,
        "text": "Solution",
        "id": "solution"
      },
      {
        "level": 2,
        "text": "Step-by-Step Walkthrough",
        "id": "step-by-step-walkthrough"
      },
      {
        "level": 2,
        "text": "Handling Large Counts",
        "id": "handling-large-counts"
      },
      {
        "level": 2,
        "text": "Alternative Solution (More Explicit)",
        "id": "alternative-solution-more-explicit"
      },
      {
        "level": 2,
        "text": "Edge Cases",
        "id": "edge-cases"
      },
      {
        "level": 2,
        "text": "Complexity Analysis",
        "id": "complexity-analysis"
      },
      {
        "level": 2,
        "text": "Key Insights",
        "id": "key-insights"
      }
    ],
    "publishedAt": "2026-01-04T04:18:51.309Z",
    "updatedAt": "2026-01-04T04:18:51.309Z",
    "author": "Morgan Ngetich",
    "readingTime": 6,
    "seo": {
      "title": "String Compression | Crackmode Documentation",
      "description": "String Compression Difficulty: Medium LeetCode: 443. String Compression --- Problem Given an array of characters chars, compress it using the following...",
      "keywords": "string, compression, medium, array, arrays, strings, leetcode, write, chars, count, return, group, crackmode, algorithm",
      "robots": "index,follow",
      "jsonLd": "{\"@context\":\"https://schema.org\",\"@type\":\"Article\",\"headline\":\"String Compression\",\"description\":\"String Compression Difficulty: Medium LeetCode: 443. String Compression --- Problem Given an array of characters chars, compress it using the following...\",\"url\":\"https://crackmode.vercel.app/docs/leetcode75/arrays-strings/string-compression\",\"datePublished\":\"2026-01-04T04:18:51.309Z\",\"dateModified\":\"2026-01-04T04:18:51.309Z\",\"author\":{\"@type\":\"Person\",\"name\":\"Morgan Ngetich\"},\"publisher\":{\"@type\":\"Organization\",\"name\":\"CrackMode\",\"logo\":{\"@type\":\"ImageObject\",\"url\":\"https://crackmode.vercel.app/group.png\"}},\"mainEntityOfPage\":{\"@type\":\"WebPage\",\"@id\":\"https://crackmode.vercel.app/docs/leetcode75/arrays-strings/string-compression\"},\"wordCount\":147,\"timeRequired\":\"PT6M\",\"inLanguage\":\"en-US\",\"isAccessibleForFree\":true}"
    },
    "socialMedia": {
      "ogTitle": "String Compression | Crackmode Documentation",
      "ogDescription": "Given an array of characters chars, compress it using the following algorithm: Begin with an empty string s.",
      "ogImage": "https://crackmode.vercel.app/api/v1/og?title=String+Compression&description=Given+an+array+of+characters+chars%2C+compress+it+using+the+following+algorithm%3A+Begin+with+an+empty+string+s.&section=Documentation&theme=crackmode",
      "twitterTitle": "String Compression | Crackmode Documentation",
      "twitterDescription": "Given an array of characters chars, compress it using the following algorithm: Begin with an empty string s.",
      "twitterImage": "https://crackmode.vercel.app/api/v1/og?title=String+Compression&description=Given+an+array+of+characters+chars%2C+compress+it+using+the+following+algorithm%3A+Begin+with+an+empty+string+s.&section=Documentation&theme=crackmode"
    }
  },
  {
    "id": "problems/asteroid-collision",
    "title": "Asteroid Collision",
    "content": "Asteroid Collision Difficulty: Medium LeetCode: 735. Asteroid Collision --- Problem We are given an array asteroids of integers representing asteroids in a row. The indices of the asteroid in the array represent their relative position in space. For each asteroid, the absolute value represents its size, and the sign represents its direction  positive meaning right, negative meaning left . Each asteroid moves at the same speed. Find out the state of the asteroids after all collisions. If two asteroids meet, the smaller one will explode. If both are the same size, both will explode. Two asteroids moving in the same direction will never meet. Example 1:    Input: asteroids    5,10,-5  Output:  5,10  Explanation: The 10 and -5 collide resulting in 10. The 5 and 10 never collide.   Example 2:   Input: asteroids    8,-8  Output:    Explanation: The 8 and -8 collide exploding each other.   Example 3:   Input: asteroids    10,2,-5  Output:  10  Explanation: The 2 and -5 collide resulting in -5. The 10 and -5 collide resulting in 10.   Constraints: - 2 0 and stack -1  0    stack stack.length - 1    0    stack stack.length - 1  0    stack stack.length - 1      Math.abs asteroid   stack.pop  ;    Both explode    Add left-moving asteroid if no collision or it survives else if  stack.length     0    stack stack.length - 1  stack   new Stack    ; for  int asteroid : asteroids  if  asteroid 0    stack.peek     0; i--  result i    stack.pop  ; return result; , title:  C   , language:  cpp , code:  include  include  include class Solution public: std::vector asteroidCollision std::vector  asteroids  std::stack stack; for  int asteroid : asteroids  if  asteroid 0    stack.top   result stack.size   ; for  int i   result.size   - 1; i    0; i--  result i    stack.top  ; stack.pop  ; return result; ;      --- Step-by-Step Walkthrough Example 1: asteroids    5, 10, -5    asteroid   5: Right-moving   stack    5  asteroid   10: Right-moving   stack    5, 10  asteroid   -5: Left-moving, size 5 - Top of stack is 10  right-moving, size 10  - 10   5, so -5 explodes - stack remains  5, 10  Final result:  5, 10    Example 2: asteroids    8, -8    asteroid   8: Right-moving   stack    8  asteroid   -8: Left-moving, size 8 - Top of stack is 8  right-moving, size 8  - 8    8, so both explode - stack becomes    Final result:      Example 3: asteroids    10, 2, -5    asteroid   10: Right-moving   stack    10  asteroid   2: Right-moving   stack    10, 2  asteroid   -5: Left-moving, size 5 - Top is 2  right-moving, size 2  - 2 5, so -5 explodes - stack remains  10  Final result:  10    Example 4: asteroids    -2, -1, 1, 2    asteroid   -2: Left-moving   stack    -2  asteroid   -1: Left-moving   stack    -2, -1  asteroid   1: Right-moving   stack    -2, -1, 1  asteroid   2: Right-moving   stack    -2, -1, 1, 2  Final result:  -2, -1, 1, 2   no collisions    --- Edge Cases  python Test cases: print asteroidCollision  5, 10, -5       5, 10  print asteroidCollision  8, -8         print asteroidCollision  10, 2, -5       10  print asteroidCollision  -2, -1, 1, 2       -2, -1, 1, 2  print asteroidCollision  1, -1, -2, -2       -2, -2  print asteroidCollision  2, 1, -1, -2         print asteroidCollision  1, 2, 3, -3       1, 2  print asteroidCollision  -1, -2, 3, 4       -1, -2, 3, 4     --- Complexity Analysis Time Complexity: O n  - Each asteroid is pushed and popped at most once Even with the while loop, total operations are linear Space Complexity: O n  - Stack can hold up to n asteroids in worst case Example: All asteroids moving right:  1, 2, 3, 4, 5  --- Key Insights When do collisions occur? - Only when right-moving asteroid  positive  meets left-moving asteroid  negative  - Asteroids moving in same direction never collide - Left-moving asteroids can only collide with right-moving ones Stack behavior: - Right-moving asteroids: Always added to stack - Left-moving asteroids: May cause chain of explosions with right-moving asteroids in stack Collision outcomes: 1. Left-moving wins: Right-moving asteroid s  explode 2. Right-moving wins: Left-moving asteroid explodes 3. Tie: Both asteroids explode 4. No collision: Different directions or separated --- Pattern Recognition This problem demonstrates key patterns: - Stack for Simulation: Using LIFO structure to track state changes - Collision Detection: Identifying when interactions occur - Chain Reactions: One event triggering multiple subsequent events - State Management: Tracking and updating system state over time You ll see similar patterns in: - Game physics simulations - Event processing systems - Undo Redo operations with cascading effects - Compiler parsing with precedence rules - Traffic flow simulations ---",
    "excerpt": "Asteroid Collision Difficulty: Medium LeetCode: 735. Asteroid Collision --- Problem We are given an array asteroids of integers representing asteroids in a...",
    "url": "/docs/problems/asteroid-collision",
    "canonicalUrl": "https://crackmode.vercel.app/docs/problems/asteroid-collision",
    "section": "Problems",
    "tags": [
      "medium",
      "array",
      "leetcode",
      "complexity",
      "pattern",
      "python"
    ],
    "headings": [
      {
        "level": 1,
        "text": "Asteroid Collision",
        "id": "asteroid-collision"
      },
      {
        "level": 2,
        "text": "Problem",
        "id": "problem"
      },
      {
        "level": 2,
        "text": "Simple Explanation",
        "id": "simple-explanation"
      },
      {
        "level": 2,
        "text": "Solution",
        "id": "solution"
      },
      {
        "level": 2,
        "text": "Step-by-Step Walkthrough",
        "id": "step-by-step-walkthrough"
      },
      {
        "level": 3,
        "text": "Example 1: asteroids = [5, 10, -5]",
        "id": "example-1-asteroids-5-10-5"
      },
      {
        "level": 3,
        "text": "Example 2: asteroids = [8, -8]",
        "id": "example-2-asteroids-8-8"
      },
      {
        "level": 3,
        "text": "Example 3: asteroids = [10, 2, -5]",
        "id": "example-3-asteroids-10-2-5"
      },
      {
        "level": 3,
        "text": "Example 4: asteroids = [-2, -1, 1, 2]",
        "id": "example-4-asteroids-2-1-1-2"
      },
      {
        "level": 2,
        "text": "Edge Cases",
        "id": "edge-cases"
      },
      {
        "level": 1,
        "text": "Test cases:",
        "id": "test-cases"
      },
      {
        "level": 2,
        "text": "Complexity Analysis",
        "id": "complexity-analysis"
      },
      {
        "level": 2,
        "text": "Key Insights",
        "id": "key-insights"
      },
      {
        "level": 2,
        "text": "Pattern Recognition",
        "id": "pattern-recognition"
      }
    ],
    "publishedAt": "2026-01-04T04:18:51.309Z",
    "updatedAt": "2026-01-04T04:18:51.309Z",
    "author": "Morgan Ngetich",
    "readingTime": 4,
    "seo": {
      "title": "Asteroid Collision | Crackmode Documentation",
      "description": "Asteroid Collision Difficulty: Medium LeetCode: 735. Asteroid Collision --- Problem We are given an array asteroids of integers representing asteroids in a...",
      "keywords": "asteroid, collision, medium, array, leetcode, complexity, pattern, python, stack, asteroids, asteroidcollision, print, crackmode, algorithm",
      "robots": "index,follow",
      "jsonLd": "{\"@context\":\"https://schema.org\",\"@type\":\"Article\",\"headline\":\"Asteroid Collision\",\"description\":\"Asteroid Collision Difficulty: Medium LeetCode: 735. Asteroid Collision --- Problem We are given an array asteroids of integers representing asteroids in a...\",\"url\":\"https://crackmode.vercel.app/docs/problems/asteroid-collision\",\"datePublished\":\"2026-01-04T04:18:51.309Z\",\"dateModified\":\"2026-01-04T04:18:51.309Z\",\"author\":{\"@type\":\"Person\",\"name\":\"Morgan Ngetich\"},\"publisher\":{\"@type\":\"Organization\",\"name\":\"CrackMode\",\"logo\":{\"@type\":\"ImageObject\",\"url\":\"https://crackmode.vercel.app/group.png\"}},\"mainEntityOfPage\":{\"@type\":\"WebPage\",\"@id\":\"https://crackmode.vercel.app/docs/problems/asteroid-collision\"},\"wordCount\":154,\"timeRequired\":\"PT4M\",\"inLanguage\":\"en-US\",\"isAccessibleForFree\":true}"
    },
    "socialMedia": {
      "ogTitle": "Asteroid Collision | Crackmode Documentation",
      "ogDescription": "We are given an array asteroids of integers representing asteroids in a row. The indices of the asteroid in the array represent their relative position in space.",
      "ogImage": "https://crackmode.vercel.app/api/v1/og?title=Asteroid+Collision&description=We+are+given+an+array+asteroids+of+integers+representing+asteroids+in+a+row.+The+indices+of+the+asteroid+in+the+array+re...&section=Documentation&theme=crackmode",
      "twitterTitle": "Asteroid Collision | Crackmode Documentation",
      "twitterDescription": "We are given an array asteroids of integers representing asteroids in a row. The indices of the asteroid in the array represent their relative position in space.",
      "twitterImage": "https://crackmode.vercel.app/api/v1/og?title=Asteroid+Collision&description=We+are+given+an+array+asteroids+of+integers+representing+asteroids+in+a+row.+The+indices+of+the+asteroid+in+the+array+re...&section=Documentation&theme=crackmode"
    }
  },
  {
    "id": "problems/best-time-to-buy-and-sell-stock",
    "title": "Best Time To Buy And Sell Stock",
    "content": "Best Time to Buy and Sell Stock Difficulty: Easy LeetCode: 121. Best Time to Buy and Sell Stock --- Problem You are given an array prices where prices i  is the price of a given stock on the ith day. You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock. Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0. Example 1:    Input: prices    7,1,5,3,6,4  Output: 5 Explanation: Buy on day 2  price   1  and sell on day 5  price   6 , profit   6-1   5. Note that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.   Example 2:   Input: prices    7,6,4,3,1  Output: 0 Explanation: In this case, no transactions are done and the max profit   0.   Constraints: - 1  include using namespace std; int maxProfit vector  prices  if  prices.size   --- Step-by-Step Walkthrough Let s trace through prices    7,1,5,3,6,4 :    Day 0: price   7 min_price   7, max_profit   0 Day 1: price   1 current_profit   1 - 7   -6  can t have negative profit  max_profit   max 0, -6    0 min_price   min 7, 1    1 Day 2: price   5 current_profit   5 - 1   4 max_profit   max 0, 4    4 min_price   min 1, 5    1 Day 3: price   3 current_profit   3 - 1   2 max_profit   max 4, 2    4 min_price   min 1, 3    1 Day 4: price   6 current_profit   6 - 1   5 max_profit   max 4, 5    5   min_price   min 1, 6    1 Day 5: price   4 current_profit   4 - 1   3 max_profit   max 5, 3    5 min_price   min 1, 4    1 Final Result: max_profit   5   --- Why This Approach Works Single pass - Only need to go through the array once Greedy strategy - Always keep track of the lowest price seen so far Forward-looking - For each price, calculate best profit if selling today Optimal substructure - Maximum profit at day i depends on minimum price before day i --- Visual Example For prices    7,1,5,3,6,4 :   Price Chart: 7    6     5       4     3     2   1     0  ________________ 0 1 2 3 4 5 Days     Actual prices     Optimal buy sell points Buy at day 1  price   1  Sell at day 4  price   6  Profit   6 - 1   5   --- Common Mistakes to Avoid 1. Allowing negative profits: Always ensure profit   0 2. Selling before buying: Make sure you track minimum price before current day 3. Using nested loops: The O n   solution will time out on large inputs 4. Not handling edge cases: Empty arrays, single elements, decreasing prices 5. Forgetting to update min_price: Always update minimum price after calculating profit --- Complexity Analysis Time Complexity: O n  Single pass through the prices array Constant time operations for each element Space Complexity: O 1  Only using two variables: min_price and max_profit No additional data structures needed --- Pattern Recognition This problem demonstrates key patterns: - Greedy Algorithm: Make locally optimal choice  track minimum price  - Single Pass Optimization: Transform O n   brute force to O n  - Running Maximum Minimum: Keep track of best values seen so far - Profit Maximization: Core concept in many financial algorithms You ll see similar patterns in: - Maximum subarray sum  Kadane s algorithm  - Best time to buy sell stock with multiple transactions - Trapping rainwater - Finding maximum difference in array --- Follow-up Variations 1. Multiple Transactions Allowed  LeetCode 122   python def maxProfit_multiple_transactions prices : profit   0 for i in range 1, len prices  :   Buy yesterday, sell today if profitable profit    max 0, prices i  - prices i-1   return profit   2. At Most K Transactions  LeetCode 188   python def maxProfit_k_transactions k, prices : if k    len prices     2:   If k is large enough, it s same as unlimited transactions return maxProfit_multiple_transactions prices    Use DP with states:  transaction  holding_stock  buy    -prices 0    k   1  sell    0   k   1  for price in prices 1: : for j in range k, 0, -1 : sell j    max sell j , buy j    price  buy j    max buy j , sell j-1  - price  return sell k     ---",
    "excerpt": "Best Time to Buy and Sell Stock Difficulty: Easy LeetCode: 121. Best Time to Buy and Sell Stock --- Problem You are given an array prices where prices i is the...",
    "url": "/docs/problems/best-time-to-buy-and-sell-stock",
    "canonicalUrl": "https://crackmode.vercel.app/docs/problems/best-time-to-buy-and-sell-stock",
    "section": "Problems",
    "tags": [
      "easy",
      "array",
      "arrays",
      "greedy",
      "leetcode",
      "algorithm"
    ],
    "headings": [
      {
        "level": 1,
        "text": "Best Time to Buy and Sell Stock",
        "id": "best-time-to-buy-and-sell-stock"
      },
      {
        "level": 2,
        "text": "Problem",
        "id": "problem"
      },
      {
        "level": 2,
        "text": "Simple Explanation",
        "id": "simple-explanation"
      },
      {
        "level": 2,
        "text": "Optimal Solution",
        "id": "optimal-solution"
      },
      {
        "level": 2,
        "text": "Step-by-Step Walkthrough",
        "id": "step-by-step-walkthrough"
      },
      {
        "level": 2,
        "text": "Why This Approach Works",
        "id": "why-this-approach-works"
      },
      {
        "level": 2,
        "text": "Visual Example",
        "id": "visual-example"
      },
      {
        "level": 2,
        "text": "Common Mistakes to Avoid",
        "id": "common-mistakes-to-avoid"
      },
      {
        "level": 2,
        "text": "Complexity Analysis",
        "id": "complexity-analysis"
      },
      {
        "level": 2,
        "text": "Pattern Recognition",
        "id": "pattern-recognition"
      },
      {
        "level": 2,
        "text": "Follow-up Variations",
        "id": "follow-up-variations"
      },
      {
        "level": 3,
        "text": "1. Multiple Transactions Allowed (LeetCode 122)",
        "id": "1-multiple-transactions-allowed-leetcode-122"
      },
      {
        "level": 3,
        "text": "2. At Most K Transactions (LeetCode 188)",
        "id": "2-at-most-k-transactions-leetcode-188"
      }
    ],
    "publishedAt": "2026-01-04T04:18:51.309Z",
    "updatedAt": "2026-01-04T04:18:51.309Z",
    "author": "Morgan Ngetich",
    "readingTime": 4,
    "seo": {
      "title": "Best Time To Buy And Sell Stock | Crackmode Documentation",
      "description": "Best Time to Buy and Sell Stock Difficulty: Easy LeetCode: 121. Best Time to Buy and Sell Stock --- Problem You are given an array prices where prices i is the...",
      "keywords": "best, time, sell, stock, easy, array, arrays, greedy, leetcode, algorithm, price, prices, profit, single, crackmode",
      "robots": "index,follow",
      "jsonLd": "{\"@context\":\"https://schema.org\",\"@type\":\"Article\",\"headline\":\"Best Time To Buy And Sell Stock\",\"description\":\"Best Time to Buy and Sell Stock Difficulty: Easy LeetCode: 121. Best Time to Buy and Sell Stock --- Problem You are given an array prices where prices i is the...\",\"url\":\"https://crackmode.vercel.app/docs/problems/best-time-to-buy-and-sell-stock\",\"datePublished\":\"2026-01-04T04:18:51.309Z\",\"dateModified\":\"2026-01-04T04:18:51.309Z\",\"author\":{\"@type\":\"Person\",\"name\":\"Morgan Ngetich\"},\"publisher\":{\"@type\":\"Organization\",\"name\":\"CrackMode\",\"logo\":{\"@type\":\"ImageObject\",\"url\":\"https://crackmode.vercel.app/group.png\"}},\"mainEntityOfPage\":{\"@type\":\"WebPage\",\"@id\":\"https://crackmode.vercel.app/docs/problems/best-time-to-buy-and-sell-stock\"},\"wordCount\":217,\"timeRequired\":\"PT4M\",\"inLanguage\":\"en-US\",\"isAccessibleForFree\":true}"
    },
    "socialMedia": {
      "ogTitle": "Best Time To Buy And Sell Stock | Crackmode Documentation",
      "ogDescription": "You are given an array prices where prices[i] is the price of a given stock on the ith day.",
      "ogImage": "https://crackmode.vercel.app/api/v1/og?title=Best+Time+To+Buy+And+Sell+Stock&description=You+are+given+an+array+prices+where+prices%5Bi%5D+is+the+price+of+a+given+stock+on+the+ith+day.&section=Documentation&theme=crackmode",
      "twitterTitle": "Best Time To Buy And Sell Stock | Crackmode Documentation",
      "twitterDescription": "You are given an array prices where prices[i] is the price of a given stock on the ith day.",
      "twitterImage": "https://crackmode.vercel.app/api/v1/og?title=Best+Time+To+Buy+And+Sell+Stock&description=You+are+given+an+array+prices+where+prices%5Bi%5D+is+the+price+of+a+given+stock+on+the+ith+day.&section=Documentation&theme=crackmode"
    }
  },
  {
    "id": "problems/check-if-number-has-equal-digit-count-and-digit-value",
    "title": "Check If Number Has Equal Digit Count And Digit Value",
    "content": "Check if Number Has Equal Digit Count and Digit Value Difficulty: Easy LeetCode: 2283. Check if Number Has Equal Digit Count and Digit Value --- Problem You are given a 0-indexed string num of length n consisting of digits. Return true if for every index i in the range 0 bool: for i in range len num  : counter   0 for j in range len num  : if i    int num j  : counter    1 if counter !  int num i  : return False return True   Approach 2: Frequency Array def digitCountOptimized self, num: str  -  bool: count    0    10   Count frequency of each digit for char in num: count int char      1   Check if each position s requirement is met for i in range len num  : if count i  !  int num i  : return False return True   Approach 3: Using Counter from collections def digitCountCounter self, num: str  -  bool: from collections import Counter count   Counter num  for i in range len num  : digit_count   count.get str i , 0  if digit_count !  int num i  : return False return True , title:  C   , language:  cpp , code:  include  include using namespace std; class Solution public:    Approach 1: Brute Force bool digitCount string num  int n   num.length  ; for  int i   0; i count 10, 0 ;    Count frequency of each digit for  char c : num  count c -  0    ;    Check if each position s requirement is met for  int i   0; i --- Step-by-Step Walkthrough Let s trace through Example 1 with num    1210  using different approaches: Brute Force Approach:   Index 0: Count digit 0 in  1210    appears 1 time, num 0     1    Index 1: Count digit 1 in  1210    appears 2 times, num 1     2    Index 2: Count digit 2 in  1210    appears 1 time, num 2     1    Index 3: Count digit 3 in  1210    appears 0 times, num 3     0    All conditions satisfied   Return true   Frequency Array Approach:   Step 1: Count frequencies count 0    1  digit  0  appears once  count 1    2  digit  1  appears twice  count 2    1  digit  2  appears once  count 3    0  digit  3  never appears  Step 2: Verify conditions i 0: count 0  1, num 0   1    1  1   i 1: count 1  2, num 1   2    2  2   i 2: count 2  1, num 2   1    1  1   i 3: count 3  0, num 3   0    0  0   All conditions satisfied   Return true   Let s trace through Example 2 with num    030 :   Index 0: Count digit 0 in  030    appears 2 times, num 0     0    2 0   Return false immediately   --- Algorithm Intuition The problem is asking us to verify a self-describing property:    At position i, the digit tells us how many times digit i should appear in the entire string  This creates a constraint system where: - Position 0 contains the count of digit 0 - Position 1 contains the count of digit 1 - And so on... The constraint 1 Self-reference - each position describes the count of its own index Constraint bounds - length   10 makes frequency array practical Early termination - return false as soon as any condition fails Trade-offs - O n   simplicity vs O n  efficiency --- Edge Cases to Consider 1. Single digit:  1    digit 0 should appear 1 time, but it appears 0 times   false 2. All zeros:  00    both positions expect 0 occurrences of digits 0 and 1, but digit 0 appears twice   false 3. Valid single:  10    digit 0 appears 1 time    , digit 1 appears 0 times       true --- Follow-up Questions 1. What if the string could be longer than 10? - We d need to handle digits   9, possibly using a hash map instead of array 2. What if we wanted to find all valid self-describing numbers of length n? - This becomes a constraint satisfaction problem with backtracking 3. Is there a mathematical pattern for valid numbers? - Yes! Valid numbers have specific structural properties based on their length --- This problem beautifully demonstrates how constraint verification and frequency counting work together in a self-referential system!",
    "excerpt": "Check if Number Has Equal Digit Count and Digit Value Difficulty: Easy LeetCode: 2283. Check if Number Has Equal Digit Count and Digit Value --- Problem You...",
    "url": "/docs/problems/check-if-number-has-equal-digit-count-and-digit-value",
    "canonicalUrl": "https://crackmode.vercel.app/docs/problems/check-if-number-has-equal-digit-count-and-digit-value",
    "section": "Problems",
    "tags": [
      "easy",
      "array",
      "string",
      "backtracking",
      "leetcode",
      "algorithm"
    ],
    "headings": [
      {
        "level": 1,
        "text": "Check if Number Has Equal Digit Count and Digit Value",
        "id": "check-if-number-has-equal-digit-count-and-digit-value"
      },
      {
        "level": 2,
        "text": "Problem",
        "id": "problem"
      },
      {
        "level": 2,
        "text": "Simple Explanation",
        "id": "simple-explanation"
      },
      {
        "level": 2,
        "text": "Solution Approaches",
        "id": "solution-approaches"
      },
      {
        "level": 3,
        "text": "Approach 1: Brute Force (Most Straightforward)",
        "id": "approach-1-brute-force-most-straightforward"
      },
      {
        "level": 3,
        "text": "Approach 2: Frequency Array (Most Efficient)",
        "id": "approach-2-frequency-array-most-efficient"
      },
      {
        "level": 2,
        "text": "Solution",
        "id": "solution"
      },
      {
        "level": 2,
        "text": "Step-by-Step Walkthrough",
        "id": "step-by-step-walkthrough"
      },
      {
        "level": 3,
        "text": "Brute Force Approach:",
        "id": "brute-force-approach"
      },
      {
        "level": 3,
        "text": "Frequency Array Approach:",
        "id": "frequency-array-approach"
      },
      {
        "level": 2,
        "text": "Algorithm Intuition",
        "id": "algorithm-intuition"
      },
      {
        "level": 2,
        "text": "Complexity Analysis",
        "id": "complexity-analysis"
      },
      {
        "level": 3,
        "text": "Brute Force:",
        "id": "brute-force"
      },
      {
        "level": 3,
        "text": "Frequency Array:",
        "id": "frequency-array"
      },
      {
        "level": 2,
        "text": "Key Insights",
        "id": "key-insights"
      },
      {
        "level": 2,
        "text": "Edge Cases to Consider",
        "id": "edge-cases-to-consider"
      },
      {
        "level": 2,
        "text": "Follow-up Questions",
        "id": "follow-up-questions"
      }
    ],
    "publishedAt": "2026-01-04T04:18:51.313Z",
    "updatedAt": "2026-01-04T04:18:51.313Z",
    "author": "Morgan Ngetich",
    "readingTime": 4,
    "seo": {
      "title": "Check If Number Has Equal Digit Count And Digit Value | Crackmode Documentation",
      "description": "Check if Number Has Equal Digit Count and Digit Value Difficulty: Easy LeetCode: 2283. Check if Number Has Equal Digit Count and Digit Value --- Problem You...",
      "keywords": "check, number, equal, digit, count, value, easy, array, string, backtracking, leetcode, algorithm, appears, return, index, crackmode",
      "robots": "index,follow",
      "jsonLd": "{\"@context\":\"https://schema.org\",\"@type\":\"Article\",\"headline\":\"Check If Number Has Equal Digit Count And Digit Value\",\"description\":\"Check if Number Has Equal Digit Count and Digit Value Difficulty: Easy LeetCode: 2283. Check if Number Has Equal Digit Count and Digit Value --- Problem You...\",\"url\":\"https://crackmode.vercel.app/docs/problems/check-if-number-has-equal-digit-count-and-digit-value\",\"datePublished\":\"2026-01-04T04:18:51.313Z\",\"dateModified\":\"2026-01-04T04:18:51.313Z\",\"author\":{\"@type\":\"Person\",\"name\":\"Morgan Ngetich\"},\"publisher\":{\"@type\":\"Organization\",\"name\":\"CrackMode\",\"logo\":{\"@type\":\"ImageObject\",\"url\":\"https://crackmode.vercel.app/group.png\"}},\"mainEntityOfPage\":{\"@type\":\"WebPage\",\"@id\":\"https://crackmode.vercel.app/docs/problems/check-if-number-has-equal-digit-count-and-digit-value\"},\"wordCount\":189,\"timeRequired\":\"PT4M\",\"inLanguage\":\"en-US\",\"isAccessibleForFree\":true}"
    },
    "socialMedia": {
      "ogTitle": "Check If Number Has Equal Digit Count And Digit Value | Crackmode Documentation",
      "ogDescription": "You are given a 0-indexed string num of length n consisting of digits. Return true if for every index i in the range 0 <= i < n, the digit i occurs num[i] times in num, otherwise return false.",
      "ogImage": "https://crackmode.vercel.app/api/v1/og?title=Check+If+Number+Has+Equal+Digit+Count+And+Digit+Value&description=You+are+given+a+0-indexed+string+num+of+length+n+consisting+of+digits.+Return+true+if+for+every+index+i+in+the+range+0+%3C...&section=Documentation&theme=crackmode",
      "twitterTitle": "Check If Number Has Equal Digit Count And Digit Value | Crackmode Documentation",
      "twitterDescription": "You are given a 0-indexed string num of length n consisting of digits. Return true if for every index i in the range 0 <= i < n, the digit i occurs num[i] times in num, otherwise return false.",
      "twitterImage": "https://crackmode.vercel.app/api/v1/og?title=Check+If+Number+Has+Equal+Digit+Count+And+Digit+Value&description=You+are+given+a+0-indexed+string+num+of+length+n+consisting+of+digits.+Return+true+if+for+every+index+i+in+the+range+0+%3C...&section=Documentation&theme=crackmode"
    }
  },
  {
    "id": "problems/contains-duplicate",
    "title": "Contains Duplicate",
    "content": "Contains Duplicate Difficulty: Easy LeetCode: 217. Contains Duplicate --- Problem Given an integer array nums, return true if any value appears at least twice in the array, and return false if every element is distinct. Example 1:    Input: nums    1,2,3,1  Output: true Explanation: The element 1 occurs at the indices 0 and 3.   Example 2:   Input: nums    1,2,3,4  Output: false Explanation: All elements are distinct.   Example 3:   Input: nums    1,1,1,3,3,4,3,2,4,2  Output: true   Constraints: - 1 a - b ; for  let i   1; i seen   new HashSet    ; for  int num : nums  if  seen.contains num   return true; seen.add num ; return false; public boolean containsDuplicate_optimized int   nums     Optimized Set approach Set seen   new HashSet    ; for  int num : nums  if  !seen.add num      add   returns false if element already exists return true; return false; public boolean containsDuplicate_sorting int   nums     Sorting Approach Arrays.sort nums ; for  int i   1; i  include  include class Solution public: bool containsDuplicate std::vector  nums     Hash Set Approach std::unordered_set seen; for  int num : nums  if  seen.find num  !  seen.end    return true; seen.insert num ; return false; bool containsDuplicate_optimized std::vector  nums     Optimized Set approach std::unordered_set seen; for  int num : nums  if  seen.insert num .second    false     insert returns pair return true; return false; bool containsDuplicate_sorting std::vector  nums     Sorting Approach std::sort nums.begin  , nums.end   ; for  int i   1; i   nums     Brute Force Approach for  int i   0; i --- Step-by-Step Walkthrough Hash Set Approach for nums    1,2,3,1     Step 1: num   1 1 not in seen seen   1 Step 2: num   2 2 not in seen seen   1, 2 Step 3: num   3 3 not in seen seen   1, 2, 3 Step 4: num   1 1 found in seen   Return true  duplicate found!    Sorting Approach for nums    1,1,1,3,3,4,3,2,4,2    Step 1: Sort array Original:  1,1,1,3,3,4,3,2,4,2  Sorted:  1,1,1,2,2,3,3,3,4,4  Step 2: Compare adjacent elements Compare nums 0  and nums 1 : 1    1   Return true  duplicate found!    --- Why Hash Set Works Best Constant lookup - Hash set provides O 1  average time for contains add operations Early termination - Returns immediately upon finding first duplicate Single pass - Only needs to iterate through array once Memory efficient - In worst case  no duplicates , stores each element once --- Algorithm Comparison Performance Analysis:   Hash Set Approach:   Time: O n  - single pass   Space: O n  - set storage   Early termination possible Best for: Most cases, optimal time complexity Sorting Approach:    Time: O n log n  - sorting dominates   Space: O 1  - if in-place sort   Early termination possible Best for: Memory-constrained environments One-liner Set Size:    Time: O n  - but always processes entire array    Space: O n  - creates complete set   No early termination Best for: Code golf, when you need the set anyway Brute Force:   Time: O n   - nested loops   Space: O 1  - no extra storage   Early termination possible Best for: Tiny arrays only   --- Edge Cases  python Test cases: print containsDuplicate  1, 2, 3, 1      True - basic duplicate print containsDuplicate  1, 2, 3, 4      False - all unique print containsDuplicate  1, 1, 1, 3, 3, 4      True - multiple duplicates print containsDuplicate  1      False - single element print containsDuplicate  0, 0      True - duplicate zeros print containsDuplicate  -1, -1      True - negative duplicates print containsDuplicate  1000000000, 1000000000      True - large numbers print containsDuplicate  2147483647, -2147483648      False - boundary values   --- Common Mistakes to Avoid 1. Modifying input array: Be careful with sorting approach if you need to preserve original array 2. Hash collision assumptions: Modern hash sets handle collisions well, don t over-optimize 3. Integer overflow: With constraints up to 10 9, standard int types are sufficient 4. Early vs complete processing: Choose hash set for early termination, size comparison for other use cases 5. Memory considerations: For very large arrays, consider sorting approach to save space --- Complexity Analysis Hash Set Approach  Optimal : Time: O n  - Single pass through array, O 1  set operations Space: O n  - Worst case stores all n elements in set Sorting Approach: Time: O n log n  - Sorting dominates, O n  for comparison Space: O 1  - If using in-place sort like heapsort Brute Force Approach: Time: O n   - Nested loops check all pairs Space: O 1  - No extra space used Set Size Comparison: Time: O n  - Creates set from entire array Space: O n  - Set stores all unique elements --- Pattern Recognition This problem demonstrates key patterns: - Hash Set for Uniqueness: Using set data structure to track seen elements - Early Termination Optimization: Returning as soon as duplicate is found - Space-Time Tradeoffs: Hash set vs sorting vs brute force approaches - Duplicate Detection: Core pattern used in many algorithms You ll see similar patterns in: - Finding missing numbers in arrays - Intersection of two arrays - Remove duplicates from arrays - Checking for anagrams - Cycle detection in linked lists  Floyd s algorithm  - Finding unique elements --- Real-World Applications - Data Validation: Ensuring unique IDs, usernames, or email addresses - Database Systems: Checking constraint violations before insertion - File Processing: Detecting duplicate files or records - User Input: Validating unique selections in forms - Security: Detecting replay attacks or duplicate tokens - Analytics: Finding unique visitors, events, or transactions --- Visual Representation   Array:  1, 2, 3, 1  Hash Set Approach Visualization:                             1   2   3   1                                     Add Add Add Found!         Set: 1   1,2   1,2,3   Duplicate! Timeline: Step 1: seen , num 1   seen 1 Step 2: seen 1, num 2   seen 1,2 Step 3: seen 1,2, num 3   seen 1,2,3 Step 4: seen 1,2,3, num 1   DUPLICATE FOUND! Result: Return true after checking 4 4 elements    --- Follow-up Questions Q: What if the array is sorted? A: You can solve in O n  time, O 1  space by just checking adjacent elements. Q: What if you need to find the duplicate element, not just detect it? A: Modify hash set approach to return the element instead of True. Q: What if you need to count all duplicates? A: Use a frequency map  HashMap  instead of a set. Q: Can you solve it without extra space? A: Yes, with sorting approach O n log n  time, or O n   brute force. Q: What about floating point numbers? A: Same approaches work, but be careful with floating point precision issues.",
    "excerpt": "Contains Duplicate Difficulty: Easy LeetCode: 217. Contains Duplicate --- Problem Given an integer array nums, return true if any value appears at least twice...",
    "url": "/docs/problems/contains-duplicate",
    "canonicalUrl": "https://crackmode.vercel.app/docs/problems/contains-duplicate",
    "section": "Problems",
    "tags": [
      "easy",
      "array",
      "arrays",
      "sorting",
      "leetcode",
      "algorithm"
    ],
    "headings": [
      {
        "level": 1,
        "text": "Contains Duplicate",
        "id": "contains-duplicate"
      },
      {
        "level": 2,
        "text": "Problem",
        "id": "problem"
      },
      {
        "level": 2,
        "text": "Simple Explanation",
        "id": "simple-explanation"
      },
      {
        "level": 2,
        "text": "Optimal Solutions",
        "id": "optimal-solutions"
      },
      {
        "level": 2,
        "text": "Step-by-Step Walkthrough",
        "id": "step-by-step-walkthrough"
      },
      {
        "level": 3,
        "text": "Hash Set Approach for nums = [1,2,3,1]",
        "id": "hash-set-approach-for-nums-1231"
      },
      {
        "level": 3,
        "text": "Sorting Approach for nums = [1,1,1,3,3,4,3,2,4,2]",
        "id": "sorting-approach-for-nums-1113343242"
      },
      {
        "level": 2,
        "text": "Why Hash Set Works Best",
        "id": "why-hash-set-works-best"
      },
      {
        "level": 2,
        "text": "Algorithm Comparison",
        "id": "algorithm-comparison"
      },
      {
        "level": 3,
        "text": "Performance Analysis:",
        "id": "performance-analysis"
      },
      {
        "level": 2,
        "text": "Edge Cases",
        "id": "edge-cases"
      },
      {
        "level": 1,
        "text": "Test cases:",
        "id": "test-cases"
      },
      {
        "level": 2,
        "text": "Common Mistakes to Avoid",
        "id": "common-mistakes-to-avoid"
      },
      {
        "level": 2,
        "text": "Complexity Analysis",
        "id": "complexity-analysis"
      },
      {
        "level": 2,
        "text": "Pattern Recognition",
        "id": "pattern-recognition"
      },
      {
        "level": 2,
        "text": "Real-World Applications",
        "id": "real-world-applications"
      },
      {
        "level": 2,
        "text": "Visual Representation",
        "id": "visual-representation"
      },
      {
        "level": 2,
        "text": "Follow-up Questions",
        "id": "follow-up-questions"
      }
    ],
    "publishedAt": "2026-01-04T04:18:51.313Z",
    "updatedAt": "2026-01-04T04:18:51.313Z",
    "author": "Morgan Ngetich",
    "readingTime": 6,
    "seo": {
      "title": "Contains Duplicate | Crackmode Documentation",
      "description": "Contains Duplicate Difficulty: Easy LeetCode: 217. Contains Duplicate --- Problem Given an integer array nums, return true if any value appears at least twice...",
      "keywords": "contains, duplicate, easy, array, arrays, sorting, leetcode, algorithm, return, approach, containsduplicate, crackmode",
      "robots": "index,follow",
      "jsonLd": "{\"@context\":\"https://schema.org\",\"@type\":\"Article\",\"headline\":\"Contains Duplicate\",\"description\":\"Contains Duplicate Difficulty: Easy LeetCode: 217. Contains Duplicate --- Problem Given an integer array nums, return true if any value appears at least twice...\",\"url\":\"https://crackmode.vercel.app/docs/problems/contains-duplicate\",\"datePublished\":\"2026-01-04T04:18:51.313Z\",\"dateModified\":\"2026-01-04T04:18:51.313Z\",\"author\":{\"@type\":\"Person\",\"name\":\"Morgan Ngetich\"},\"publisher\":{\"@type\":\"Organization\",\"name\":\"CrackMode\",\"logo\":{\"@type\":\"ImageObject\",\"url\":\"https://crackmode.vercel.app/group.png\"}},\"mainEntityOfPage\":{\"@type\":\"WebPage\",\"@id\":\"https://crackmode.vercel.app/docs/problems/contains-duplicate\"},\"wordCount\":168,\"timeRequired\":\"PT6M\",\"inLanguage\":\"en-US\",\"isAccessibleForFree\":true}"
    },
    "socialMedia": {
      "ogTitle": "Contains Duplicate | Crackmode Documentation",
      "ogDescription": "Given an integer array nums, return true if any value appears at least twice in the array, and return false if every element is distinct.",
      "ogImage": "https://crackmode.vercel.app/api/v1/og?title=Contains+Duplicate&description=Given+an+integer+array+nums%2C+return+true+if+any+value+appears+at+least+twice+in+the+array%2C+and+return+false+if+every+ele...&section=Documentation&theme=crackmode",
      "twitterTitle": "Contains Duplicate | Crackmode Documentation",
      "twitterDescription": "Given an integer array nums, return true if any value appears at least twice in the array, and return false if every element is distinct.",
      "twitterImage": "https://crackmode.vercel.app/api/v1/og?title=Contains+Duplicate&description=Given+an+integer+array+nums%2C+return+true+if+any+value+appears+at+least+twice+in+the+array%2C+and+return+false+if+every+ele...&section=Documentation&theme=crackmode"
    }
  },
  {
    "id": "problems/determine-if-two-strings-are-close",
    "title": "Determine If Two Strings Are Close",
    "content": "Determine if Two Strings Are Close Difficulty: Medium LeetCode: 1657. Determine if Two Strings Are Close --- Problem Two strings are considered close if you can attain one from the other using the following operations: 1. Operation 1: Swap any two existing characters. - For example, abcde -  aecdb 2. Operation 2: Transform every occurrence of one existing character into another existing character, and do the same with the other character. - For example, aacabb -  bbcbaa  all a s turn into b s, and all b s turn into a s  You can use the operations on either string as many times as necessary. Given two strings, word1 and word2, return true if word1 and word2 are close, and false otherwise. Example 1:    Input: word1    abc , word2    bca  Output: true Explanation: You can attain word2 from word1 in 2 operations. Apply Operation 1:  abc  -   acb  Apply Operation 1:  acb  -   bca    Example 2:   Input: word1    a , word2    aa  Output: false Explanation: It is impossible to attain word2 from word1, or vice versa, in any number of operations.   Example 3:   Input: word1    cabbba , word2    abbccc  Output: true Explanation: You can attain word2 from word1 in 3 operations. Apply Operation 1:  cabbba  -   caabbb  Apply Operation 2:  caabbb  -   baaccc  Apply Operation 2:  baaccc  -   abbccc    --- Simple Explanation Think of this like rearranging and swapping character frequencies! Two strings are  close  if: 1. They have the same set of unique characters 2. The frequency counts can be rearranged to match The Key Insight: - Operation 1  swap  means order doesn t matter - Operation 2  transform  means we can swap frequency counts between characters So we need to check: - Same character sets: a,b,c vs a,b,c   - Same frequency patterns:  1,2,3  vs  2,1,3    --- Optimal Solutions a - b ; const values2   Array.from count2.values   .sort  a, b     a - b ; return JSON.stringify values1      JSON.stringify values2 ; , title:  Java , language:  java , code: import java.util. ; public class Solution public boolean closeStrings String word1, String word2     Quick length check if  word1.length   !  word2.length    return false;    Count frequencies Map freq1   new HashMap    ; Map freq2   new HashMap    ; for  char c : word1.toCharArray    freq1.put c, freq1.getOrDefault c, 0    1 ; for  char c : word2.toCharArray    freq2.put c, freq2.getOrDefault c, 0    1 ;    Check same character sets if  !freq1.keySet  .equals freq2.keySet     return false;    Check same frequency patterns List values1   new ArrayList   freq1.values   ; List values2   new ArrayList   freq2.values   ; Collections.sort values1 ; Collections.sort values2 ; return values1.equals values2 ; , title:  C   , language:  cpp , code:  include  include  include  include class Solution public: bool closeStrings std::string word1, std::string word2     Quick length check if  word1.length   !  word2.length    return false;    Count frequencies std::unordered_map freq1, freq2; for  char c : word1  freq1 c   ; for  char c : word2  freq2 c   ;    Check same character sets if  freq1.size   !  freq2.size    return false; for  auto  p : freq1  if  freq2.find p.first     freq2.end    return false;    Check same frequency patterns std::vector values1, values2; for  auto  p : freq1  values1.push_back p.second ; for  auto  p : freq2  values2.push_back p.second ; std::sort values1.begin  , values1.end   ; std::sort values2.begin  , values2.end   ; return values1    values2;      --- Step-by-Step Walkthrough Example: word1    cabbba , word2    abbccc     Step 1: Length Check len  cabbba     6, len  abbccc     6   Step 2: Count Frequencies word1 frequencies: c: 1, a: 2, b: 3 word2 frequencies: a: 1, b: 2, c: 3 Step 3: Check Character Sets word1 chars: a, b, c word2 chars: a, b, c   Step 4: Check Frequency Patterns word1 frequencies:  1, 2, 3  word2 frequencies:  1, 2, 3    Result: true   Example: word1    a , word2    aa    Step 1: Length Check len  a     1, len  aa     2   Result: false  early termination    Example: word1    abc , word2    bca    Step 1: Length Check len  abc     3, len  bca     3   Step 2: Count Frequencies word1 frequencies: a: 1, b: 1, c: 1 word2 frequencies: b: 1, c: 1, a: 1 Step 3: Check Character Sets word1 chars: a, b, c word2 chars: a, b, c   Step 4: Check Frequency Patterns word1 frequencies:  1, 1, 1  word2 frequencies:  1, 1, 1    Result: true   --- Why This Algorithm Works Operation 1  Swap  - Makes character order irrelevant, only frequencies matter Operation 2  Transform  - Allows swapping frequency counts between existing characters Character Set Check - Both strings must have exactly the same unique characters Frequency Pattern - The sorted frequency arrays must be identical --- Algorithm Analysis Key Insights:   Two strings are close if and only if: 1. Same character sets: set word1     set word2  2. Same frequency distribution: sorted freq1     sorted freq2  Why this works: - Operation 1: Rearrange   Order doesn t matter - Operation 2: Transform   Frequency counts can be swapped between chars Example Analysis: word1    aab    freq: a:2, b:1   pattern:  1,2  word2    bba    freq: b:2, a:1   pattern:  1,2  Same chars a,b, same pattern  1,2    Close   word1    aab    freq: a:2, b:1   pattern:  1,2  word2    bbc    freq: b:2, c:1   chars: b,c   a,b   Not close     --- Edge Cases  python Test cases: print closeStrings  abc ,  bca      true - same chars, same freq print closeStrings  a ,  aa      false - different lengths print closeStrings  cabbba ,  abbccc      true - same chars, diff freq distribution print closeStrings  cabbba ,  aabbss      false - different character sets print closeStrings   ,        true - both empty print closeStrings  a ,  b      false - different characters print closeStrings  aa ,  bb      false - different characters print closeStrings  abbbzcf ,  babzzcf      true - rearrangeable   --- Common Mistakes to Avoid 1. Ignoring length check: Always check if lengths are equal first 2. Wrong frequency comparison: Compare sorted frequency arrays, not the maps directly 3. Character set confusion: Must have exactly the same unique characters 4. Order dependency: Don t check character positions, only frequencies matter 5. Case sensitivity: Handle uppercase lowercase consistently --- Complexity Analysis Hash Map Approach  Optimal : Time: O n  - Single pass to count   O k log k  to sort frequencies where k   26 Space: O k  - Hash maps store at most 26 characters for lowercase letters --- Pattern Recognition This problem demonstrates key patterns: - Frequency Counting: Core technique for character element analysis - Set Comparison: Checking if two collections have same elements - Frequency Distribution: Comparing patterns rather than exact mappings - Invariant Properties: What remains constant under allowed operations You ll see similar patterns in: - Group Anagrams - Valid Anagram - Find All Anagrams in a String - Character replacement problems - String transformation problems --- Visual Representation   word1    cabbba , word2    abbccc  Frequency Analysis: word1: c 1    a 2    b 3     cabbba        v v v word2: c 3    a 1    b 2     abbccc  Character Sets: a,b,c    a,b,c   Frequency Patterns:  1,2,3      1,2,3    Transformation Path:  cabbba     caabbb   swap positions   caabbb     baaccc   transform c a   baaccc     abbccc   swap positions  Result: Close     --- Follow-up Questions Q: What if we allow insertion deletion operations? A: That would be edit distance problem - much more complex with dynamic programming. Q: Can this be solved without sorting? A: Yes, use frequency counting of frequencies, but sorting is simpler and efficient for small alphabets. Q: What about Unicode characters? A: Same algorithm works, but space complexity becomes O unique_chars  instead of O 26 . Q: How would you optimize for very large strings? A: Early termination after first mismatch in character sets, or use parallel processing for frequency counting. Q: What if strings can have different lengths but still be  close ? A: Then they can t be close - the operations preserve string length. --- Alternative Approaches Frequency of Frequencies: Instead of sorting frequency arrays, count how many characters appear with each frequency:  python def closeStrings_freq_of_freq word1, word2 : if len word1  !  len word2 : return False from collections import Counter freq1   Counter word1  freq2   Counter word2    Same character sets if set freq1.keys    !  set freq2.keys   : return False   Count frequency of frequencies freq_freq1   Counter freq1.values    freq_freq2   Counter freq2.values    return freq_freq1    freq_freq2    This avoids sorting but uses more space for the frequency-of-frequency counters.",
    "excerpt": "Determine if Two Strings Are Close Difficulty: Medium LeetCode: 1657. Determine if Two Strings Are Close --- Problem Two strings are considered close if you...",
    "url": "/docs/problems/determine-if-two-strings-are-close",
    "canonicalUrl": "https://crackmode.vercel.app/docs/problems/determine-if-two-strings-are-close",
    "section": "Problems",
    "tags": [
      "medium",
      "array",
      "arrays",
      "string",
      "strings",
      "sorting"
    ],
    "headings": [
      {
        "level": 1,
        "text": "Determine if Two Strings Are Close",
        "id": "determine-if-two-strings-are-close"
      },
      {
        "level": 2,
        "text": "Problem",
        "id": "problem"
      },
      {
        "level": 2,
        "text": "Simple Explanation",
        "id": "simple-explanation"
      },
      {
        "level": 2,
        "text": "Optimal Solutions",
        "id": "optimal-solutions"
      },
      {
        "level": 2,
        "text": "Step-by-Step Walkthrough",
        "id": "step-by-step-walkthrough"
      },
      {
        "level": 3,
        "text": "Example: word1 = \"cabbba\", word2 = \"abbccc\"",
        "id": "example-word1-cabbba-word2-abbccc"
      },
      {
        "level": 3,
        "text": "Example: word1 = \"a\", word2 = \"aa\"",
        "id": "example-word1-a-word2-aa"
      },
      {
        "level": 3,
        "text": "Example: word1 = \"abc\", word2 = \"bca\"",
        "id": "example-word1-abc-word2-bca"
      },
      {
        "level": 2,
        "text": "Why This Algorithm Works",
        "id": "why-this-algorithm-works"
      },
      {
        "level": 2,
        "text": "Algorithm Analysis",
        "id": "algorithm-analysis"
      },
      {
        "level": 3,
        "text": "Key Insights:",
        "id": "key-insights"
      },
      {
        "level": 2,
        "text": "Edge Cases",
        "id": "edge-cases"
      },
      {
        "level": 1,
        "text": "Test cases:",
        "id": "test-cases"
      },
      {
        "level": 2,
        "text": "Common Mistakes to Avoid",
        "id": "common-mistakes-to-avoid"
      },
      {
        "level": 2,
        "text": "Complexity Analysis",
        "id": "complexity-analysis"
      },
      {
        "level": 2,
        "text": "Pattern Recognition",
        "id": "pattern-recognition"
      },
      {
        "level": 2,
        "text": "Visual Representation",
        "id": "visual-representation"
      },
      {
        "level": 2,
        "text": "Follow-up Questions",
        "id": "follow-up-questions"
      },
      {
        "level": 2,
        "text": "Alternative Approaches",
        "id": "alternative-approaches"
      },
      {
        "level": 3,
        "text": "Frequency of Frequencies:",
        "id": "frequency-of-frequencies"
      }
    ],
    "publishedAt": "2026-01-04T04:18:51.313Z",
    "updatedAt": "2026-01-04T04:18:51.313Z",
    "author": "Morgan Ngetich",
    "readingTime": 7,
    "seo": {
      "title": "Determine If Two Strings Are Close | Crackmode Documentation",
      "description": "Determine if Two Strings Are Close Difficulty: Medium LeetCode: 1657. Determine if Two Strings Are Close --- Problem Two strings are considered close if you...",
      "keywords": "determine, strings, close, medium, array, arrays, string, sorting, frequency, character, check, operation, return, crackmode, leetcode, algorithm",
      "robots": "index,follow",
      "jsonLd": "{\"@context\":\"https://schema.org\",\"@type\":\"Article\",\"headline\":\"Determine If Two Strings Are Close\",\"description\":\"Determine if Two Strings Are Close Difficulty: Medium LeetCode: 1657. Determine if Two Strings Are Close --- Problem Two strings are considered close if you...\",\"url\":\"https://crackmode.vercel.app/docs/problems/determine-if-two-strings-are-close\",\"datePublished\":\"2026-01-04T04:18:51.313Z\",\"dateModified\":\"2026-01-04T04:18:51.313Z\",\"author\":{\"@type\":\"Person\",\"name\":\"Morgan Ngetich\"},\"publisher\":{\"@type\":\"Organization\",\"name\":\"CrackMode\",\"logo\":{\"@type\":\"ImageObject\",\"url\":\"https://crackmode.vercel.app/group.png\"}},\"mainEntityOfPage\":{\"@type\":\"WebPage\",\"@id\":\"https://crackmode.vercel.app/docs/problems/determine-if-two-strings-are-close\"},\"wordCount\":175,\"timeRequired\":\"PT7M\",\"inLanguage\":\"en-US\",\"isAccessibleForFree\":true}"
    },
    "socialMedia": {
      "ogTitle": "Determine If Two Strings Are Close | Crackmode Documentation",
      "ogDescription": "Two strings are considered close if you can attain one from the other using the following operations: 1. Operation 1: Swap any two existing characters.",
      "ogImage": "https://crackmode.vercel.app/api/v1/og?title=Determine+If+Two+Strings+Are+Close&description=Two+strings+are+considered+close+if+you+can+attain+one+from+the+other+using+the+following+operations%3A+1.+Operation+1%3A+Sw...&section=Documentation&theme=crackmode",
      "twitterTitle": "Determine If Two Strings Are Close | Crackmode Documentation",
      "twitterDescription": "Two strings are considered close if you can attain one from the other using the following operations: 1. Operation 1: Swap any two existing characters.",
      "twitterImage": "https://crackmode.vercel.app/api/v1/og?title=Determine+If+Two+Strings+Are+Close&description=Two+strings+are+considered+close+if+you+can+attain+one+from+the+other+using+the+following+operations%3A+1.+Operation+1%3A+Sw...&section=Documentation&theme=crackmode"
    }
  },
  {
    "id": "problems/distribute-candies",
    "title": "Distribute Candies",
    "content": "Distribute Candies Difficulty: Easy LeetCode: 575. Distribute Candies --- Problem Alice has n candies, where the ith candy is of type candyType i . Alice noticed that she started to gain weight, so she visited a doctor. The doctor advised Alice to only eat n   2 of the candies she has  n is always even . Alice likes her candies very much, and she wants to eat the maximum number of different types of candies while still following the doctor s advice. Given the integer array candyType of length n, return the maximum number of different types of candies she can eat if she only eats n   2 of them. Example 1:    Input: candyType    1,1,2,2,3,3  Output: 3 Explanation: Alice can only eat 6   2   3 candies. Since there are only 3 types, she can eat one of each type.   Example 2:   Input: candyType    1,1,2,3  Output: 2 Explanation: Alice can only eat 4   2   2 candies. Whether she eats types  1,2 ,  1,3 , or  2,3 , she still can only eat 2 different types.   Example 3:   Input: candyType    6,6,6,6  Output: 1 Explanation: Alice can only eat 4   2   2 candies. Even though she can eat 2 candies, she only has 1 type.   --- Simple Explanation Think of this like choosing different flavors at an ice cream shop with a limited budget! Just like in real life: - You have money for only 3 scoops  n 2   3  - The shop has flavors:  vanilla, vanilla, chocolate, chocolate, strawberry, strawberry  - You want maximum variety, so you pick: vanilla, chocolate, strawberry   3 different types!   - Even though you could pick 3 vanilla scoops, that s not maximizing variety The Key Insight: Alice wants maximum variety! She should pick one candy of each type until she either: 1. Runs out of allowed candies  n 2 , OR 2. Runs out of different types The answer is: min unique_types, n 2  --- Solution uniqueTypes   new HashSet    ; for  int candy : candyType  uniqueTypes.add candy ;    Alice can eat at most n 2 candies int maxCandies   candyType.length   2;    Return minimum for maximum variety return Math.min uniqueTypes.size  , maxCandies ;      --- Step-by-Step Walkthrough Let s trace through candyType    1,1,2,2,3,3 :    Step 1: Count unique candy types candyType    1,1,2,2,3,3  unique_types   1, 2, 3   3 different types Step 2: Calculate maximum candies Alice can eat total_candies   6 max_candies   6   2   3 Step 3: Find the limiting factor Alice wants maximum variety She can eat 3 candies and there are 3 types available result   min 3 types, 3 candies    3   Strategy: Pick one candy of each type:  1, 2, 3    Let s try another example: candyType    1,1,2,3 :   Step 1: Count unique types candyType    1,1,2,3  unique_types   1, 2, 3   3 different types Step 2: Calculate max candies total_candies   4 max_candies   4   2   2 Step 3: Find limiting factor Alice can only eat 2 candies but there are 3 types result   min 3 types, 2 candies    2   Strategy: Pick any 2 types, e.g.,  1, 2  or  1, 3  or  2, 3    Final example: candyType    6,6,6,6 :   Step 1: Count unique types candyType    6,6,6,6  unique_types   6   1 different type Step 2: Calculate max candies total_candies   4 max_candies   4   2   2 Step 3: Find limiting factor Alice can eat 2 candies but only 1 type exists result   min 1 type, 2 candies    1   Strategy: Pick 2 candies of type 6, but only 1 unique type   --- Why This Approach Works Greedy strategy - Always pick one of each type for maximum variety Two constraints - Limited by both candy count  n 2  and available types Simple math - Take minimum of the two limiting factors Set for uniqueness - Automatically handles counting distinct types --- Visual Understanding Let s visualize the decision process:   Scenario 1: Many types, few candies allowed candyType    1,2,3,4,5,6,7,8,9,10   10 candies, 10 types  max_candies   10 2   5 unique_types   10 result   min 10, 5    5   Limited by candy count Scenario 2: Few types, many candies allowed candyType    1,1,1,1,1,1   6 candies, 1 type  max_candies   6 2   3 unique_types   1 result   min 1, 3    1   Limited by variety Scenario 3: Perfect balance candyType    1,1,2,2,3,3   6 candies, 3 types  max_candies   6 2   3 unique_types   3 result   min 3, 3    3   Balanced   --- Alternative Counting Approach If you prefer explicit counting without sets:  python def distributeCandies_manual_count candyType :   Manually count unique types seen   for candy in candyType: seen candy    True unique_types   len seen  max_candies   len candyType     2 return min unique_types, max_candies    This does the same thing but shows the counting process explicitly. --- Real-World Analogy Think of it like planning a diverse meal with portion control: - You re at a buffet with 10 different dishes - Your diet plan allows only 4 servings total - To maximize nutrition variety, you d pick 4 different dishes - Even if there are 10 options, you re limited to 4 servings Same logic: - unique_types   dishes available - max_candies   servings allowed - result   maximum variety you can achieve --- Common Mistakes to Avoid 1. Overcomplicating: Don t try to track which specific candies to pick 2. Forgetting the constraint: Alice can only eat n 2 candies, not all of them 3. Misunderstanding the goal: She wants maximum variety, not maximum quantity 4. Integer division: Use    in Python or proper integer division 5. Edge cases: What if there are no candies?  Won t happen per constraints  --- Complexity Analysis Time Complexity: O n  Single pass to create the set of unique types Set operations are O 1  average case Space Complexity: O n  Set stores at most n unique candy types In worst case, all candies are different types --- Test Cases to Try  python Test your solution with these: print distributeCandies  1,1,2,2,3,3      Should return 3 print distributeCandies  1,1,2,3      Should return 2 print distributeCandies  6,6,6,6      Should return 1 print distributeCandies  1,1,1,1,2,2      Should return 2 print distributeCandies  1,2,3,4,5,6      Should return 3 print distributeCandies  100000,0,100000,0,100000,0,100000,0      Should return 2   --- Pattern Recognition This problem teaches important patterns: Greedy Choice: Always pick maximum variety when given freedom Constraint Optimization: Find the limiting factor among multiple constraints Set Usage: Use sets to count unique elements efficiently Min Max Logic: min available_options, allowed_choices  pattern appears frequently You ll see similar patterns in: - Resource allocation problems - Optimization with multiple constraints - Diversity maximization problems - Subset selection with limits --- Key Takeaway The beauty of this problem is its simplicity once you realize:   Alice should be greedy for variety - always pick different types until she hits a limit! The limit is either: - She runs out of candies she s allowed to eat  n 2 , OR - She runs out of different types to try Whichever comes first determines the answer: min unique_types, n 2",
    "excerpt": "Distribute Candies Difficulty: Easy LeetCode: 575. Distribute Candies --- Problem Alice has n candies, where the ith candy is of type candyType i .",
    "url": "/docs/problems/distribute-candies",
    "canonicalUrl": "https://crackmode.vercel.app/docs/problems/distribute-candies",
    "section": "Problems",
    "tags": [
      "easy",
      "array",
      "greedy",
      "leetcode",
      "optimization",
      "complexity"
    ],
    "headings": [
      {
        "level": 1,
        "text": "Distribute Candies",
        "id": "distribute-candies"
      },
      {
        "level": 2,
        "text": "Problem",
        "id": "problem"
      },
      {
        "level": 2,
        "text": "Simple Explanation",
        "id": "simple-explanation"
      },
      {
        "level": 2,
        "text": "Solution",
        "id": "solution"
      },
      {
        "level": 1,
        "text": "Example usage:",
        "id": "example-usage"
      },
      {
        "level": 1,
        "text": "candyType = [1,1,2,2,3,3]",
        "id": "candytype-112233"
      },
      {
        "level": 1,
        "text": "unique_types = len({1,2,3}) = 3",
        "id": "uniquetypes-len123-3"
      },
      {
        "level": 1,
        "text": "max_candies = 6 // 2 = 3",
        "id": "maxcandies-6-2-3"
      },
      {
        "level": 1,
        "text": "result = min(3, 3) = 3`",
        "id": "result-min3-3-3"
      },
      {
        "level": 2,
        "text": "Step-by-Step Walkthrough",
        "id": "step-by-step-walkthrough"
      },
      {
        "level": 2,
        "text": "Why This Approach Works",
        "id": "why-this-approach-works"
      },
      {
        "level": 2,
        "text": "Visual Understanding",
        "id": "visual-understanding"
      },
      {
        "level": 2,
        "text": "Alternative Counting Approach",
        "id": "alternative-counting-approach"
      },
      {
        "level": 2,
        "text": "Real-World Analogy",
        "id": "real-world-analogy"
      },
      {
        "level": 2,
        "text": "Common Mistakes to Avoid",
        "id": "common-mistakes-to-avoid"
      },
      {
        "level": 2,
        "text": "Complexity Analysis",
        "id": "complexity-analysis"
      },
      {
        "level": 2,
        "text": "Test Cases to Try",
        "id": "test-cases-to-try"
      },
      {
        "level": 1,
        "text": "Test your solution with these:",
        "id": "test-your-solution-with-these"
      },
      {
        "level": 2,
        "text": "Pattern Recognition",
        "id": "pattern-recognition"
      },
      {
        "level": 2,
        "text": "Key Takeaway",
        "id": "key-takeaway"
      }
    ],
    "publishedAt": "2026-01-04T04:18:51.313Z",
    "updatedAt": "2026-01-04T04:18:51.313Z",
    "author": "Morgan Ngetich",
    "readingTime": 6,
    "seo": {
      "title": "Distribute Candies | Crackmode Documentation",
      "description": "Distribute Candies Difficulty: Easy LeetCode: 575. Distribute Candies --- Problem Alice has n candies, where the ith candy is of type candyType i .",
      "keywords": "distribute, candies, easy, array, greedy, leetcode, optimization, complexity, types, candytype, alice, different, crackmode, algorithm",
      "robots": "index,follow",
      "jsonLd": "{\"@context\":\"https://schema.org\",\"@type\":\"Article\",\"headline\":\"Distribute Candies\",\"description\":\"Distribute Candies Difficulty: Easy LeetCode: 575. Distribute Candies --- Problem Alice has n candies, where the ith candy is of type candyType i .\",\"url\":\"https://crackmode.vercel.app/docs/problems/distribute-candies\",\"datePublished\":\"2026-01-04T04:18:51.313Z\",\"dateModified\":\"2026-01-04T04:18:51.313Z\",\"author\":{\"@type\":\"Person\",\"name\":\"Morgan Ngetich\"},\"publisher\":{\"@type\":\"Organization\",\"name\":\"CrackMode\",\"logo\":{\"@type\":\"ImageObject\",\"url\":\"https://crackmode.vercel.app/group.png\"}},\"mainEntityOfPage\":{\"@type\":\"WebPage\",\"@id\":\"https://crackmode.vercel.app/docs/problems/distribute-candies\"},\"wordCount\":168,\"timeRequired\":\"PT6M\",\"inLanguage\":\"en-US\",\"isAccessibleForFree\":true}"
    },
    "socialMedia": {
      "ogTitle": "Distribute Candies | Crackmode Documentation",
      "ogDescription": "Alice has n candies, where the ith candy is of type candyType[i]. Alice noticed that she started to gain weight, so she visited a doctor.",
      "ogImage": "https://crackmode.vercel.app/api/v1/og?title=Distribute+Candies&description=Alice+has+n+candies%2C+where+the+ith+candy+is+of+type+candyType%5Bi%5D.+Alice+noticed+that+she+started+to+gain+weight%2C+so+she...&section=Documentation&theme=crackmode",
      "twitterTitle": "Distribute Candies | Crackmode Documentation",
      "twitterDescription": "Alice has n candies, where the ith candy is of type candyType[i]. Alice noticed that she started to gain weight, so she visited a doctor.",
      "twitterImage": "https://crackmode.vercel.app/api/v1/og?title=Distribute+Candies&description=Alice+has+n+candies%2C+where+the+ith+candy+is+of+type+candyType%5Bi%5D.+Alice+noticed+that+she+started+to+gain+weight%2C+so+she...&section=Documentation&theme=crackmode"
    }
  },
  {
    "id": "problems/find-all-duplicates-in-an-array",
    "title": "Find All Duplicates In An Array",
    "content": "Find All Duplicates in an Array Difficulty: Medium LeetCode: 442. Find All Duplicates in an Array --- Problem Given an integer array nums of length n where all the integers of nums are in the range  1, n  and each integer appears at most twice, return an array of all the integers that appear twice. You must write an algorithm that runs in O n  time and uses only constant auxiliary space, excluding the space needed to store the output. Example 1:    Input: nums    4,3,2,7,8,2,3,1  Output:  2,3    Example 2:   Input: nums    1,1,2  Output:  1    Example 3:   Input: nums    1  Output:      Constraints: - n    nums.length - 1 0   mark:  4,3,2,-7,8,2,3,1  Process 3: index 2, nums 2  2   0   mark:  4,3,-2,-7,8,2,3,1  Process 2: index 1, nums 1  3   0   mark:  4,-3,-2,-7,8,2,3,1  Process 7: index 6, nums 6  3   0   mark:  4,-3,-2,-7,8,2,-3,1  Process 8: index 7, nums 7  1   0   mark:  4,-3,-2,-7,8,2,-3,-1  Process 2: index 1, nums 1  -3 0   mark:  -4,-3,-2,-7,8,2,-3,-1  Result:  2,3  , title:  JavaScript , language:  javascript , code:    In-place marking approach  O 1  space  function findDuplicates nums  const duplicates     ; for  let i   0; i findDuplicates int   nums  List duplicates   new ArrayList    ; for  int i   0; i findDuplicatesSet int   nums  Set seen   new HashSet    ; Set duplicates   new HashSet    ; for  int num : nums  if  seen.contains num   duplicates.add num ; else seen.add num ; return new ArrayList   duplicates ;      --- Step-by-Step Walkthrough Let s trace through the in-place marking approach with nums    4,3,2,7,8,2,3,1 :   Initial:  4, 3, 2, 7, 8, 2, 3, 1  Process 4  index 3 : nums 3  7   0   mark negative After:  4, 3, 2, -7, 8, 2, 3, 1  Process 3  index 2 : nums 2  2   0   mark negative After:  4, 3, -2, -7, 8, 2, 3, 1  Process 2  index 1 : nums 1  3   0   mark negative After:  4, -3, -2, -7, 8, 2, 3, 1  Process 7  index 6 : nums 6  3   0   mark negative After:  4, -3, -2, -7, 8, 2, -3, 1  Process 8  index 7 : nums 7  1   0   mark negative After:  4, -3, -2, -7, 8, 2, -3, -1  Process 2  index 1 : nums 1  -3 0   mark negative After:  -4, -3, -2, -7, 8, 2, -3, -1  Final Result:  2, 3    --- Why The In-Place Approach Works Uses array as hash table - Each number points to its corresponding index Negative   visited - First visit: mark negative, Second visit: found duplicate! Perfect range match - Numbers  1,n  map perfectly to indices  0,n-1  Constant space - No extra arrays or sets needed, meets the constraint! --- The Approach In-Place Marking  Optimal  - Meets all constraints: O n  time, O 1  space - Tricky but efficient: Uses the array itself as a marker - Modifies input: Changes the original array --- Common Mistakes to Avoid 1. Forgetting abs  : When checking nums index    0, the number itself might be negative from previous marking 2. Wrong index calculation: Remember index   num - 1 to convert from 1-based to 0-based 3. Using extra space: Counter and Set approaches don t meet the O 1  space requirement 4. Not handling edge cases: Empty array or single element should return empty list --- Complexity Analysis In-Place Marking  Optimal Solution : Time Complexity: O n  Single pass through the array Each operation is O 1  Space Complexity: O 1  Only uses a few variables Output space doesn t count toward space complexity --- When to Use This Pattern This  in-place marking  pattern works when: - Numbers are in range  1, n  and array length is n - You need constant space complexity - Input array can be modified - Looking for duplicates, missing numbers, or first occurrence Similar problems: - Find All Numbers Disappeared in an Array - Find the Duplicate Number - First Missing Positive --- Test Cases to Try  python Test your solution with these: print find_duplicates  4,3,2,7,8,2,3,1      Should return  2,3  print find_duplicates  1,1,2      Should return  1  print find_duplicates  1      Should return    print find_duplicates  1,1      Should return  1  print find_duplicates  2,2,3,3,4,4      Should return  2,3,4     --- Key Takeaways - In-place marking is a powerful technique for constant space solutions - Use array indices as hash keys when numbers match the range  1,n  - Negative values as markers is a clever way to track state without extra space - Always consider space complexity requirements - they often guide the approach choice!",
    "excerpt": "Find All Duplicates in an Array Difficulty: Medium LeetCode: 442. Find All Duplicates in an Array --- Problem Given an integer array nums of length n where all...",
    "url": "/docs/problems/find-all-duplicates-in-an-array",
    "canonicalUrl": "https://crackmode.vercel.app/docs/problems/find-all-duplicates-in-an-array",
    "section": "Problems",
    "tags": [
      "medium",
      "array",
      "arrays",
      "leetcode",
      "algorithm",
      "complexity"
    ],
    "headings": [
      {
        "level": 1,
        "text": "Find All Duplicates in an Array",
        "id": "find-all-duplicates-in-an-array"
      },
      {
        "level": 2,
        "text": "Problem",
        "id": "problem"
      },
      {
        "level": 2,
        "text": "Simple Explanation",
        "id": "simple-explanation"
      },
      {
        "level": 2,
        "text": "Solution",
        "id": "solution"
      },
      {
        "level": 1,
        "text": "Example walkthrough with [4,3,2,7,8,2,3,1]:",
        "id": "example-walkthrough-with-43278231"
      },
      {
        "level": 1,
        "text": "Process 4: index=3, nums[3]=7 > 0 â†’ mark: [4,3,2,-7,8,2,3,1]",
        "id": "process-4-index3-nums37-0-mark-432-78231"
      },
      {
        "level": 1,
        "text": "Process 3: index=2, nums[2]=2 > 0 â†’ mark: [4,3,-2,-7,8,2,3,1]",
        "id": "process-3-index2-nums22-0-mark-43-2-78231"
      },
      {
        "level": 1,
        "text": "Process 2: index=1, nums[1]=3 > 0 â†’ mark: [4,-3,-2,-7,8,2,3,1]",
        "id": "process-2-index1-nums13-0-mark-4-3-2-78231"
      },
      {
        "level": 1,
        "text": "Process 7: index=6, nums[6]=3 > 0 â†’ mark: [4,-3,-2,-7,8,2,-3,1]",
        "id": "process-7-index6-nums63-0-mark-4-3-2-782-31"
      },
      {
        "level": 1,
        "text": "Process 8: index=7, nums[7]=1 > 0 â†’ mark: [4,-3,-2,-7,8,2,-3,-1]",
        "id": "process-8-index7-nums71-0-mark-4-3-2-782-3-1"
      },
      {
        "level": 1,
        "text": "Process 2: index=1, nums[1]=-3 < 0 â†’ DUPLICATE! Add 2",
        "id": "process-2-index1-nums1-3-0-duplicate-add-2"
      },
      {
        "level": 1,
        "text": "Process 3: index=2, nums[2]=-2 < 0 â†’ DUPLICATE! Add 3",
        "id": "process-3-index2-nums2-2-0-duplicate-add-3"
      },
      {
        "level": 1,
        "text": "Process 1: index=0, nums[0]=4 > 0 â†’ mark: [-4,-3,-2,-7,8,2,-3,-1]",
        "id": "process-1-index0-nums04-0-mark-4-3-2-782-3-1"
      },
      {
        "level": 1,
        "text": "Result: [2,3]`",
        "id": "result-23"
      },
      {
        "level": 2,
        "text": "Step-by-Step Walkthrough",
        "id": "step-by-step-walkthrough"
      },
      {
        "level": 2,
        "text": "Why The In-Place Approach Works",
        "id": "why-the-in-place-approach-works"
      },
      {
        "level": 2,
        "text": "The Approach",
        "id": "the-approach"
      },
      {
        "level": 3,
        "text": "**In-Place Marking (Optimal)**",
        "id": "in-place-marking-optimal"
      },
      {
        "level": 2,
        "text": "Common Mistakes to Avoid",
        "id": "common-mistakes-to-avoid"
      },
      {
        "level": 2,
        "text": "Complexity Analysis",
        "id": "complexity-analysis"
      },
      {
        "level": 3,
        "text": "**In-Place Marking (Optimal Solution):**",
        "id": "in-place-marking-optimal-solution"
      },
      {
        "level": 2,
        "text": "When to Use This Pattern",
        "id": "when-to-use-this-pattern"
      },
      {
        "level": 2,
        "text": "Test Cases to Try",
        "id": "test-cases-to-try"
      },
      {
        "level": 1,
        "text": "Test your solution with these:",
        "id": "test-your-solution-with-these"
      },
      {
        "level": 2,
        "text": "Key Takeaways",
        "id": "key-takeaways"
      }
    ],
    "publishedAt": "2026-01-04T04:18:51.313Z",
    "updatedAt": "2026-01-04T04:18:51.313Z",
    "author": "Morgan Ngetich",
    "readingTime": 4,
    "seo": {
      "title": "Find All Duplicates In An Array | Crackmode Documentation",
      "description": "Find All Duplicates in an Array Difficulty: Medium LeetCode: 442. Find All Duplicates in an Array --- Problem Given an integer array nums of length n where all...",
      "keywords": "find, duplicates, array, medium, arrays, leetcode, algorithm, complexity, index, space, process, negative, crackmode",
      "robots": "index,follow",
      "jsonLd": "{\"@context\":\"https://schema.org\",\"@type\":\"Article\",\"headline\":\"Find All Duplicates In An Array\",\"description\":\"Find All Duplicates in an Array Difficulty: Medium LeetCode: 442. Find All Duplicates in an Array --- Problem Given an integer array nums of length n where all...\",\"url\":\"https://crackmode.vercel.app/docs/problems/find-all-duplicates-in-an-array\",\"datePublished\":\"2026-01-04T04:18:51.313Z\",\"dateModified\":\"2026-01-04T04:18:51.313Z\",\"author\":{\"@type\":\"Person\",\"name\":\"Morgan Ngetich\"},\"publisher\":{\"@type\":\"Organization\",\"name\":\"CrackMode\",\"logo\":{\"@type\":\"ImageObject\",\"url\":\"https://crackmode.vercel.app/group.png\"}},\"mainEntityOfPage\":{\"@type\":\"WebPage\",\"@id\":\"https://crackmode.vercel.app/docs/problems/find-all-duplicates-in-an-array\"},\"wordCount\":196,\"timeRequired\":\"PT4M\",\"inLanguage\":\"en-US\",\"isAccessibleForFree\":true}"
    },
    "socialMedia": {
      "ogTitle": "Find All Duplicates In An Array | Crackmode Documentation",
      "ogDescription": "Given an integer array nums of length n where all the integers of nums are in the range [1, n] and each integer appears at most twice, return an array of all the integers that...",
      "ogImage": "https://crackmode.vercel.app/api/v1/og?title=Find+All+Duplicates+In+An+Array&description=Given+an+integer+array+nums+of+length+n+where+all+the+integers+of+nums+are+in+the+range+%5B1%2C+n%5D+and+each+integer+appears...&section=Documentation&theme=crackmode",
      "twitterTitle": "Find All Duplicates In An Array | Crackmode Documentation",
      "twitterDescription": "Given an integer array nums of length n where all the integers of nums are in the range [1, n] and each integer appears at most twice, return an array of all the integers that...",
      "twitterImage": "https://crackmode.vercel.app/api/v1/og?title=Find+All+Duplicates+In+An+Array&description=Given+an+integer+array+nums+of+length+n+where+all+the+integers+of+nums+are+in+the+range+%5B1%2C+n%5D+and+each+integer+appears...&section=Documentation&theme=crackmode"
    }
  },
  {
    "id": "problems/find-all-numbers-disappeared-in-an-array",
    "title": "Find All Numbers Disappeared In An Array",
    "content": "Find All Numbers Disappeared in an Array Difficulty: Easy LeetCode: 448. Find All Numbers Disappeared in an Array --- Problem Given an array nums of n integers where nums i  is in the range  1, n , return an array of all the integers in the range  1, n  that do not appear in nums. Example 1:    Input: nums    4,3,2,7,8,2,3,1  Output:  5,6    Example 2:   Input: nums    1,1  Output:  2    --- Simple Explanation Think of this like roll call attendance! Just like in school: - You have a class list:  1, 2, 3, 4, 5, 6, 7, 8   expected students  - Students present:  4, 3, 2, 7, 8, 2, 3, 1   actual attendance  - Missing students:  5, 6    These are who didn t show up!   The Plan: Create a complete list of expected numbers  1 to n , then find which ones are missing from our input array! --- Solution findDisappearedNumbers int   nums     Convert array to HashSet for O 1  lookup Set numsSet   new HashSet    ; for  int num : nums  numsSet.add num ;    Find missing numbers List result   new ArrayList    ; for  int i   1; i findDisappearedNumbersSet int   nums  Set numsSet   new HashSet    ; Set expectedSet   new HashSet    ;    Add all numbers from nums for  int num : nums  numsSet.add num ;    Add expected numbers 1 to n for  int i   1; i  expectedSet ;      --- Step-by-Step Walkthrough Let s trace through nums    4,3,2,7,8,2,3,1 :    Step 1: Convert nums to set  removes duplicates  nums_set   1, 2, 3, 4, 7, 8 Step 2: Create expected set  1 to n  where n   8 expected_set   1, 2, 3, 4, 5, 6, 7, 8 Step 3: Find set difference  expected - nums  missing   1, 2, 3, 4, 5, 6, 7, 8 - 1, 2, 3, 4, 7, 8 missing   5, 6 Result:  5, 6  are the missing numbers!   Let s try the second example: nums    1,1 :   Step 1: Convert nums to set nums_set   1 Step 2: Create expected set  1 to 2  expected_set   1, 2 Step 3: Find set difference missing   1, 2 - 1   2 Result:  2  is the missing number!   --- Why This Approach Works Fast lookup - Sets give us O 1  checking if a number exists Handles duplicates - Converting to set automatically removes duplicates Clean logic - Set difference does the heavy lifting for us Easy to understand - Just like checking attendance in a classroom! --- Alternative Approaches Approach 1: Simple Loop  Slower but Clear  findDisappearedNumbersSimple int   nums  List result   new ArrayList    ;    Check each number from 1 to n using linear search for  int i   1; i Approach 2: In-Place Marking  O 1  Space  0: nums index    -nums index    Find positive numbers  unvisited  result      for i in range len nums  : if nums i    0: result.append i   1  return result Example: nums    4,3,2,7,8,2,3,1  After marking:  -4, -3, -2, -7, 8, 2, -3, -1  Missing:  5, 6  , title:  JavaScript , language:  javascript , code: function findDisappearedNumbersInplace nums     Mark visited indices as negative for  let i   0; i 0  nums index    -nums index ;    Find indices with positive values const result     ; for  let i   0; i 0  result.push i   1 ; return result;    Example:    nums    4,3,2,7,8,2,3,1     result    5,6  , title:  Java , language:  java , code: import java.util. ; public class Solution public List findDisappearedNumbersInplace int   nums     Mark visited numbers by negating the value at the corresponding index for  int i   0; i 0  nums index    -nums index ;    Find indices with positive values List result   new ArrayList    ; for  int i   0; i 0  result.add i   1 ; return result;    Example:    nums    4,3,2,7,8,2,3,1     Output:  5,6       --- Visual Example    Array:  4, 3, 2, 7, 8, 2, 3, 1  Index: 0 1 2 3 4 5 6 7 Expected numbers: 1, 2, 3, 4, 5, 6, 7, 8 Present numbers: 1, 2, 3, 4,  ,  , 7, 8     5 6   Missing! Result:  5, 6    --- Common Mistakes to Avoid 1. Using list instead of set: if i not in nums is O n , making total complexity O n   2. Forgetting duplicates: The input can have duplicate numbers, but we only care about unique ones 3. Wrong range: Remember the range is  1, n , not  0, n-1  4. Modifying original array: Unless specifically asked for in-place solution --- Complexity Analysis Time Complexity: O n  Creating the set from nums: O n  Creating expected set: O n  Set difference operation: O n  Converting back to list: O k  where k   n Space Complexity: O n  nums_set can store up to n elements expected_set stores exactly n elements Result list can store up to n elements --- When to Use This Pattern This  find missing elements  pattern is useful when: - You have a known expected range of values - You need to find what s missing from that range - You want fast lookup operations - Input may contain duplicates that you need to handle Similar problems: - Missing Number  single missing  - First Missing Positive - Find All Duplicates in Array --- Test Cases to Try  python Test your solution with these: print find_disappeared_numbers  4,3,2,7,8,2,3,1      Should return  5,6  print find_disappeared_numbers  1,1      Should return  2  print find_disappeared_numbers  1,2,3,4,5      Should return    print find_disappeared_numbers  2,2,2,2,2      Should return  1,3,4,5  print find_disappeared_numbers  1      Should return      --- Key Takeaways - Sets are powerful for membership testing and set operations - Set difference  A - B   finds elements in A but not in B - Converting to set automatically handles duplicates - Think in terms of expected vs actual - like attendance checking!",
    "excerpt": "Find All Numbers Disappeared in an Array Difficulty: Easy LeetCode: 448. Find All Numbers Disappeared in an Array --- Problem Given an array nums of n integers...",
    "url": "/docs/problems/find-all-numbers-disappeared-in-an-array",
    "canonicalUrl": "https://crackmode.vercel.app/docs/problems/find-all-numbers-disappeared-in-an-array",
    "section": "Problems",
    "tags": [
      "easy",
      "array",
      "leetcode",
      "complexity",
      "pattern",
      "javascript"
    ],
    "headings": [
      {
        "level": 1,
        "text": "Find All Numbers Disappeared in an Array",
        "id": "find-all-numbers-disappeared-in-an-array"
      },
      {
        "level": 2,
        "text": "Problem",
        "id": "problem"
      },
      {
        "level": 2,
        "text": "Simple Explanation",
        "id": "simple-explanation"
      },
      {
        "level": 2,
        "text": "Solution",
        "id": "solution"
      },
      {
        "level": 1,
        "text": "Example usage:",
        "id": "example-usage"
      },
      {
        "level": 1,
        "text": "nums = [4,3,2,7,8,2,3,1]",
        "id": "nums-43278231"
      },
      {
        "level": 1,
        "text": "nums_set = {1, 2, 3, 4, 7, 8}",
        "id": "numsset-1-2-3-4-7-8"
      },
      {
        "level": 1,
        "text": "expected = {1, 2, 3, 4, 5, 6, 7, 8}",
        "id": "expected-1-2-3-4-5-6-7-8"
      },
      {
        "level": 1,
        "text": "missing = {5, 6} â†’ return [5, 6]`",
        "id": "missing-5-6-return-5-6"
      },
      {
        "level": 2,
        "text": "Step-by-Step Walkthrough",
        "id": "step-by-step-walkthrough"
      },
      {
        "level": 2,
        "text": "Why This Approach Works",
        "id": "why-this-approach-works"
      },
      {
        "level": 2,
        "text": "Alternative Approaches",
        "id": "alternative-approaches"
      },
      {
        "level": 3,
        "text": "Approach 1: Simple Loop (Slower but Clear)",
        "id": "approach-1-simple-loop-slower-but-clear"
      },
      {
        "level": 1,
        "text": "Example:",
        "id": "example"
      },
      {
        "level": 1,
        "text": "nums = [4,3,2,7,8,2,3,1]",
        "id": "nums-43278231-1"
      },
      {
        "level": 1,
        "text": "missing = [5, 6]`",
        "id": "missing-5-6"
      },
      {
        "level": 3,
        "text": "Approach 2: In-Place Marking (O(1) Space)",
        "id": "approach-2-in-place-marking-o1-space"
      },
      {
        "level": 1,
        "text": "Example:",
        "id": "example-1"
      },
      {
        "level": 1,
        "text": "nums = [4,3,2,7,8,2,3,1]",
        "id": "nums-43278231-2"
      },
      {
        "level": 1,
        "text": "After marking: [-4, -3, -2, -7, 8, 2, -3, -1]",
        "id": "after-marking-4-3-2-7-8-2-3-1"
      },
      {
        "level": 1,
        "text": "Missing: [5, 6]`",
        "id": "missing-5-6-1"
      },
      {
        "level": 2,
        "text": "Visual Example",
        "id": "visual-example"
      },
      {
        "level": 2,
        "text": "Common Mistakes to Avoid",
        "id": "common-mistakes-to-avoid"
      },
      {
        "level": 2,
        "text": "Complexity Analysis",
        "id": "complexity-analysis"
      },
      {
        "level": 2,
        "text": "When to Use This Pattern",
        "id": "when-to-use-this-pattern"
      },
      {
        "level": 2,
        "text": "Test Cases to Try",
        "id": "test-cases-to-try"
      },
      {
        "level": 1,
        "text": "Test your solution with these:",
        "id": "test-your-solution-with-these"
      },
      {
        "level": 2,
        "text": "Key Takeaways",
        "id": "key-takeaways"
      }
    ],
    "publishedAt": "2026-01-04T04:18:51.317Z",
    "updatedAt": "2026-01-04T04:18:51.317Z",
    "author": "Morgan Ngetich",
    "readingTime": 5,
    "seo": {
      "title": "Find All Numbers Disappeared In An Array | Crackmode Documentation",
      "description": "Find All Numbers Disappeared in an Array Difficulty: Easy LeetCode: 448. Find All Numbers Disappeared in an Array --- Problem Given an array nums of n integers...",
      "keywords": "find, numbers, disappeared, array, easy, leetcode, complexity, pattern, javascript, missing, expected, return, result, crackmode, algorithm",
      "robots": "index,follow",
      "jsonLd": "{\"@context\":\"https://schema.org\",\"@type\":\"Article\",\"headline\":\"Find All Numbers Disappeared In An Array\",\"description\":\"Find All Numbers Disappeared in an Array Difficulty: Easy LeetCode: 448. Find All Numbers Disappeared in an Array --- Problem Given an array nums of n integers...\",\"url\":\"https://crackmode.vercel.app/docs/problems/find-all-numbers-disappeared-in-an-array\",\"datePublished\":\"2026-01-04T04:18:51.317Z\",\"dateModified\":\"2026-01-04T04:18:51.317Z\",\"author\":{\"@type\":\"Person\",\"name\":\"Morgan Ngetich\"},\"publisher\":{\"@type\":\"Organization\",\"name\":\"CrackMode\",\"logo\":{\"@type\":\"ImageObject\",\"url\":\"https://crackmode.vercel.app/group.png\"}},\"mainEntityOfPage\":{\"@type\":\"WebPage\",\"@id\":\"https://crackmode.vercel.app/docs/problems/find-all-numbers-disappeared-in-an-array\"},\"wordCount\":189,\"timeRequired\":\"PT5M\",\"inLanguage\":\"en-US\",\"isAccessibleForFree\":true}"
    },
    "socialMedia": {
      "ogTitle": "Find All Numbers Disappeared In An Array | Crackmode Documentation",
      "ogDescription": "Given an array nums of n integers where nums[i] is in the range [1, n], return an array of all the integers in the range [1, n] that do not appear in nums.",
      "ogImage": "https://crackmode.vercel.app/api/v1/og?title=Find+All+Numbers+Disappeared+In+An+Array&description=Given+an+array+nums+of+n+integers+where+nums%5Bi%5D+is+in+the+range+%5B1%2C+n%5D%2C+return+an+array+of+all+the+integers+in+the+range...&section=Documentation&theme=crackmode",
      "twitterTitle": "Find All Numbers Disappeared In An Array | Crackmode Documentation",
      "twitterDescription": "Given an array nums of n integers where nums[i] is in the range [1, n], return an array of all the integers in the range [1, n] that do not appear in nums.",
      "twitterImage": "https://crackmode.vercel.app/api/v1/og?title=Find+All+Numbers+Disappeared+In+An+Array&description=Given+an+array+nums+of+n+integers+where+nums%5Bi%5D+is+in+the+range+%5B1%2C+n%5D%2C+return+an+array+of+all+the+integers+in+the+range...&section=Documentation&theme=crackmode"
    }
  },
  {
    "id": "problems/find-the-difference",
    "title": "Find The Difference",
    "content": "Find the Difference Difficulty: Easy LeetCode: 389. Find the Difference --- Problem You are given two strings s and t. String t is generated by random shuffling string s and then add one more letter at a random position. Return the letter that was added to t. Example 1:    Input: s    abcd , t    abcde  Output:  e  Explanation:  e  is the letter that was added.   Example 2:   Input: s     , t    y  Output:  y    Example 3:   Input: s    ae , t    aea  Output:  a  Explanation:  a  is the letter that was added.   --- Simple Explanation Think of this like counting items in two bags! Just like in real life: - Bag A has: 1 apple, 1 banana, 1 cherry - Bag B has: 1 apple, 1 banana, 1 cherry, 1 grape   grape is the extra item!   The Plan: Count how many times each letter appears in both strings. The letter that appears more in t is our answer! --- Solution sCount   new HashMap    ; for  char c : s.toCharArray    sCount.put c, sCount.getOrDefault c, 0    1 ;    Count letters in t Map tCount   new HashMap    ; for  char c : t.toCharArray    tCount.put c, tCount.getOrDefault c, 0    1 ;    Find the different letter for  char letter : tCount.keySet    int tFreq   tCount.get letter ; int sFreq   sCount.getOrDefault letter, 0 ; if  tFreq !  sFreq  return letter; return   0 ;      --- Step-by-Step Walkthrough Let s trace through s    abcd , t    abcde :    Step 1: Count letters in s    abcd  s_count    a : 1,  b : 1,  c : 1,  d : 1 Step 2: Count letters in t    abcde  t_count    a : 1,  b : 1,  c : 1,  d : 1,  e : 1 Step 3: Compare counts for each letter in t  a : t has 1, s has 1   Same    b : t has 1, s has 1   Same    c : t has 1, s has 1   Same    d : t has 1, s has 1   Same    e : t has 1, s has 0  doesn t exist    Different!   Result:  e  is the extra letter!   Let s try another example: s    ae , t    aea :   Step 1: Count letters in s    ae  s_count    a : 1,  e : 1 Step 2: Count letters in t    aea  t_count    a : 2,  e : 1 Step 3: Compare counts  a : t has 2, s has 1   Different!   Result:  a  is the extra letter!   --- Why This Approach Works Easy to understand - Just count and compare, like counting toys Handles all cases - Works whether the extra letter is new or repeated Built-in tools - Python s Counter does the hard work for us Clear logic - If counts don t match, we found our answer! --- Alternative Simple Approach If you want an even simpler approach  though less efficient , you can check each letter:  python def find_the_difference_simple s, t :   Try each letter in t for letter in t:   Count how many times it appears in both strings count_in_s   s.count letter  count_in_t   t.count letter    If counts are different, this is our answer if count_in_t   count_in_s: return letter return      This is slower but very easy to understand! --- Common Mistakes to Avoid 1. Forgetting edge cases: What if s is empty? The solution still works! 2. Assuming only new letters: The extra letter might be a duplicate, not a new one 3. Not handling missing keys: Always check if a letter exists in the dictionary 4. Overcomplicating: The counting approach is simple and works for all cases --- Complexity Analysis Time Complexity: O n  We go through each string once to count letters Then we check each letter in t  at most n 1 letters  Space Complexity: O 1  We store at most 26 different letters  a-z  This is constant space, not dependent on input size --- Test Cases to Try   python Test your solution with these: print find_the_difference  abcd ,  abcde      Should return  e  print find_the_difference   ,  y      Should return  y  print find_the_difference  ae ,  aea      Should return  a  print find_the_difference  a ,  aa      Should return  a  print find_the_difference  ymbgaraibkfmvocpizdydugvalagaivdbfhvbksexkfrzrfrukndvuaobvfvwmmpnqivjyihhhwjuwfjmcryrz",
    "excerpt": "Find the Difference Difficulty: Easy LeetCode: 389. Find the Difference --- Problem You are given two strings s and t.",
    "url": "/docs/problems/find-the-difference",
    "canonicalUrl": "https://crackmode.vercel.app/docs/problems/find-the-difference",
    "section": "Problems",
    "tags": [
      "easy",
      "hard",
      "array",
      "string",
      "strings",
      "leetcode"
    ],
    "headings": [
      {
        "level": 1,
        "text": "Find the Difference",
        "id": "find-the-difference"
      },
      {
        "level": 2,
        "text": "Problem",
        "id": "problem"
      },
      {
        "level": 2,
        "text": "Simple Explanation",
        "id": "simple-explanation"
      },
      {
        "level": 2,
        "text": "Solution",
        "id": "solution"
      },
      {
        "level": 1,
        "text": "Example usage:",
        "id": "example-usage"
      },
      {
        "level": 1,
        "text": "s = \"abcd\", t = \"abcde\"",
        "id": "s-abcd-t-abcde"
      },
      {
        "level": 1,
        "text": "s_count = {'a': 1, 'b': 1, 'c': 1, 'd': 1}",
        "id": "scount-a-1-b-1-c-1-d-1"
      },
      {
        "level": 1,
        "text": "t_count = {'a': 1, 'b': 1, 'c': 1, 'd': 1, 'e': 1}",
        "id": "tcount-a-1-b-1-c-1-d-1-e-1"
      },
      {
        "level": 1,
        "text": "'e' is not in s_count, so return 'e'`",
        "id": "e-is-not-in-scount-so-return-e"
      },
      {
        "level": 2,
        "text": "Step-by-Step Walkthrough",
        "id": "step-by-step-walkthrough"
      },
      {
        "level": 2,
        "text": "Why This Approach Works",
        "id": "why-this-approach-works"
      },
      {
        "level": 2,
        "text": "Alternative Simple Approach",
        "id": "alternative-simple-approach"
      },
      {
        "level": 2,
        "text": "Common Mistakes to Avoid",
        "id": "common-mistakes-to-avoid"
      },
      {
        "level": 2,
        "text": "Complexity Analysis",
        "id": "complexity-analysis"
      },
      {
        "level": 2,
        "text": "Test Cases to Try",
        "id": "test-cases-to-try"
      },
      {
        "level": 1,
        "text": "Test your solution with these:",
        "id": "test-your-solution-with-these"
      }
    ],
    "publishedAt": "2026-01-04T04:18:51.317Z",
    "updatedAt": "2026-01-04T04:18:51.317Z",
    "author": "Morgan Ngetich",
    "readingTime": 4,
    "seo": {
      "title": "Find The Difference | Crackmode Documentation",
      "description": "Find the Difference Difficulty: Easy LeetCode: 389. Find the Difference --- Problem You are given two strings s and t.",
      "keywords": "find, difference, easy, hard, array, string, strings, leetcode, letter, return, count, letters, extra, crackmode, algorithm",
      "robots": "index,follow",
      "jsonLd": "{\"@context\":\"https://schema.org\",\"@type\":\"Article\",\"headline\":\"Find The Difference\",\"description\":\"Find the Difference Difficulty: Easy LeetCode: 389. Find the Difference --- Problem You are given two strings s and t.\",\"url\":\"https://crackmode.vercel.app/docs/problems/find-the-difference\",\"datePublished\":\"2026-01-04T04:18:51.317Z\",\"dateModified\":\"2026-01-04T04:18:51.317Z\",\"author\":{\"@type\":\"Person\",\"name\":\"Morgan Ngetich\"},\"publisher\":{\"@type\":\"Organization\",\"name\":\"CrackMode\",\"logo\":{\"@type\":\"ImageObject\",\"url\":\"https://crackmode.vercel.app/group.png\"}},\"mainEntityOfPage\":{\"@type\":\"WebPage\",\"@id\":\"https://crackmode.vercel.app/docs/problems/find-the-difference\"},\"wordCount\":140,\"timeRequired\":\"PT4M\",\"inLanguage\":\"en-US\",\"isAccessibleForFree\":true}"
    },
    "socialMedia": {
      "ogTitle": "Find The Difference | Crackmode Documentation",
      "ogDescription": "You are given two strings s and t. String t is generated by random shuffling string s and then add one more letter at a random position. Return the letter that was added to t.",
      "ogImage": "https://crackmode.vercel.app/api/v1/og?title=Find+The+Difference&description=You+are+given+two+strings+s+and+t.+String+t+is+generated+by+random+shuffling+string+s+and+then+add+one+more+letter+at+a...&section=Documentation&theme=crackmode",
      "twitterTitle": "Find The Difference | Crackmode Documentation",
      "twitterDescription": "You are given two strings s and t. String t is generated by random shuffling string s and then add one more letter at a random position. Return the letter that was added to t.",
      "twitterImage": "https://crackmode.vercel.app/api/v1/og?title=Find+The+Difference&description=You+are+given+two+strings+s+and+t.+String+t+is+generated+by+random+shuffling+string+s+and+then+add+one+more+letter+at+a...&section=Documentation&theme=crackmode"
    }
  },
  {
    "id": "problems/find-the-difference-of-two-arrays",
    "title": "Find The Difference Of Two Arrays",
    "content": "Find the Difference of Two Arrays Difficulty: Easy LeetCode: 2215. Find the Difference of Two Arrays --- Problem Given two 0-indexed integer arrays nums1 and nums2, return a list answer of size 2 where: - answer 0  is a list of all distinct integers in nums1 which are not present in nums2. - answer 1  is a list of all distinct integers in nums2 which are not present in nums1. Note that the integers in the lists may be returned in any order. Example 1:    Input: nums1    1,2,3 , nums2    2,4,6  Output:   1,3 , 4,6   Explanation: For nums1, nums1 1    2 is present at index 0 of nums2, whereas nums1 0    1 and nums1 2    3 are not present in nums2. Therefore, answer 0     1,3 . For nums2, nums2 0    2 is present at index 1 of nums1, whereas nums2 1    4 and nums2 2    6 are not present in nums1. Therefore, answer 1     4,6 .   Example 2:   Input: nums1    1,2,3,3 , nums2    1,1,2,2  Output:   3 ,    Explanation: For nums1, nums1 2  and nums1 3  are not present in nums2. Since nums1 2     nums1 3 , their value is only included once and answer 0     3 . Every integer in nums2 is present in nums1. Therefore, answer 1      .   Constraints: - 1 !set2.has x  ; const diff2    ...set2 .filter x    !set1.has x  ; return  diff1, diff2 ; ;    Approach 2: Hash Set Lookup var findDifferenceHashSet   function nums1, nums2  const set1   new Set nums1 ; const set2   new Set nums2 ; const result      ,    ;    Find elements in nums1 not in nums2 for  let num of set1  if  !set2.has num   result 0 .push num ;    Find elements in nums2 not in nums1 for  let num of set2  if  !set1.has num   result 1 .push num ; return result; ;    Approach 3: Using Set Difference  ES6 Style  var findDifferenceES6   function nums1, nums2  const set1   new Set nums1 ; const set2   new Set nums2 ; return   Array.from set1 .filter x    !set2.has x  , Array.from set2 .filter x    !set1.has x    ; ; , title:  Python , language:  python , code: class Solution:   Approach 1: Set Operations  Most Pythonic  def findDifference self, nums1: List int , nums2: List int   -  List List int  : set1, set2   set nums1 , set nums2  return  list set1 - set2 , list set2 - set1     Approach 2: Set Comprehension def findDifferenceComprehension self, nums1: List int , nums2: List int   -  List List int  : set1, set2   set nums1 , set nums2  return    x for x in set1 if x not in set2 ,  x for x in set2 if x not in set1      Approach 3: Hash Set Lookup def findDifferenceHashSet self, nums1: List int , nums2: List int   -  List List int  : set1, set2   set nums1 , set nums2  result      ,       Find elements in nums1 not in nums2 for num in set1: if num not in set2: result 0 .append num    Find elements in nums2 not in nums1 for num in set2: if num not in set1: result 1 .append num  return result   Approach 4: Using filter def findDifferenceFilter self, nums1: List int , nums2: List int   -  List List int  : set1, set2   set nums1 , set nums2  return   list filter lambda x: x not in set2, set1  , list filter lambda x: x not in set1, set2     , title:  C   , language:  cpp , code:  include  include  include using namespace std; class Solution public:    Approach 1: Unordered Set vector  findDifference vector  nums1, vector  nums2  unordered_set set1 nums1.begin  , nums1.end   ; unordered_set set2 nums2.begin  , nums2.end   ; vector  result 2 ;    Find elements in set1 not in set2 for  int num : set1  if  set2.find num     set2.end    result 0 .push_back num ;    Find elements in set2 not in set1 for  int num : set2  if  set1.find num     set1.end    result 1 .push_back num ; return result;    Approach 2: Using set_difference  STL  vector  findDifferenceSTL vector  nums1, vector  nums2  set set1 nums1.begin  , nums1.end   ; set set2 nums2.begin  , nums2.end   ; vector diff1, diff2; set_difference set1.begin  , set1.end  , set2.begin  , set2.end  , back_inserter diff1  ; set_difference set2.begin  , set2.end  , set1.begin  , set1.end  , back_inserter diff2  ; return diff1, diff2; ; , title:  Java , language:  java , code: import java.util. ; class Solution    Approach 1: HashSet public List  findDifference int   nums1, int   nums2  Set set1   new HashSet    ; Set set2   new HashSet    ; for  int num : nums1  set1.add num ; for  int num : nums2  set2.add num ; List  result   new ArrayList    ; result.add new ArrayList     ; result.add new ArrayList     ;    Find elements in set1 not in set2 for  int num : set1  if  !set2.contains num   result.get 0 .add num ;    Find elements in set2 not in set1 for  int num : set2  if  !set1.contains num   result.get 1 .add num ; return result;    Approach 2: Using Streams  Java 8   public List  findDifferenceStreams int   nums1, int   nums2  Set set1   Arrays.stream nums1 .boxed   .collect Collectors.toSet   ; Set set2   Arrays.stream nums2 .boxed   .collect Collectors.toSet   ; List diff1   set1.stream   .filter x -  !set2.contains x   .collect Collectors.toList   ; List diff2   set2.stream   .filter x -  !set1.contains x   .collect Collectors.toList   ; return Arrays.asList diff1, diff2 ; ,      --- Step-by-Step Walkthrough Let s trace through Example 1 with nums1    1,2,3  and nums2    2,4,6 : Set Operations Approach:   Step 1: Create sets set1   1, 2, 3 set2   2, 4, 6 Step 2: Find set1 - set2  elements in set1 but not in set2  set1 - set2   1, 3 Step 3: Find set2 - set1  elements in set2 but not in set1  set2 - set1   4, 6 Result:   1, 3 ,  4, 6     Let s trace through Example 2 with nums1    1,2,3,3  and nums2    1,1,2,2 :   Step 1: Create sets  duplicates automatically removed  set1   1, 2, 3 set2   1, 2 Step 2: Find differences set1 - set2   3 set2 - set1    empty set  Result:   3 ,       --- Algorithm Intuition This problem is fundamentally about set operations:    Find elements that are unique to each array  The key insights are: 1. Duplicates within arrays don t matter - we only care about distinct values 2. We need symmetric difference - elements in A but not B, and elements in B but not A 3. Order doesn t matter - we can return results in any order The constraint -1000 Set operations - perfect for finding differences and handling duplicates Automatic deduplication - sets naturally handle duplicate removal Symmetric difference - finding elements unique to each set Hash lookup - O 1  membership testing makes this efficient --- Edge Cases to Consider 1. Empty arrays: nums1     , nums2    1,2       ,  1,2   2. Identical arrays: nums1    1,2 , nums2    1,2       ,     3. No common elements: nums1    1,2 , nums2    3,4      1,2 ,  3,4   4. One array subset of other: nums1    1,2,3 , nums2    1,2      3 ,     5. Many duplicates: nums1    1,1,1 , nums2    2,2,2      1 ,  2   --- Follow-up Questions 1. What if we needed to preserve order of first occurrence? - Use ordered sets or track indices during iteration 2. What about finding intersection instead of difference? - Use set1   set2  intersection operation  3. How would this scale to k arrays? - Generalize to finding elements unique to each of k sets 4. What if memory was extremely limited? - Process one array at a time, use bit manipulation for small ranges --- Related Problems - 268. Missing Number - Finding what s missing using set operations - 349. Intersection of Two Arrays - Finding common elements - 287. Find the Duplicate Number - Set-based duplicate detection --- This problem beautifully demonstrates how set theory and hash-based data structures can elegantly solve array difference problems with optimal time complexity!",
    "excerpt": "Find the Difference of Two Arrays Difficulty: Easy LeetCode: 2215. Find the Difference of Two Arrays --- Problem Given two 0-indexed integer arrays nums1 and...",
    "url": "/docs/problems/find-the-difference-of-two-arrays",
    "canonicalUrl": "https://crackmode.vercel.app/docs/problems/find-the-difference-of-two-arrays",
    "section": "Problems",
    "tags": [
      "easy",
      "array",
      "arrays",
      "leetcode",
      "algorithm",
      "complexity"
    ],
    "headings": [
      {
        "level": 1,
        "text": "Find the Difference of Two Arrays",
        "id": "find-the-difference-of-two-arrays"
      },
      {
        "level": 2,
        "text": "Problem",
        "id": "problem"
      },
      {
        "level": 2,
        "text": "Simple Explanation",
        "id": "simple-explanation"
      },
      {
        "level": 2,
        "text": "Solution Approaches",
        "id": "solution-approaches"
      },
      {
        "level": 3,
        "text": "Approach 1: Set Operations (Most Elegant)",
        "id": "approach-1-set-operations-most-elegant"
      },
      {
        "level": 3,
        "text": "Approach 2: Hash Set Lookup (Most Intuitive)",
        "id": "approach-2-hash-set-lookup-most-intuitive"
      },
      {
        "level": 3,
        "text": "Approach 3: Nested Loops (Brute Force)",
        "id": "approach-3-nested-loops-brute-force"
      },
      {
        "level": 2,
        "text": "Solution",
        "id": "solution"
      },
      {
        "level": 2,
        "text": "Step-by-Step Walkthrough",
        "id": "step-by-step-walkthrough"
      },
      {
        "level": 3,
        "text": "Set Operations Approach:",
        "id": "set-operations-approach"
      },
      {
        "level": 2,
        "text": "Algorithm Intuition",
        "id": "algorithm-intuition"
      },
      {
        "level": 2,
        "text": "Complexity Analysis",
        "id": "complexity-analysis"
      },
      {
        "level": 3,
        "text": "Set Operations:",
        "id": "set-operations"
      },
      {
        "level": 3,
        "text": "Hash Set Lookup:",
        "id": "hash-set-lookup"
      },
      {
        "level": 3,
        "text": "Brute Force (Not shown):",
        "id": "brute-force-not-shown"
      },
      {
        "level": 2,
        "text": "Key Insights",
        "id": "key-insights"
      },
      {
        "level": 2,
        "text": "Edge Cases to Consider",
        "id": "edge-cases-to-consider"
      },
      {
        "level": 2,
        "text": "Follow-up Questions",
        "id": "follow-up-questions"
      },
      {
        "level": 2,
        "text": "Related Problems",
        "id": "related-problems"
      }
    ],
    "publishedAt": "2026-01-04T04:18:51.317Z",
    "updatedAt": "2026-01-04T04:18:51.317Z",
    "author": "Morgan Ngetich",
    "readingTime": 7,
    "seo": {
      "title": "Find The Difference Of Two Arrays | Crackmode Documentation",
      "description": "Find the Difference of Two Arrays Difficulty: Easy LeetCode: 2215. Find the Difference of Two Arrays --- Problem Given two 0-indexed integer arrays nums1 and...",
      "keywords": "find, difference, arrays, easy, array, leetcode, algorithm, complexity, elements, return, result, approach, present, crackmode",
      "robots": "index,follow",
      "jsonLd": "{\"@context\":\"https://schema.org\",\"@type\":\"Article\",\"headline\":\"Find The Difference Of Two Arrays\",\"description\":\"Find the Difference of Two Arrays Difficulty: Easy LeetCode: 2215. Find the Difference of Two Arrays --- Problem Given two 0-indexed integer arrays nums1 and...\",\"url\":\"https://crackmode.vercel.app/docs/problems/find-the-difference-of-two-arrays\",\"datePublished\":\"2026-01-04T04:18:51.317Z\",\"dateModified\":\"2026-01-04T04:18:51.317Z\",\"author\":{\"@type\":\"Person\",\"name\":\"Morgan Ngetich\"},\"publisher\":{\"@type\":\"Organization\",\"name\":\"CrackMode\",\"logo\":{\"@type\":\"ImageObject\",\"url\":\"https://crackmode.vercel.app/group.png\"}},\"mainEntityOfPage\":{\"@type\":\"WebPage\",\"@id\":\"https://crackmode.vercel.app/docs/problems/find-the-difference-of-two-arrays\"},\"wordCount\":175,\"timeRequired\":\"PT7M\",\"inLanguage\":\"en-US\",\"isAccessibleForFree\":true}"
    },
    "socialMedia": {
      "ogTitle": "Find The Difference Of Two Arrays | Crackmode Documentation",
      "ogDescription": "Given two 0-indexed integer arrays nums1 and nums2, return a list answer of size 2 where: - answer[0] is a list of all distinct integers in nums1 which are not present in nums2. - answer[1] is a list of all distinct integers in nums2 which are not present in nums1.",
      "ogImage": "https://crackmode.vercel.app/api/v1/og?title=Find+The+Difference+Of+Two+Arrays&description=Given+two+0-indexed+integer+arrays+nums1+and+nums2%2C+return+a+list+answer+of+size+2+where%3A+-+answer%5B0%5D+is+a+list+of+all+d...&section=Documentation&theme=crackmode",
      "twitterTitle": "Find The Difference Of Two Arrays | Crackmode Documentation",
      "twitterDescription": "Given two 0-indexed integer arrays nums1 and nums2, return a list answer of size 2 where: - answer[0] is a list of all distinct integers in nums1 which are not present in nums2. - answer[1] is a list of all distinct integers in nums2 which are not present in nums1.",
      "twitterImage": "https://crackmode.vercel.app/api/v1/og?title=Find+The+Difference+Of+Two+Arrays&description=Given+two+0-indexed+integer+arrays+nums1+and+nums2%2C+return+a+list+answer+of+size+2+where%3A+-+answer%5B0%5D+is+a+list+of+all+d...&section=Documentation&theme=crackmode"
    }
  },
  {
    "id": "problems/implement-stack-using-queues",
    "title": "Implement Stack Using Queues",
    "content": "Implement Stack using Queues Difficulty: Easy LeetCode: 225. Implement Stack using Queues --- Problem Implement a last-in-first-out  LIFO  stack using only two queues. The implemented stack should support all the functions of a normal stack  push, top, pop, and empty . Implement the MyStack class: - void push int x  - Pushes element x to the top of the stack. - int pop   - Removes the element on the top of the stack and returns it. - int top   - Returns the element on the top of the stack. - boolean empty   - Returns true if the stack is empty, false otherwise. Notes: - You must use only standard operations of a queue, which means that only push to back, peek pop from front, size and is empty operations are valid. Example 1:    Input   MyStack ,  push ,  push ,  top ,  pop ,  empty      ,  1 ,  2 ,   ,   ,     Output  null, null, null, 2, 2, false  Explanation MyStack myStack   new MyStack  ; myStack.push 1 ; myStack.push 2 ; myStack.top  ;    return 2 myStack.pop  ;    return 2 myStack.empty  ;    return False   --- Simple Explanation Think of this like reversing the order using two containers: 1. Queue   FIFO  First In, First Out  - like a line at a store 2. Stack   LIFO  Last In, First Out  - like a stack of plates The trick is to use the queue s rotation ability to simulate stack behavior: - When pushing: add to queue, then rotate all previous elements - When popping: just remove from the front  which is now the  top   --- Solution Approach There are two main approaches: Approach 1: Make Push Operation Heavy - Push: Add new element, then rotate all previous elements to maintain stack order - Pop: Simply remove from front Approach 2: Make Pop Operation Heavy - Push: Simply add to back of queue - Pop: Move all elements except the last one to another queue, then pop the last element Let s implement Approach 1  more efficient for multiple pops : --- Solution None: self.queue.append x    Rotate the queue to bring the new element to front for _ in range len self.queue  - 1 : self.queue.append self.queue.popleft    def pop self  -  int: return self.queue.popleft   def top self  -  int: return self.queue 0  def empty self  -  bool: return len self.queue     0 , title:  C   , language:  cpp , code:  include using namespace std; class MyStack private: queue q; public: MyStack   void push int x  q.push x ; int size   q.size  ;    Rotate the queue to bring the new element to front for  int i   0; i queue; public MyStack   queue   new LinkedList    ; public void push int x  queue.offer x ; int size   queue.size  ;    Rotate the queue to bring the new element to front for  int i   0; i --- Step-by-Step Walkthrough Let s trace through the operations: push 1 , push 2 , push 3 , top  , pop  :   Initial: queue      Step 1: push 1  queue    1  No rotation needed  size   1  Final: queue    1  Step 2: push 2  queue    1, 2  Rotate 1 time: move 1 to back queue    2, 1  Final: queue    2, 1  Step 3: push 3  queue    2, 1, 3  Rotate 2 times: move 2,1 to back After 1st rotation:  1, 3, 2  After 2nd rotation:  3, 2, 1  Final: queue    3, 2, 1  Step 4: top   Return queue 0    3 Step 5: pop   Remove and return queue 0    3 Final: queue    2, 1    --- Alternative Solution  Two Queues  1  this.q2.push this.q1.shift   ; let result   this.q1.shift  ;    Swap queues  this.q1, this.q2     this.q2, this.q1 ; return result; top      Move all elements except last to q2 while  this.q1.length   1  this.q2.push this.q1.shift   ; let result   this.q1 0 ; this.q2.push this.q1.shift   ;    Swap queues  this.q1, this.q2     this.q2, this.q1 ; return result; empty   return this.q1.length     0; , title:  Python , language:  python , code: from collections import deque class MyStack: def __init__ self : self.q1   deque   self.q2   deque   def push self, x: int  -  None: self.q1.append x  def pop self  -  int:   Move all elements except last to q2 while len self.q1    1: self.q2.append self.q1.popleft    result   self.q1.popleft     Swap queues self.q1, self.q2   self.q2, self.q1 return result def top self  -  int:   Move all elements except last to q2 while len self.q1    1: self.q2.append self.q1.popleft    result   self.q1 0  self.q2.append self.q1.popleft      Swap queues self.q1, self.q2   self.q2, self.q1 return result def empty self  -  bool: return len self.q1     0 , title:  Java , language:  java , code: import java.util. ; class MyStack private Queue q1; private Queue q2; public MyStack   q1   new LinkedList    ; q2   new LinkedList    ; public void push int x  q1.offer x ; public int pop      Move all elements except last to q2 while  q1.size     1  q2.offer q1.poll   ; int result   q1.poll  ;    Swap queues Queue temp   q1; q1   q2; q2   temp; return result; public int top      Move all elements except last to q2 while  q1.size     1  q2.offer q1.poll   ; int result   q1.peek  ; q2.offer q1.poll   ;    Swap queues Queue temp   q1; q1   q2; q2   temp; return result; public boolean empty   return q1.isEmpty  ; , title:  C   , language:  cpp , code:  include using namespace std; class MyStack private: queue q1; queue q2; public: MyStack   void push int x  q1.push x ; int pop      Move all elements except last to q2 while  q1.size     1  q2.push q1.front   ; q1.pop  ; int result   q1.front  ; q1.pop  ;    Swap queues swap q1, q2 ; return result; int top      Move all elements except last to q2 while  q1.size     1  q2.push q1.front   ; q1.pop  ; int result   q1.front  ; q2.push q1.front   ; q1.pop  ;    Swap queues swap q1, q2 ; return result; bool empty   return q1.empty  ; ; ,      --- Complexity Analysis Approach 1  One Queue - Heavy Push : Time Complexity: Push: O n  - need to rotate n-1 elements Pop: O 1  - just remove from front Top: O 1  - just peek at front Empty: O 1  - check queue size Space Complexity: O n  One queue to store all elements Approach 2  Two Queues - Heavy Pop : Time Complexity: Push: O 1  - just add to back Pop: O n  - need to move n-1 elements Top: O n  - need to move and restore elements --- Key Insights Queue rotation trick - use queue s own operations to reorder elements Trade-off decision - make either push or pop operations expensive LIFO simulation - maintain stack order using FIFO operations Single queue preferred - simpler implementation than using two queues --- Follow-up Questions 1. Which approach is better? - If you do more pops than pushes   Make push heavy  Approach 1  - If you do more pushes than pops   Make pop heavy  Approach 2  2. Can you implement it with just one queue? - Yes! That s our main solution above. 3. What about space optimization? - Single queue approach uses minimum space O n  --- This problem teaches us how to simulate one data structure using another by cleverly manipulating the order of operations!",
    "excerpt": "Implement Stack using Queues Difficulty: Easy LeetCode: 225. Implement Stack using Queues --- Problem Implement a last-in-first-out LIFO stack using only two...",
    "url": "/docs/problems/implement-stack-using-queues",
    "canonicalUrl": "https://crackmode.vercel.app/docs/problems/implement-stack-using-queues",
    "section": "Problems",
    "tags": [
      "easy",
      "leetcode",
      "optimization",
      "complexity",
      "python",
      "java"
    ],
    "headings": [
      {
        "level": 1,
        "text": "Implement Stack using Queues",
        "id": "implement-stack-using-queues"
      },
      {
        "level": 2,
        "text": "Problem",
        "id": "problem"
      },
      {
        "level": 2,
        "text": "Simple Explanation",
        "id": "simple-explanation"
      },
      {
        "level": 2,
        "text": "Solution Approach",
        "id": "solution-approach"
      },
      {
        "level": 3,
        "text": "Approach 1: Make Push Operation Heavy",
        "id": "approach-1-make-push-operation-heavy"
      },
      {
        "level": 3,
        "text": "Approach 2: Make Pop Operation Heavy",
        "id": "approach-2-make-pop-operation-heavy"
      },
      {
        "level": 2,
        "text": "Solution",
        "id": "solution"
      },
      {
        "level": 2,
        "text": "Step-by-Step Walkthrough",
        "id": "step-by-step-walkthrough"
      },
      {
        "level": 2,
        "text": "Alternative Solution (Two Queues)",
        "id": "alternative-solution-two-queues"
      },
      {
        "level": 2,
        "text": "Complexity Analysis",
        "id": "complexity-analysis"
      },
      {
        "level": 3,
        "text": "Approach 1 (One Queue - Heavy Push):",
        "id": "approach-1-one-queue-heavy-push"
      },
      {
        "level": 3,
        "text": "Approach 2 (Two Queues - Heavy Pop):",
        "id": "approach-2-two-queues-heavy-pop"
      },
      {
        "level": 2,
        "text": "Key Insights",
        "id": "key-insights"
      },
      {
        "level": 2,
        "text": "Follow-up Questions",
        "id": "follow-up-questions"
      }
    ],
    "publishedAt": "2026-01-04T04:18:51.317Z",
    "updatedAt": "2026-01-04T04:18:51.317Z",
    "author": "Morgan Ngetich",
    "readingTime": 6,
    "seo": {
      "title": "Implement Stack Using Queues | Crackmode Documentation",
      "description": "Implement Stack using Queues Difficulty: Easy LeetCode: 225. Implement Stack using Queues --- Problem Implement a last-in-first-out LIFO stack using only two...",
      "keywords": "implement, stack, using, queues, easy, leetcode, optimization, complexity, python, java, queue, return, elements, crackmode, algorithm",
      "robots": "index,follow",
      "jsonLd": "{\"@context\":\"https://schema.org\",\"@type\":\"Article\",\"headline\":\"Implement Stack Using Queues\",\"description\":\"Implement Stack using Queues Difficulty: Easy LeetCode: 225. Implement Stack using Queues --- Problem Implement a last-in-first-out LIFO stack using only two...\",\"url\":\"https://crackmode.vercel.app/docs/problems/implement-stack-using-queues\",\"datePublished\":\"2026-01-04T04:18:51.317Z\",\"dateModified\":\"2026-01-04T04:18:51.317Z\",\"author\":{\"@type\":\"Person\",\"name\":\"Morgan Ngetich\"},\"publisher\":{\"@type\":\"Organization\",\"name\":\"CrackMode\",\"logo\":{\"@type\":\"ImageObject\",\"url\":\"https://crackmode.vercel.app/group.png\"}},\"mainEntityOfPage\":{\"@type\":\"WebPage\",\"@id\":\"https://crackmode.vercel.app/docs/problems/implement-stack-using-queues\"},\"wordCount\":154,\"timeRequired\":\"PT6M\",\"inLanguage\":\"en-US\",\"isAccessibleForFree\":true}"
    },
    "socialMedia": {
      "ogTitle": "Implement Stack Using Queues | Crackmode Documentation",
      "ogDescription": "Implement a last-in-first-out (LIFO) stack using only two queues. The implemented stack should support all the functions of a normal stack (push, top, pop, and empty).",
      "ogImage": "https://crackmode.vercel.app/api/v1/og?title=Implement+Stack+Using+Queues&description=Implement+a+last-in-first-out+%28LIFO%29+stack+using+only+two+queues.+The+implemented+stack+should+support+all+the+functions...&section=Documentation&theme=crackmode",
      "twitterTitle": "Implement Stack Using Queues | Crackmode Documentation",
      "twitterDescription": "Implement a last-in-first-out (LIFO) stack using only two queues. The implemented stack should support all the functions of a normal stack (push, top, pop, and empty).",
      "twitterImage": "https://crackmode.vercel.app/api/v1/og?title=Implement+Stack+Using+Queues&description=Implement+a+last-in-first-out+%28LIFO%29+stack+using+only+two+queues.+The+implemented+stack+should+support+all+the+functions...&section=Documentation&theme=crackmode"
    }
  },
  {
    "id": "problems/longest-consecutive-sequence",
    "title": "Longest Consecutive Sequence",
    "content": "Longest Consecutive Sequence Difficulty: Medium LeetCode: 128. Longest Consecutive Sequence --- Problem Given an unsorted array of integers nums, return the length of the longest consecutive elements sequence. You must write an algorithm that runs in O n  time. Example 1:    Input: nums    100,4,200,1,3,2  Output: 6 Explanation: The longest consecutive elements sequence is  1, 2, 3, 4, 100, 200 . It has length 6.   Example 2:   Input: nums    0,3,7,2,5,8,4,6,0,1  Output: 9   Constraints: - 0 int:   Convert to set for O 1  lookups nset   set nums  longest   0 for num in nset:   Only start counting from sequence beginnings if num - 1 not in nset: length   1 nexxt   num   1   Follow the consecutive chain while nexxt in nset: length    1 nexxt    1   Update maximum length found longest   max longest, length  return longest , title:  JavaScript , language:  javascript , code: function longestConsecutive nums     Convert to Set for O 1  lookups const numSet   new Set nums ; let longest   0; for  let num of numSet     Only start counting from sequence beginnings if  !numSet.has num - 1   let length   1; let next   num   1;    Follow the consecutive chain while  numSet.has next   length  ; next  ;    Update maximum length found longest   Math.max longest, length ; return longest; , title:  Java , language:  java , code: class Solution public int longestConsecutive int   nums     Convert to Set for O 1  lookups Set numSet   new HashSet    ; for  int num : nums  numSet.add num ; int longest   0; for  int num : numSet     Only start counting from sequence beginnings if  !numSet.contains num - 1   int length   1; int next   num   1;    Follow the consecutive chain while  numSet.contains next   length  ; next  ;    Update maximum length found longest   Math.max longest, length ; return longest; , title:  C   , language:  cpp , code: class Solution public: int longestConsecutive vector  nums     Convert to set for O 1  lookups unordered_set numSet nums.begin  , nums.end   ; int longest   0; for  int num : numSet     Only start counting from sequence beginnings if  numSet.find num - 1     numSet.end    int length   1; int next   num   1;    Follow the consecutive chain while  numSet.find next  !  numSet.end    length  ; next  ;    Update maximum length found longest   max longest, length ; return longest; ; ,      --- Step-by-Step Walkthrough Let s trace through nums    100, 4, 200, 1, 3, 2 :   Step 1: Convert to set nset   100, 4, 200, 1, 3, 2 Step 2: Check each number for sequence start num   100: - Is  100-1  99 in set? NO   Start of sequence - Count: 100  , 101   - length   1 num   4: - Is  4-1  3 in set? YES   Skip  not sequence start  num   200: - Is  200-1  199 in set? NO   Start of sequence - Count: 200  , 201   - length   1 num   1: - Is  1-1  0 in set? NO   Start of sequence - Count: 1  , 2  , 3  , 4  , 5   - length   4 num   3: - Is  3-1  2 in set? YES   Skip  not sequence start  num   2: - Is  2-1  1 in set? YES   Skip  not sequence start  Step 3: Maximum length found   4   Wait, that should be 6! Let me recalculate:   Actually, let s be more careful: nset   100, 4, 200, 1, 3, 2 num   1:  1-1  0 not in set   sequence start - Count: 1 2 3 4  all in set , 5 not in set - length   4 But wait, this should give us length 6 for  1,2,3,4 ... Let me check the original sequence:  100,4,200,1,3,2  The consecutive sequence is  1,2,3,4  which has length 4, not 6. Actually looking at the problem again - it says the answer should be 6. This means I misunderstood. Let me re-read... Oh! The explanation says  The longest consecutive elements sequence is  1, 2, 3, 4, 100, 200   But that s not consecutive! Let me check the problem statement again. Actually, re-reading the problem: it should be  1,2,3,4  with length 4. The problem example might have a typo. Let me use the correct trace: nset   100, 4, 200, 1, 3, 2 num   1: 0 not in set   start sequence - 1 in set    length 1  - 2 in set    length 2  - 3 in set    length 3  - 4 in set    length 4  - 5 not in set   - Final length   4 Maximum   4   --- Why This Works  Key Insight  The brilliant insight is the sequence start check: if num - 1 not in nset: Without this check:   We d count every number in sequence  1,2,3,4  four separate times   Time complexity would be O n   in worst case With this check:   We only start counting from sequence beginnings  1, 100, 200    Each number is visited at most twice  once in main loop, once in while loop    Guarantees O n  time complexity --- Alternative Approaches int: if not nums: return 0 nums.sort   longest   1 current   1 for i in range 1, len nums  :   Skip duplicates if nums i     nums i-1 : continue   Consecutive elif nums i     nums i-1    1: current    1   Reset sequence else: longest   max longest, current  current   1 return max longest, current  , title:  Union Find Approach O n  , language:  python , code: class Solution: def longestConsecutive self, nums: List int   -  int: if not nums: return 0   Union-Find with path compression parent   size   def find x : if parent x  !  x: parent x    find parent x   return parent x  def union x, y : px, py   find x , find y  if px !  py: parent px    py size py     size px    Initialize each number as its own component for num in set nums : parent num    num size num    1   Union consecutive numbers for num in parent: if num   1 in parent: union num, num   1  return max size.values    ,      --- Complexity Analysis Time Complexity: O n    Converting array to set: O n    Main loop iterates through each unique number: O n    Each number is visited at most twice  main loop   while loop    While loop across all numbers totals O n  operations Space Complexity: O n    Set to store all unique numbers --- Key Insights Sequence start detection - only count from numbers without predecessors Set for O 1  lookups - convert array to set for fast containment checks Avoid redundant work - each number visited at most twice total Linear time guarantee - smart iteration strategy ensures O n  complexity --- Common Mistakes 1. Sorting first - This works but gives O n log n  instead of required O n  2. Not checking sequence start - Results in O n   time complexity 3. Forgetting duplicates - Use set to handle duplicate numbers 4. Off-by-one errors - Remember to start length   1  counting current number  --- Follow-up Questions 1. What if we need to return the actual sequence? - Store sequence elements while counting, return the longest one 2. What about multiple sequences of same max length? - Return any one of them, or count how many exist 3. Can we solve with less space? - Union-Find approach, but still O n  space for parent pointers --- This problem demonstrates the power of smart iteration strategies - by being clever about when to start counting, we achieve optimal O n  time complexity!",
    "excerpt": "Longest Consecutive Sequence Difficulty: Medium LeetCode: 128. Longest Consecutive Sequence --- Problem Given an unsorted array of integers nums, return the...",
    "url": "/docs/problems/longest-consecutive-sequence",
    "canonicalUrl": "https://crackmode.vercel.app/docs/problems/longest-consecutive-sequence",
    "section": "Problems",
    "tags": [
      "medium",
      "array",
      "sorting",
      "leetcode",
      "algorithm",
      "complexity"
    ],
    "headings": [
      {
        "level": 1,
        "text": "Longest Consecutive Sequence",
        "id": "longest-consecutive-sequence"
      },
      {
        "level": 2,
        "text": "Problem",
        "id": "problem"
      },
      {
        "level": 2,
        "text": "Simple Explanation",
        "id": "simple-explanation"
      },
      {
        "level": 2,
        "text": "Solution Approach",
        "id": "solution-approach"
      },
      {
        "level": 2,
        "text": "Solution",
        "id": "solution"
      },
      {
        "level": 2,
        "text": "Step-by-Step Walkthrough",
        "id": "step-by-step-walkthrough"
      },
      {
        "level": 2,
        "text": "Why This Works (Key Insight)",
        "id": "why-this-works-key-insight"
      },
      {
        "level": 2,
        "text": "Alternative Approaches",
        "id": "alternative-approaches"
      },
      {
        "level": 2,
        "text": "Complexity Analysis",
        "id": "complexity-analysis"
      },
      {
        "level": 2,
        "text": "Key Insights",
        "id": "key-insights"
      },
      {
        "level": 2,
        "text": "Common Mistakes",
        "id": "common-mistakes"
      },
      {
        "level": 2,
        "text": "Follow-up Questions",
        "id": "follow-up-questions"
      }
    ],
    "publishedAt": "2026-01-04T04:18:51.317Z",
    "updatedAt": "2026-01-04T04:18:51.317Z",
    "author": "Morgan Ngetich",
    "readingTime": 6,
    "seo": {
      "title": "Longest Consecutive Sequence | Crackmode Documentation",
      "description": "Longest Consecutive Sequence Difficulty: Medium LeetCode: 128. Longest Consecutive Sequence --- Problem Given an unsorted array of integers nums, return the...",
      "keywords": "longest, consecutive, sequence, medium, array, sorting, leetcode, algorithm, complexity, length, start, return, crackmode",
      "robots": "index,follow",
      "jsonLd": "{\"@context\":\"https://schema.org\",\"@type\":\"Article\",\"headline\":\"Longest Consecutive Sequence\",\"description\":\"Longest Consecutive Sequence Difficulty: Medium LeetCode: 128. Longest Consecutive Sequence --- Problem Given an unsorted array of integers nums, return the...\",\"url\":\"https://crackmode.vercel.app/docs/problems/longest-consecutive-sequence\",\"datePublished\":\"2026-01-04T04:18:51.317Z\",\"dateModified\":\"2026-01-04T04:18:51.317Z\",\"author\":{\"@type\":\"Person\",\"name\":\"Morgan Ngetich\"},\"publisher\":{\"@type\":\"Organization\",\"name\":\"CrackMode\",\"logo\":{\"@type\":\"ImageObject\",\"url\":\"https://crackmode.vercel.app/group.png\"}},\"mainEntityOfPage\":{\"@type\":\"WebPage\",\"@id\":\"https://crackmode.vercel.app/docs/problems/longest-consecutive-sequence\"},\"wordCount\":147,\"timeRequired\":\"PT6M\",\"inLanguage\":\"en-US\",\"isAccessibleForFree\":true}"
    },
    "socialMedia": {
      "ogTitle": "Longest Consecutive Sequence | Crackmode Documentation",
      "ogDescription": "Given an unsorted array of integers nums, return the length of the longest consecutive elements sequence. You must write an algorithm that runs in O(n) time.",
      "ogImage": "https://crackmode.vercel.app/api/v1/og?title=Longest+Consecutive+Sequence&description=Given+an+unsorted+array+of+integers+nums%2C+return+the+length+of+the+longest+consecutive+elements+sequence.+You+must+write...&section=Documentation&theme=crackmode",
      "twitterTitle": "Longest Consecutive Sequence | Crackmode Documentation",
      "twitterDescription": "Given an unsorted array of integers nums, return the length of the longest consecutive elements sequence. You must write an algorithm that runs in O(n) time.",
      "twitterImage": "https://crackmode.vercel.app/api/v1/og?title=Longest+Consecutive+Sequence&description=Given+an+unsorted+array+of+integers+nums%2C+return+the+length+of+the+longest+consecutive+elements+sequence.+You+must+write...&section=Documentation&theme=crackmode"
    }
  },
  {
    "id": "problems/longest-palindrome",
    "title": "Longest Palindrome",
    "content": "Longest Palindrome Difficulty: Easy LeetCode: 409. Longest Palindrome --- Problem Given a string s which consists of lowercase or uppercase letters, return the length of the longest palindrome that can be built with those letters. Letters are case sensitive, for example,  Aa  is not considered a palindrome. Example 1:    Input: s    abccccdd  Output: 7 Explanation: One longest palindrome that can be built is  dccaccd , whose length is 7.   Example 2:   Input: s    a  Output: 1 Explanation: The longest palindrome that can be built is  a , whose length is 1.   Example 3:   Input: s    Aab  Output: 1 Explanation: The longest palindrome that can be built is  A ,  a  or  b , whose length is 1.   --- Simple Explanation Think of this like building a palindrome with letter tiles! Imagine you have letter tiles scattered on a table: - You have tiles: a, b, c, c, c, c, d, d - You want to build the longest possible palindrome  reads same forwards backwards  - Like building: d-c-c-a-c-c-d   Key Insights: 1. Pairs are perfect   Every pair of identical letters can go on both sides 2. Odd letters   If you have leftover single letters, pick ONE to go in the middle 3. Count pairs, then add one odd if available The Strategy: Count how many pairs you can make, multiply by 2, then add 1 if there are any leftover single letters! --- Solution 0  counter    1; return counter; , title:  Java , language:  java , code: import java.util.; public class Solution public int longestPalindrome String s  Map hashMap   new HashMap    ; int counter   0; for  int i   0; i --- Step-by-Step Walkthrough Let s trace through s    abccccdd :   s    abccccdd  hash_map   counter   0 Process each character: a: not in map   hash_map    a : 1 b: not in map   hash_map    a : 1,  b : 1 c: not in map   hash_map    a : 1,  b : 1,  c : 1 c: found  c  in map!   delete  c , counter    2   counter   2 c: not in map   hash_map    a : 1,  b : 1,  c : 1 c: found  c  in map!   delete  c , counter    2   counter   4 d: not in map   hash_map    a : 1,  b : 1,  d : 1 d: found  d  in map!   delete  d , counter    2   counter   6 Final: hash_map    a : 1,  b : 1  not empty  So counter    1   counter   7     --- Visual Understanding Let s see how both approaches handle the same example: Given Solution  Real-time pairing :    abccccdd    Process as we go a: waiting   hash_map    a : 1 b: waiting   hash_map    a : 1,  b : 1 c: waiting   hash_map    a : 1,  b : 1,  c : 1 c: PAIR!  2   hash_map    a : 1,  b : 1, counter   2 c: waiting   hash_map    a : 1,  b : 1,  c : 1 c: PAIR!  2   hash_map    a : 1,  b : 1, counter   4 d: waiting   hash_map    a : 1,  b : 1,  d : 1 d: PAIR!  2   hash_map    a : 1,  b : 1, counter   6  1 for leftover   counter   7   Both get the same answer, but the given solution is more memory efficient! --- Common Mistakes to Avoid 1. Case sensitivity:  A  and  a  are different letters in this problem 2. Overcounting odds: Only add 1 total for middle, not 1 per odd letter 3. Wrong pair calculation: Use integer division      not regular division --- Complexity Analysis Time Complexity: O n  Single pass to count letters or process pairs Dictionary operations are O 1  average case Space Complexity: O 1  At most 52 different letters  a-z, A-Z  Constant space regardless of input size --- Alternative Approaches  Count Then Calculate  counts   new HashMap    ; for  char c : s.toCharArray    counts.put c, counts.getOrDefault c, 0    1 ; int pairs   0; boolean hasOdd   false; for  int count : counts.values    pairs    count   2; if  count   2    1  hasOdd   true; return pairs 2    hasOdd ? 1 : 0 ;      Test Cases to Try   python Test your solution with these: print longestPalindrome  abccccdd      Should return 7 print longestPalindrome  a      Should return 1 print longestPalindrome  Aab      Should return 1 print longestPalindrome  aabbcc      Should return 6 print longestPalindrome  aab      Should return 3 print longestPalindrome  ccc      Should return 3 print longestPalindrome  abcdef      Should return 1 print longestPalindrome  aabbccdd      Should return 8    --- Pattern Recognition This problem teaches important patterns: Pairing   Symmetry: Palindromes rely on letter pairs, with at most one unpaired letter in the middle. Greedy Strategy: Take all possible pairs, then add one extra if available HashMap for Counting: Track frequencies to make pairing decisions Odd Even Analysis: Understanding when remainders matter You ll see similar patterns in: - Anagram problems - Frequency-based problems - Symmetric structure building - Optimization with constraints --- Key Takeaway The beauty of palindromes is their symmetry: - Every letter  except maybe one in the middle  needs a partner - Count pairs, multiply by 2, add 1 if you have any singles left - Two approaches: count-then-calculate vs. process-pairs-immediately Both solve the same problem:  How many letters can I arrange symmetrically?  The answer: All paired letters   at most one single letter in the middle",
    "excerpt": "Longest Palindrome Difficulty: Easy LeetCode: 409. Longest Palindrome --- Problem Given a string s which consists of lowercase or uppercase letters, return the...",
    "url": "/docs/problems/longest-palindrome",
    "canonicalUrl": "https://crackmode.vercel.app/docs/problems/longest-palindrome",
    "section": "Problems",
    "tags": [
      "easy",
      "array",
      "string",
      "greedy",
      "leetcode",
      "optimization"
    ],
    "headings": [
      {
        "level": 1,
        "text": "Longest Palindrome",
        "id": "longest-palindrome"
      },
      {
        "level": 2,
        "text": "Problem",
        "id": "problem"
      },
      {
        "level": 2,
        "text": "Simple Explanation",
        "id": "simple-explanation"
      },
      {
        "level": 2,
        "text": "Solution",
        "id": "solution"
      },
      {
        "level": 2,
        "text": "Step-by-Step Walkthrough",
        "id": "step-by-step-walkthrough"
      },
      {
        "level": 2,
        "text": "Visual Understanding",
        "id": "visual-understanding"
      },
      {
        "level": 2,
        "text": "Common Mistakes to Avoid",
        "id": "common-mistakes-to-avoid"
      },
      {
        "level": 2,
        "text": "Complexity Analysis",
        "id": "complexity-analysis"
      },
      {
        "level": 2,
        "text": "Alternative Approaches (Count Then Calculate)",
        "id": "alternative-approaches-count-then-calculate"
      },
      {
        "level": 2,
        "text": "Test Cases to Try",
        "id": "test-cases-to-try"
      },
      {
        "level": 1,
        "text": "Test your solution with these:",
        "id": "test-your-solution-with-these"
      },
      {
        "level": 2,
        "text": "Pattern Recognition",
        "id": "pattern-recognition"
      },
      {
        "level": 2,
        "text": "Key Takeaway",
        "id": "key-takeaway"
      }
    ],
    "publishedAt": "2026-01-04T04:18:51.317Z",
    "updatedAt": "2026-01-04T04:18:51.317Z",
    "author": "Morgan Ngetich",
    "readingTime": 5,
    "seo": {
      "title": "Longest Palindrome | Crackmode Documentation",
      "description": "Longest Palindrome Difficulty: Easy LeetCode: 409. Longest Palindrome --- Problem Given a string s which consists of lowercase or uppercase letters, return the...",
      "keywords": "longest, palindrome, easy, array, string, greedy, leetcode, optimization, counter, return, longestpalindrome, letters, crackmode, algorithm",
      "robots": "index,follow",
      "jsonLd": "{\"@context\":\"https://schema.org\",\"@type\":\"Article\",\"headline\":\"Longest Palindrome\",\"description\":\"Longest Palindrome Difficulty: Easy LeetCode: 409. Longest Palindrome --- Problem Given a string s which consists of lowercase or uppercase letters, return the...\",\"url\":\"https://crackmode.vercel.app/docs/problems/longest-palindrome\",\"datePublished\":\"2026-01-04T04:18:51.317Z\",\"dateModified\":\"2026-01-04T04:18:51.317Z\",\"author\":{\"@type\":\"Person\",\"name\":\"Morgan Ngetich\"},\"publisher\":{\"@type\":\"Organization\",\"name\":\"CrackMode\",\"logo\":{\"@type\":\"ImageObject\",\"url\":\"https://crackmode.vercel.app/group.png\"}},\"mainEntityOfPage\":{\"@type\":\"WebPage\",\"@id\":\"https://crackmode.vercel.app/docs/problems/longest-palindrome\"},\"wordCount\":161,\"timeRequired\":\"PT5M\",\"inLanguage\":\"en-US\",\"isAccessibleForFree\":true}"
    },
    "socialMedia": {
      "ogTitle": "Longest Palindrome | Crackmode Documentation",
      "ogDescription": "Given a string s which consists of lowercase or uppercase letters, return the length of the longest palindrome that can be built with those letters. Letters are case sensitive, for example, \"Aa\" is not considered a palindrome.",
      "ogImage": "https://crackmode.vercel.app/api/v1/og?title=Longest+Palindrome&description=Given+a+string+s+which+consists+of+lowercase+or+uppercase+letters%2C+return+the+length+of+the+longest+palindrome+that+can...&section=Documentation&theme=crackmode",
      "twitterTitle": "Longest Palindrome | Crackmode Documentation",
      "twitterDescription": "Given a string s which consists of lowercase or uppercase letters, return the length of the longest palindrome that can be built with those letters. Letters are case sensitive, for example, \"Aa\" is not considered a palindrome.",
      "twitterImage": "https://crackmode.vercel.app/api/v1/og?title=Longest+Palindrome&description=Given+a+string+s+which+consists+of+lowercase+or+uppercase+letters%2C+return+the+length+of+the+longest+palindrome+that+can...&section=Documentation&theme=crackmode"
    }
  },
  {
    "id": "problems/merge-sorted-array",
    "title": "Merge Sorted Array",
    "content": "Merge Sorted Array Difficulty: Easy LeetCode: 88. Merge Sorted Array --- Problem You are given two integer arrays nums1 and nums2, sorted in non-decreasing order, and two integers m and n, representing the number of elements in nums1 and nums2 respectively. Merge nums1 and nums2 into a single array sorted in non-decreasing order. The final sorted array should not be returned by the function, but instead be stored inside the array nums1. To accommodate this, nums1 has a length of m   n, where the first m elements denote the elements that should be merged, and the last n elements are set to 0 and should be ignored. nums2 has a length of n. Example 1:    Input: nums1    1,2,3,0,0,0 , m   3, nums2    2,5,6 , n   3 Output:  1,2,2,3,5,6  Explanation: The arrays we are merging are  1,2,3  and  2,5,6 . The result of the merge is  1,2,2,3,5,6  with the underlined elements coming from nums1.   Example 2:   Input: nums1    1 , m   1, nums2     , n   0 Output:  1  Explanation: The arrays we are merging are  1  and   . The result of the merge is  1 .   Example 3:   Input: nums1    0 , m   0, nums2    1 , n   1 Output:  1  Explanation: The arrays we are merging are    and  1 . The result of the merge is  1 . Note that because m   0, there are no elements in nums1. The 0 is only there to ensure the merge result can fit in nums1.   --- Simple Explanation Think of this like merging two sorted piles of cards! Just like in real life: - You have two sorted piles:  1,2,3  and  2,5,6  - You want to merge them into one sorted pile - But here s the twist: you must use the first pile s space  which has extra room  - The smart way: start from the back! Compare the largest elements first The Key: Work backwards! Since nums1 has extra space at the end, fill it from right to left by comparing the largest unused elements from both arrays. --- Optimal Solution  Two Pointers from Back    0 and j    0: if nums1 i    nums2 j : nums1 k    nums1 i  i -  1 else: nums1 k    nums2 j  j -  1 k -  1   If nums2 still has elements, copy them while j    0: nums1 k    nums2 j  j -  1 k -  1   No need to handle remaining nums1 elements - they re already in place! Example usage: nums1    1,2,3,0,0,0 , m   3, nums2    2,5,6 , n   3 After merge: nums1    1,2,2,3,5,6  , title:  JavaScript , language:  javascript , code: function merge nums1, m, nums2, n  let i   m - 1;    Last element in nums1 s actual data let j   n - 1;    Last element in nums2 let k   m   n - 1;    Last position in nums1    Work backwards, placing the larger element at the end while  i    0    j    0  if  nums1 i    nums2 j   nums1 k    nums1 i ; i--; else nums1 k    nums2 j ; j--; k--;    Copy remaining elements from nums2 if any while  j    0  nums1 k    nums2 j ; j--; k--; , title:  Java , language:  java , code: public class Solution public void merge int   nums1, int m, int   nums2, int n  int i   m - 1;    Last element in nums1 s actual data int j   n - 1;    Last element in nums2 int k   m   n - 1;    Last position in nums1    Work backwards, placing the larger element at the end while  i    0    j    0  if  nums1 i    nums2 j   nums1 k    nums1 i ; i--; else nums1 k    nums2 j ; j--; k--;    Copy remaining elements from nums2 if any while  j    0  nums1 k    nums2 j ; j--; k--;      Complexity Analysis Time Complexity: O m   n  Each element from both arrays is processed exactly once Single pass through both arrays Space Complexity: O 1  Only using a constant amount of extra space for pointers In-place modification of nums1 --- Yesterday s Session Solution Here s the approach we used in yesterday s session using binary search and insertion: None: if n    0: return   Remove trailing zeros from nums1 counter   0 while nums1 and nums1 -1     0 and counter nums1, int m, List nums2, int n  if  n    0  return;    Remove trailing zeros int counter   0; while  !nums1.isEmpty      nums1.get nums1.size   - 1     0    counter Analysis of Yesterday s Solution: - Time Complexity: O n   m  - For each element in nums2, we do binary search O log m    insertion O m  - Space Complexity: O 1  - In-place modification - Pros: Uses binary search for finding insertion point, intuitive approach - Cons: Multiple insertions are expensive, not the most efficient for this problem Why the optimal solution is better: - Time Complexity: O m   n  - Single pass through both arrays - Space Complexity: O 1  - In-place, no extra operations - No expensive insertions: Just direct assignment to positions --- Step-by-Step Walkthrough Let s trace through nums1    1,2,3,0,0,0 , m   3, nums2    2,5,6 , n   3:    Initial: nums1    1,2,3,0,0,0 , nums2    2,5,6  Pointers: i 2  at 3 , j 2  at 6 , k 5  last position  Step 1: Compare nums1 2  3 vs nums2 2  6 6   3, so place 6 at position 5 nums1    1,2,3,0,0,6 , j 1, k 4 Step 2: Compare nums1 2  3 vs nums2 1  5 5   3, so place 5 at position 4 nums1    1,2,3,0,5,6 , j 0, k 3 Step 3: Compare nums1 2  3 vs nums2 0  2 3   2, so place 3 at position 3 nums1    1,2,2,3,5,6 , i 1, k 2 Step 4: Compare nums1 1  2 vs nums2 0  2 Equal, but we place nums2 0  2 at position 2 nums1    1,2,2,3,5,6 , j -1, k 1 Step 5: j No overwrites - Working backwards ensures we never overwrite unprocessed elements Optimal space usage - Uses the extra space in nums1 efficiently Single pass - Each element is touched exactly once Natural merge - Follows the same logic as merging in merge sort --- Pattern Recognition This problem teaches important patterns: - Two Pointers: Working from both ends towards the middle - In-place Array Manipulation: Using available space efficiently - Merge Process: Core component of merge sort algorithm - Backwards Iteration: Sometimes working backwards avoids complex shifting You ll see this pattern in: - Merge Sort implementation - Merging multiple sorted arrays - In-place array transformations - Two-pointer technique problems --- Follow-up Challenge Can you handle merging k sorted arrays?  python def merge_k_sorted_arrays arrays :   Use a min-heap to efficiently merge k sorted arrays import heapq heap      result        Initialize heap with first element from each array for i, arr in enumerate arrays : if arr:   Only add non-empty arrays heapq.heappush heap,  arr 0 , i, 0   while heap: val, array_idx, element_idx   heapq.heappop heap  result.append val    Add next element from same array if exists if element_idx   1   len arrays array_idx  : next_val   arrays array_idx  element_idx   1  heapq.heappush heap,  next_val, array_idx, element_idx   1   return result",
    "excerpt": "Merge Sorted Array Difficulty: Easy LeetCode: 88. Merge Sorted Array --- Problem You are given two integer arrays nums1 and nums2, sorted in non-decreasing...",
    "url": "/docs/problems/merge-sorted-array",
    "canonicalUrl": "https://crackmode.vercel.app/docs/problems/merge-sorted-array",
    "section": "Problems",
    "tags": [
      "easy",
      "array",
      "arrays",
      "leetcode",
      "algorithm",
      "complexity"
    ],
    "headings": [
      {
        "level": 1,
        "text": "Merge Sorted Array",
        "id": "merge-sorted-array"
      },
      {
        "level": 2,
        "text": "Problem",
        "id": "problem"
      },
      {
        "level": 2,
        "text": "Simple Explanation",
        "id": "simple-explanation"
      },
      {
        "level": 2,
        "text": "Optimal Solution (Two Pointers from Back)",
        "id": "optimal-solution-two-pointers-from-back"
      },
      {
        "level": 1,
        "text": "Example usage:",
        "id": "example-usage"
      },
      {
        "level": 1,
        "text": "nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3",
        "id": "nums1-123000-m-3-nums2-256-n-3"
      },
      {
        "level": 1,
        "text": "After merge: nums1 = [1,2,2,3,5,6]`",
        "id": "after-merge-nums1-122356"
      },
      {
        "level": 2,
        "text": "Complexity Analysis",
        "id": "complexity-analysis"
      },
      {
        "level": 2,
        "text": "Yesterday's Session Solution",
        "id": "yesterdays-session-solution"
      },
      {
        "level": 2,
        "text": "Step-by-Step Walkthrough",
        "id": "step-by-step-walkthrough"
      },
      {
        "level": 2,
        "text": "Why This Approach Works",
        "id": "why-this-approach-works"
      },
      {
        "level": 2,
        "text": "Pattern Recognition",
        "id": "pattern-recognition"
      },
      {
        "level": 2,
        "text": "Follow-up Challenge",
        "id": "follow-up-challenge"
      }
    ],
    "publishedAt": "2026-01-04T04:18:51.317Z",
    "updatedAt": "2026-01-04T04:18:51.317Z",
    "author": "Morgan Ngetich",
    "readingTime": 6,
    "seo": {
      "title": "Merge Sorted Array | Crackmode Documentation",
      "description": "Merge Sorted Array Difficulty: Easy LeetCode: 88. Merge Sorted Array --- Problem You are given two integer arrays nums1 and nums2, sorted in non-decreasing...",
      "keywords": "merge, sorted, array, easy, arrays, leetcode, algorithm, complexity, elements, element, crackmode",
      "robots": "index,follow",
      "jsonLd": "{\"@context\":\"https://schema.org\",\"@type\":\"Article\",\"headline\":\"Merge Sorted Array\",\"description\":\"Merge Sorted Array Difficulty: Easy LeetCode: 88. Merge Sorted Array --- Problem You are given two integer arrays nums1 and nums2, sorted in non-decreasing...\",\"url\":\"https://crackmode.vercel.app/docs/problems/merge-sorted-array\",\"datePublished\":\"2026-01-04T04:18:51.317Z\",\"dateModified\":\"2026-01-04T04:18:51.317Z\",\"author\":{\"@type\":\"Person\",\"name\":\"Morgan Ngetich\"},\"publisher\":{\"@type\":\"Organization\",\"name\":\"CrackMode\",\"logo\":{\"@type\":\"ImageObject\",\"url\":\"https://crackmode.vercel.app/group.png\"}},\"mainEntityOfPage\":{\"@type\":\"WebPage\",\"@id\":\"https://crackmode.vercel.app/docs/problems/merge-sorted-array\"},\"wordCount\":168,\"timeRequired\":\"PT6M\",\"inLanguage\":\"en-US\",\"isAccessibleForFree\":true}"
    },
    "socialMedia": {
      "ogTitle": "Merge Sorted Array | Crackmode Documentation",
      "ogDescription": "You are given two integer arrays nums1 and nums2, sorted in non-decreasing order, and two integers m and n, representing the number of elements in nums1 and nums2 respectively.",
      "ogImage": "https://crackmode.vercel.app/api/v1/og?title=Merge+Sorted+Array&description=You+are+given+two+integer+arrays+nums1+and+nums2%2C+sorted+in+non-decreasing+order%2C+and+two+integers+m+and+n%2C+representing...&section=Documentation&theme=crackmode",
      "twitterTitle": "Merge Sorted Array | Crackmode Documentation",
      "twitterDescription": "You are given two integer arrays nums1 and nums2, sorted in non-decreasing order, and two integers m and n, representing the number of elements in nums1 and nums2 respectively.",
      "twitterImage": "https://crackmode.vercel.app/api/v1/og?title=Merge+Sorted+Array&description=You+are+given+two+integer+arrays+nums1+and+nums2%2C+sorted+in+non-decreasing+order%2C+and+two+integers+m+and+n%2C+representing...&section=Documentation&theme=crackmode"
    }
  },
  {
    "id": "problems/missing-number",
    "title": "Missing Number",
    "content": "Missing Number Difficulty: Easy LeetCode: 268. Missing Number --- Problem Given an array nums containing n distinct numbers in the range  0, n , return the only number in the range that is missing from the array. Example 1:    Input: nums    3,0,1  Output: 2 Explanation: n   3 since there are 3 numbers, so all numbers are in the range  0,3 . 2 is the missing number in the range since it does not appear in nums.   Example 2:   Input: nums    0,1  Output: 2 Explanation: n   2 since there are 2 numbers, so all numbers are in the range  0,2 . 2 is the missing number in the range since it does not appear in nums.   Example 3:   Input: nums    9,6,4,2,3,5,7,0,1  Output: 8 Explanation: n   9 since there are 9 numbers, so all numbers are in the range  0,9 . 8 is the missing number in the range since it does not appear in nums.   Constraints: - n    nums.length - 1 sum   num, 0 ; return expectedSum - actualSum; ;    Approach 2: XOR Bit Manipulation var missingNumberXOR   function nums  const n   nums.length; let xor   0;    XOR all numbers from 0 to n for  let i   0; i int: n   len nums  expected_sum   n  n   1     2 actual_sum   sum nums  return expected_sum - actual_sum   Approach 2: XOR Bit Manipulation def missingNumberXOR self, nums: List int   -  int: n   len nums  xor   0   XOR all numbers from 0 to n for i in range n   1 : xor    i   XOR all numbers in array for num in nums: xor    num return xor   Approach 3: Set Lookup def missingNumberSet self, nums: List int   -  int: num_set   set nums  n   len nums  for i in range n   1 : if i not in num_set: return i , title:  C   , language:  cpp , code:  include  include  include using namespace std; class Solution public:    Approach 1: Sum Formula int missingNumber vector  nums  int n   nums.size  ; int expectedSum   n  n   1    2; int actualSum   accumulate nums.begin  , nums.end  , 0 ; return expectedSum - actualSum;    Approach 2: XOR Bit Manipulation int missingNumberXOR vector  nums  int n   nums.size  ; int xorResult   0;    XOR all numbers from 0 to n for  int i   0; i   nums  unordered_set numSet nums.begin  , nums.end   ; int n   nums.size  ; for  int i   0; i numSet   new HashSet    ; for  int num : nums  numSet.add num ; int n   nums.length; for  int i   0; i --- Step-by-Step Walkthrough Let s trace through Example 1 with nums    3,0,1  using different approaches: Sum Formula Approach:    n   3  array length  Expected sum   3  3   1    2   3 4   2   6 Actual sum   3   0   1   4 Missing number   6 - 4   2   XOR Approach:   XOR all numbers 0 to n: 0   1   2   3   0  since 0 1 2 3   0  XOR all array numbers: 3   0   1   2 Final XOR: 0   2   2   Set Approach:   numSet   3, 0, 1 Check 0:    in set  Check 1:    in set  Check 2:    not in set    Return 2   --- XOR Magic Explained The XOR approach works because of these properties: - a   a   0  any number XOR with itself equals 0  - a   0   a  any number XOR with 0 equals itself  - XOR is commutative and associative When we XOR all numbers from 0 to n  with all numbers in the array, every number except the missing one appears twice and cancels out! --- Complexity Analysis Sum Formula: Time Complexity: O n  Single pass to calculate sum Space Complexity: O 1  Only using a few variables XOR Approach: Time Complexity: O n  Two passes: one for range, one for array Space Complexity: O 1  Only using a single variable Set Approach: Time Complexity: O n  Create set   search for missing number Space Complexity: O n  Set stores all array elements --- Key Insights Gauss formula - sum of 0 to n   n  n 1  2 XOR properties - duplicate numbers cancel out, missing remains Array constraints - exactly one number missing guarantees unique solution Trade-offs - time vs space complexity considerations --- Follow-up Questions 1. What if multiple numbers were missing? - Would need different approach, like sorting or more complex bit manipulation 2. What about integer overflow? - Sum approach could overflow with large n, XOR approach is safer 3. Which approach is most practical? - Sum formula is most intuitive and readable for interviews --- This problem demonstrates how mathematical properties and bit manipulation can provide elegant solutions to seemingly complex problems!",
    "excerpt": "Missing Number Difficulty: Easy LeetCode: 268. Missing Number --- Problem Given an array nums containing n distinct numbers in the range 0, n , return the only...",
    "url": "/docs/problems/missing-number",
    "canonicalUrl": "https://crackmode.vercel.app/docs/problems/missing-number",
    "section": "Problems",
    "tags": [
      "easy",
      "array",
      "sorting",
      "leetcode",
      "complexity",
      "interview"
    ],
    "headings": [
      {
        "level": 1,
        "text": "Missing Number",
        "id": "missing-number"
      },
      {
        "level": 2,
        "text": "Problem",
        "id": "problem"
      },
      {
        "level": 2,
        "text": "Simple Explanation",
        "id": "simple-explanation"
      },
      {
        "level": 2,
        "text": "Solution Approaches",
        "id": "solution-approaches"
      },
      {
        "level": 3,
        "text": "Approach 1: Sum Formula (Most Intuitive)",
        "id": "approach-1-sum-formula-most-intuitive"
      },
      {
        "level": 3,
        "text": "Approach 2: XOR Bit Manipulation (Most Efficient)",
        "id": "approach-2-xor-bit-manipulation-most-efficient"
      },
      {
        "level": 3,
        "text": "Approach 3: Set Lookup (Simple but uses extra space)",
        "id": "approach-3-set-lookup-simple-but-uses-extra-space"
      },
      {
        "level": 2,
        "text": "Solution",
        "id": "solution"
      },
      {
        "level": 2,
        "text": "Step-by-Step Walkthrough",
        "id": "step-by-step-walkthrough"
      },
      {
        "level": 3,
        "text": "Sum Formula Approach:",
        "id": "sum-formula-approach"
      },
      {
        "level": 3,
        "text": "XOR Approach:",
        "id": "xor-approach"
      },
      {
        "level": 3,
        "text": "Set Approach:",
        "id": "set-approach"
      },
      {
        "level": 2,
        "text": "XOR Magic Explained",
        "id": "xor-magic-explained"
      },
      {
        "level": 2,
        "text": "Complexity Analysis",
        "id": "complexity-analysis"
      },
      {
        "level": 3,
        "text": "Sum Formula:",
        "id": "sum-formula"
      },
      {
        "level": 3,
        "text": "XOR Approach:",
        "id": "xor-approach-1"
      },
      {
        "level": 3,
        "text": "Set Approach:",
        "id": "set-approach-1"
      },
      {
        "level": 2,
        "text": "Key Insights",
        "id": "key-insights"
      },
      {
        "level": 2,
        "text": "Follow-up Questions",
        "id": "follow-up-questions"
      }
    ],
    "publishedAt": "2026-01-04T04:18:51.317Z",
    "updatedAt": "2026-01-04T04:18:51.317Z",
    "author": "Morgan Ngetich",
    "readingTime": 4,
    "seo": {
      "title": "Missing Number | Crackmode Documentation",
      "description": "Missing Number Difficulty: Easy LeetCode: 268. Missing Number --- Problem Given an array nums containing n distinct numbers in the range 0, n , return the only...",
      "keywords": "missing, number, easy, array, sorting, leetcode, complexity, interview, numbers, range, approach, crackmode, algorithm",
      "robots": "index,follow",
      "jsonLd": "{\"@context\":\"https://schema.org\",\"@type\":\"Article\",\"headline\":\"Missing Number\",\"description\":\"Missing Number Difficulty: Easy LeetCode: 268. Missing Number --- Problem Given an array nums containing n distinct numbers in the range 0, n , return the only...\",\"url\":\"https://crackmode.vercel.app/docs/problems/missing-number\",\"datePublished\":\"2026-01-04T04:18:51.317Z\",\"dateModified\":\"2026-01-04T04:18:51.317Z\",\"author\":{\"@type\":\"Person\",\"name\":\"Morgan Ngetich\"},\"publisher\":{\"@type\":\"Organization\",\"name\":\"CrackMode\",\"logo\":{\"@type\":\"ImageObject\",\"url\":\"https://crackmode.vercel.app/group.png\"}},\"mainEntityOfPage\":{\"@type\":\"WebPage\",\"@id\":\"https://crackmode.vercel.app/docs/problems/missing-number\"},\"wordCount\":189,\"timeRequired\":\"PT4M\",\"inLanguage\":\"en-US\",\"isAccessibleForFree\":true}"
    },
    "socialMedia": {
      "ogTitle": "Missing Number | Crackmode Documentation",
      "ogDescription": "Given an array nums containing n distinct numbers in the range [0, n], return the only number in the range that is missing from the array.",
      "ogImage": "https://crackmode.vercel.app/api/v1/og?title=Missing+Number&description=Given+an+array+nums+containing+n+distinct+numbers+in+the+range+%5B0%2C+n%5D%2C+return+the+only+number+in+the+range+that+is+missi...&section=Documentation&theme=crackmode",
      "twitterTitle": "Missing Number | Crackmode Documentation",
      "twitterDescription": "Given an array nums containing n distinct numbers in the range [0, n], return the only number in the range that is missing from the array.",
      "twitterImage": "https://crackmode.vercel.app/api/v1/og?title=Missing+Number&description=Given+an+array+nums+containing+n+distinct+numbers+in+the+range+%5B0%2C+n%5D%2C+return+the+only+number+in+the+range+that+is+missi...&section=Documentation&theme=crackmode"
    }
  },
  {
    "id": "problems/most-common-word",
    "title": "Most Common Word",
    "content": "Most Common Word Difficulty: Easy LeetCode: 819. Most Common Word --- Problem Given a string paragraph and a string array of the banned words banned, return the most frequent word that is not banned. It is guaranteed there is at least one word that is not banned, and that the answer is unique. The words in paragraph are case-insensitive and the answer should be returned in lowercase. Note: Words cannot contain punctuation symbols. Example 1:    Input: paragraph    Bob hit a ball, the hit BALL flew far after it was hit. , banned     hit   Output:  ball  Explanation:  hit  occurs 3 times, but it is a banned word.  ball  occurs twice  and no other word does , so it is the most frequent non-banned word.   Example 2:   Input: paragraph    a. , banned      Output:  a    Constraints: - 1 str:   Step 1: Remove all punctuation marks for c in  !? ,;. : paragraph   paragraph.replace c,        Step 2: Convert to lowercase paragraph   paragraph.lower     Step 3: Split into words p_list   paragraph.split        Step 4: Remove empty strings  caused by multiple spaces  while    in p_list: p_list.remove       Step 5: Count word frequencies words_map   Counter p_list    Step 6: Sort by frequency  highest first  sorted_words_map   dict sorted words_map.items  , key lambda item: item 1 , reverse True     Step 7: Return first non-banned word for key, _ in sorted_words_map.items  : if key not in banned: return key , title:  Python  Cleaner Version  , language:  python , code: from collections import Counter class Solution: def mostCommonWord self, paragraph: str, banned: List str   -  str:   Clean and normalize: remove punctuation, lowercase, split words   re.findall r   w  , paragraph.lower      Count word frequencies word_count   Counter words    Convert banned list to set for O 1  lookup banned_set   set banned    Find most common non-banned word for word, count in word_count.most_common  : if word not in banned_set: return word , title:  JavaScript , language:  javascript , code: function mostCommonWord paragraph, banned     Step 1: Clean punctuation and convert to lowercase const cleaned   paragraph.toLowerCase  .replace   !? ,;.  g,     ;    Step 2: Split into words and filter empty strings const words   cleaned.split     .filter word    word.length   0 ;    Step 3: Count word frequencies const wordCount   ; for  const word of words  wordCount word     wordCount word     0    1;    Step 4: Convert banned array to set for faster lookup const bannedSet   new Set banned ;    Step 5: Find most frequent non-banned word let maxCount   0; let result     ; for  const  word, count  of Object.entries wordCount   if  !bannedSet.has word     count   maxCount  maxCount   count; result   word; return result; , title:  Java , language:  java , code: import java.util. ; class Solution public String mostCommonWord String paragraph, String   banned     Step 1: Clean punctuation, convert to lowercase, split String   words   paragraph.toLowerCase  .replaceAll   !? ,;.  ,     .split      s   ;    Step 2: Count word frequencies Map wordCount   new HashMap    ; for  String word : words  if  !word.isEmpty    wordCount.put word, wordCount.getOrDefault word, 0    1 ;    Step 3: Convert banned array to set Set bannedSet   new HashSet   Arrays.asList banned  ;    Step 4: Find most frequent non-banned word String result     ; int maxCount   0; for  Map.Entry entry : wordCount.entrySet    String word   entry.getKey  ; int count   entry.getValue  ; if  !bannedSet.contains word     count   maxCount  maxCount   count; result   word; return result;      --- Step-by-Step Walkthrough Let s trace through the session approach with paragraph    Bob hit a ball, the hit BALL flew far after it was hit.  and banned     hit  :   Original:  Bob hit a ball, the hit BALL flew far after it was hit.  Step 1: Remove punctuation for c in  !? ,;. : paragraph   paragraph.replace c,      Result:  Bob hit a ball the hit BALL flew far after it was hit   Step 2: Convert to lowercase paragraph   paragraph.lower   Result:  bob hit a ball the hit ball flew far after it was hit   Step 3: Split into words p_list   paragraph.split      Result:   bob ,  hit ,  a ,  ball ,   ,  the ,  hit ,  ball ,  flew ,  far ,  after ,  it ,  was ,  hit ,     Step 4: Remove empty strings while    in p_list: p_list.remove     Result:   bob ,  hit ,  a ,  ball ,  the ,  hit ,  ball ,  flew ,  far ,  after ,  it ,  was ,  hit   Step 5: Count frequencies words_map   Counter p_list  Result:  hit : 3,  ball : 2,  bob : 1,  a : 1,  the : 1,  flew : 1,  far : 1,  after : 1,  it : 1,  was : 1 Step 6: Sort by frequency  descending  sorted_words_map    hit : 3,  ball : 2,  bob : 1,  a : 1, ... Step 7: Find first non-banned word  hit  is banned   skip  ball  is not banned   return  ball      --- Visual Understanding Text Cleaning Process:    Bob hit a ball, the hit BALL flew far after it was hit.    Remove punctuation  Bob hit a ball the hit BALL flew far after it was hit     Convert to lowercase  bob hit a ball the hit ball flew far after it was hit     Split and clean   bob ,  hit ,  a ,  ball ,  the ,  hit ,  ball ,  flew ,  far ,  after ,  it ,  was ,  hit     Word Frequency Analysis:   Word Counts: hit        3 times    BANNED! ball       2 times    Winner! bob      1 time  a      1 time  the      1 time  ...   --- Common Mistakes to Avoid 1. Forgetting to handle empty strings: After splitting, you might get empty strings from consecutive spaces or punctuation 2. Case sensitivity: Don t forget to convert everything to lowercase before processing 3. Inefficient banned word lookup: Convert the banned list to a set for O 1  lookup time 4. Not handling all punctuation: Make sure you remove all specified punctuation marks:  !? ,;.  5. Regex pitfalls: If using regex, remember that  w  matches word characters  letters, digits, underscore  --- Complexity Analysis Time Complexity: O n   m  n   length of paragraph, m   number of words String operations: O n  Counting and sorting: O m log m  Overall: O n   m log m  Space Complexity: O m  HashMap to store word counts Set for banned words lookup List to store processed words --- Alternative Approaches Test Cases to Try  python Test your solution with these: print mostCommonWord  Bob hit a ball, the hit BALL flew far after it was hit. ,   hit     Should return  ball  print mostCommonWord  a. ,      Should return  a  print mostCommonWord  a, a, a, a, b,b,b,c, c ,   a     Should return  b  print mostCommonWord  Bob. hIt, baLl ,   bob ,  hit     Should return  ball  print mostCommonWord  a. ,   a     Should return whatever is the most frequent non-banned word print mostCommonWord  ... ,      Edge case - what happens with only punctuation?    --- Pattern Recognition This problem teaches several important patterns: Text Processing Pipeline: 1. Normalize   Clean punctuation, handle case 2. Tokenize   Split into meaningful units  words  3. Filter   Remove unwanted elements 4. Analyze   Count frequencies, find patterns Data Structure Choice: - HashMap for frequency counting - Set for fast banned word lookup - Sorting vs Max tracking trade-offs Edge Case Handling: - Empty strings from splitting - Case insensitivity requirements - Punctuation removal strategies You ll see similar patterns in: - Text analysis and NLP problems - Log processing and analytics - Data cleaning and preprocessing - Frequency-based algorithms --- Key Takeaway Text processing problems like this are all about the pipeline: 1. Clean your data first  remove noise, normalize format  2. Extract meaningful tokens  words, not punctuation  3. Count frequencies efficiently 4. Filter based on constraints  banned words  5. Select the best candidate The beauty is in handling edge cases gracefully and choosing the right data structures for efficient lookups. Remember: clean data leads to clean solutions! Pro tip: When dealing with text, always think about normalization first - it saves you from many bugs later!",
    "excerpt": "Most Common Word Difficulty: Easy LeetCode: 819. Most Common Word --- Problem Given a string paragraph and a string array of the banned words banned, return...",
    "url": "/docs/problems/most-common-word",
    "canonicalUrl": "https://crackmode.vercel.app/docs/problems/most-common-word",
    "section": "Problems",
    "tags": [
      "easy",
      "array",
      "arrays",
      "string",
      "strings",
      "graph"
    ],
    "headings": [
      {
        "level": 1,
        "text": "Most Common Word",
        "id": "most-common-word"
      },
      {
        "level": 2,
        "text": "Problem",
        "id": "problem"
      },
      {
        "level": 2,
        "text": "Simple Explanation",
        "id": "simple-explanation"
      },
      {
        "level": 2,
        "text": "Solution",
        "id": "solution"
      },
      {
        "level": 2,
        "text": "Step-by-Step Walkthrough",
        "id": "step-by-step-walkthrough"
      },
      {
        "level": 2,
        "text": "Visual Understanding",
        "id": "visual-understanding"
      },
      {
        "level": 2,
        "text": "Common Mistakes to Avoid",
        "id": "common-mistakes-to-avoid"
      },
      {
        "level": 2,
        "text": "Complexity Analysis",
        "id": "complexity-analysis"
      },
      {
        "level": 2,
        "text": "Alternative Approaches",
        "id": "alternative-approaches"
      },
      {
        "level": 2,
        "text": "Test Cases to Try",
        "id": "test-cases-to-try"
      },
      {
        "level": 1,
        "text": "Test your solution with these:",
        "id": "test-your-solution-with-these"
      },
      {
        "level": 1,
        "text": "Should return \"ball\"",
        "id": "should-return-ball"
      },
      {
        "level": 1,
        "text": "Should return \"a\"",
        "id": "should-return-a"
      },
      {
        "level": 1,
        "text": "Should return \"b\"",
        "id": "should-return-b"
      },
      {
        "level": 1,
        "text": "Should return \"ball\"",
        "id": "should-return-ball-1"
      },
      {
        "level": 1,
        "text": "Should return whatever is the most frequent non-banned word",
        "id": "should-return-whatever-is-the-most-frequent-non-banned-word"
      },
      {
        "level": 1,
        "text": "Edge case - what happens with only punctuation?",
        "id": "edge-case-what-happens-with-only-punctuation"
      },
      {
        "level": 2,
        "text": "Pattern Recognition",
        "id": "pattern-recognition"
      },
      {
        "level": 2,
        "text": "Key Takeaway",
        "id": "key-takeaway"
      }
    ],
    "publishedAt": "2026-01-04T04:18:51.321Z",
    "updatedAt": "2026-01-04T04:18:51.321Z",
    "author": "Morgan Ngetich",
    "readingTime": 7,
    "seo": {
      "title": "Most Common Word | Crackmode Documentation",
      "description": "Most Common Word Difficulty: Easy LeetCode: 819. Most Common Word --- Problem Given a string paragraph and a string array of the banned words banned, return...",
      "keywords": "most, common, word, easy, array, arrays, string, strings, graph, banned, words, return, count, crackmode, leetcode, algorithm",
      "robots": "index,follow",
      "jsonLd": "{\"@context\":\"https://schema.org\",\"@type\":\"Article\",\"headline\":\"Most Common Word\",\"description\":\"Most Common Word Difficulty: Easy LeetCode: 819. Most Common Word --- Problem Given a string paragraph and a string array of the banned words banned, return...\",\"url\":\"https://crackmode.vercel.app/docs/problems/most-common-word\",\"datePublished\":\"2026-01-04T04:18:51.321Z\",\"dateModified\":\"2026-01-04T04:18:51.321Z\",\"author\":{\"@type\":\"Person\",\"name\":\"Morgan Ngetich\"},\"publisher\":{\"@type\":\"Organization\",\"name\":\"CrackMode\",\"logo\":{\"@type\":\"ImageObject\",\"url\":\"https://crackmode.vercel.app/group.png\"}},\"mainEntityOfPage\":{\"@type\":\"WebPage\",\"@id\":\"https://crackmode.vercel.app/docs/problems/most-common-word\"},\"wordCount\":182,\"timeRequired\":\"PT7M\",\"inLanguage\":\"en-US\",\"isAccessibleForFree\":true}"
    },
    "socialMedia": {
      "ogTitle": "Most Common Word | Crackmode Documentation",
      "ogDescription": "Given a string paragraph and a string array of the banned words banned, return the most frequent word that is not banned.",
      "ogImage": "https://crackmode.vercel.app/api/v1/og?title=Most+Common+Word&description=Given+a+string+paragraph+and+a+string+array+of+the+banned+words+banned%2C+return+the+most+frequent+word+that+is+not+banned...&section=Documentation&theme=crackmode",
      "twitterTitle": "Most Common Word | Crackmode Documentation",
      "twitterDescription": "Given a string paragraph and a string array of the banned words banned, return the most frequent word that is not banned.",
      "twitterImage": "https://crackmode.vercel.app/api/v1/og?title=Most+Common+Word&description=Given+a+string+paragraph+and+a+string+array+of+the+banned+words+banned%2C+return+the+most+frequent+word+that+is+not+banned...&section=Documentation&theme=crackmode"
    }
  },
  {
    "id": "problems/number-of-1-bits",
    "title": "Number Of 1 Bits",
    "content": "Number of 1 Bits Difficulty: Easy LeetCode: 191. Number of 1 Bits --- Problem Given a positive integer n, write a function that returns the number of set bits in its binary representation  also known as the Hamming weight . Example 1:    Input: n   11 Output: 3 Explanation: The input binary string 1011 has a total of three set bits.   Example 2:   Input: n   128 Output: 1 Explanation: The input binary string 10000000 has a total of one set bit.   Example 3:   Input: n   2147483645 Output: 30 Explanation: The input binary string 1111111111111111111111111111101 has a total of thirty set bits.   --- Simple Explanation Think of this like counting light bulbs that are ON in a binary string! - Binary 1011 has 3 lights ON  three 1s  - Binary 10000000 has 1 light ON  one 1  - Just count how many 1 bits exist in the number The Key: Use bit manipulation tricks to efficiently count 1s without converting to string. --- Optimal Solutions    1   Right shift by 1 return count def hammingWeight_builtin n :     Using Built-in Function     return bin n .count  1   , title:  JavaScript , language:  javascript , code: function hammingWeight n     Brian Kernighan s Algorithm let count   0; while  n !   0  n    n - 1;    Remove rightmost 1 bit count  ; return count; function hammingWeight_v2 n     Right shift method let count   0; while  n !   0  count    n   1;    Check rightmost bit n      1;    Unsigned right shift return count; function hammingWeight_builtin n     Using built-in method return n.toString 2 .split  1  .length - 1; , title:  Java , language:  java , code: public class Solution public int hammingWeight int n     Brian Kernighan s Algorithm int count   0; while  n !  0  n    n - 1;    Remove rightmost 1 bit count  ; return count; public int hammingWeight_v2 int n     Right shift method int count   0; while  n !  0  count    n   1;    Check rightmost bit n      1;    Unsigned right shift return count; public int hammingWeight_builtin int n     Using built-in method return Integer.bitCount n ; , title:  C   , language:  cpp , code: class Solution public: int hammingWeight uint32_t n     Brian Kernighan s Algorithm int count   0; while  n  n     n - 1 ;    Remove rightmost 1 bit count  ; return count; int hammingWeight_v2 uint32_t n     Right shift method int count   0; while  n  count     n   1 ;    Check rightmost bit n     1;    Logical shift return count; int hammingWeight_builtin uint32_t n     Using built-in function return __builtin_popcount n ; ;      --- Step-by-Step Walkthrough Brian Kernighan s Algorithm for n   12  binary: 1100     Step 1: n   1100  12  n-1   1011  11  n    n-1    1100   1011   1000  8  count   1 Step 2: n   1000  8  n-1   0111  7  n    n-1    1000   0111   0000  0  count   2 Step 3: n   0000  0  Loop ends, return count   2     Right Shift Method for n   11  binary: 1011    Step 1: n   1011, rightmost bit   1 count    1, n     1   n   0101 count   1 Step 2: n   0101, rightmost bit   1 count    1, n     1   n   0010 count   2 Step 3: n   0010, rightmost bit   0 count    0, n     1   n   0001 count   2 Step 4: n   0001, rightmost bit   1 count    1, n     1   n   0000 count   3 Step 5: n   0000, loop ends return count   3     --- Why Brian Kernighan s Algorithm Works Bit manipulation magic - n    n-1  always removes the rightmost 1 bit Fewer iterations - Only loops for the number of 1 bits, not all 32 bits Mathematical property - Subtracting 1 flips all trailing bits including first 1 Optimal performance - Best case O 1  for powers of 2, worst case O log n  --- Bit Manipulation Breakdown Understanding n    n-1 :   Example: n   1100  12  n   1100 n-1   1011  subtracting 1 flips rightmost 1 and all 0s after it  ------ n  n-1   1000  removes the rightmost 1 bit  Example: n   1000  8  n   1000 n-1   0111  subtracting 1 flips the single 1 and all 0s after it  ------ n  n-1   0000  removes the rightmost 1 bit    Why this works: 1. Subtracting 1 from any number flips the rightmost 1 bit to 0 2. It also flips all trailing 0s to 1s 3. AND operation keeps only bits that are 1 in both numbers 4. This effectively removes the rightmost 1 bit --- Edge Cases  python Test cases: print hammingWeight 0     0  binary: 0  print hammingWeight 1     1  binary: 1  print hammingWeight 2     1  binary: 10  print hammingWeight 7     3  binary: 111  print hammingWeight 8     1  binary: 1000  print hammingWeight 15     4  binary: 1111  print hammingWeight 2147483647     31  binary: 01111...1111  print hammingWeight 2147483648     1  binary: 10000...0000    --- Common Mistakes to Avoid 1. Signed vs unsigned shifts: Use     in JavaScript for unsigned right shift 2. Infinite loops: Make sure to handle the termination condition correctly 3. Overflow issues: Be careful with large numbers in different languages 4. Wrong bit operations: Don t confuse    AND  with     logical AND  --- Complexity Analysis Brian Kernighan s Algorithm: Time: O number of 1 bits  - Best case O 1 , worst case O 32  Space: O 1  Right Shift Method: Time: O 32  - Always checks all bits Space: O 1  Built-in Methods: Time: O 1  - Optimized assembly instructions Space: O 1  --- Pattern Recognition This problem demonstrates key patterns: - Bit Manipulation: Core operations like AND, OR, XOR, shifts - Brian Kernighan s Algorithm: Efficiently removing rightmost set bits - Hamming Weight: Counting set bits in binary representation - Optimization: Trading algorithm complexity for fewer iterations You ll see similar patterns in: - Power of Two detection: n    n-1     0 - Counting trailing zeros - Bit reversal problems - Binary tree problems with bit indexing --- Real-World Applications - Error Detection: Hamming codes for detecting correcting errors - Cryptography: Bit counting in hash functions and encryption - Computer Graphics: Bit masks for pixel manipulation - Database Systems: Bitmap indexes for fast queries - Network Protocols: Checksums and parity bits --- Visual Representation   Number: 1011  11 in decimal  Bit positions: 3 2 1 0 Binary: 1 0 1 1       1 1 1   Count these   3 Brian Kernighan s steps: 1011   1010   1010  removed rightmost 1  1010   1001   1000  removed rightmost 1  1000   0111   0000  removed rightmost 1  Total operations: 3  same as number of 1 bits",
    "excerpt": "Number of 1 Bits Difficulty: Easy LeetCode: 191. Number of 1 Bits --- Problem Given a positive integer n, write a function that returns the number of set bits...",
    "url": "/docs/problems/number-of-1-bits",
    "canonicalUrl": "https://crackmode.vercel.app/docs/problems/number-of-1-bits",
    "section": "Problems",
    "tags": [
      "easy",
      "string",
      "tree",
      "graph",
      "leetcode",
      "algorithm"
    ],
    "headings": [
      {
        "level": 1,
        "text": "Number of 1 Bits",
        "id": "number-of-1-bits"
      },
      {
        "level": 2,
        "text": "Problem",
        "id": "problem"
      },
      {
        "level": 2,
        "text": "Simple Explanation",
        "id": "simple-explanation"
      },
      {
        "level": 2,
        "text": "Optimal Solutions",
        "id": "optimal-solutions"
      },
      {
        "level": 1,
        "text": "How it works:",
        "id": "how-it-works"
      },
      {
        "level": 1,
        "text": "n = 1100 (12 in decimal)",
        "id": "n-1100-12-in-decimal"
      },
      {
        "level": 1,
        "text": "n-1 = 1011 (11 in decimal)",
        "id": "n-1-1011-11-in-decimal"
      },
      {
        "level": 1,
        "text": "n & (n-1) = 1000 (removes rightmost 1)",
        "id": "n-n-1-1000-removes-rightmost-1"
      },
      {
        "level": 1,
        "text": "Continue until n becomes 0",
        "id": "continue-until-n-becomes-0"
      },
      {
        "level": 2,
        "text": "Step-by-Step Walkthrough",
        "id": "step-by-step-walkthrough"
      },
      {
        "level": 3,
        "text": "Brian Kernighan's Algorithm for n = 12 (binary: 1100)",
        "id": "brian-kernighans-algorithm-for-n-12-binary-1100"
      },
      {
        "level": 3,
        "text": "Right Shift Method for n = 11 (binary: 1011)",
        "id": "right-shift-method-for-n-11-binary-1011"
      },
      {
        "level": 2,
        "text": "Why Brian Kernighan's Algorithm Works",
        "id": "why-brian-kernighans-algorithm-works"
      },
      {
        "level": 2,
        "text": "Bit Manipulation Breakdown",
        "id": "bit-manipulation-breakdown"
      },
      {
        "level": 3,
        "text": "Understanding `n & (n-1)`:",
        "id": "understanding-n-n-1"
      },
      {
        "level": 3,
        "text": "Why this works:",
        "id": "why-this-works"
      },
      {
        "level": 2,
        "text": "Edge Cases",
        "id": "edge-cases"
      },
      {
        "level": 1,
        "text": "Test cases:",
        "id": "test-cases"
      },
      {
        "level": 2,
        "text": "Common Mistakes to Avoid",
        "id": "common-mistakes-to-avoid"
      },
      {
        "level": 2,
        "text": "Complexity Analysis",
        "id": "complexity-analysis"
      },
      {
        "level": 2,
        "text": "Pattern Recognition",
        "id": "pattern-recognition"
      },
      {
        "level": 2,
        "text": "Real-World Applications",
        "id": "real-world-applications"
      },
      {
        "level": 2,
        "text": "Visual Representation",
        "id": "visual-representation"
      }
    ],
    "publishedAt": "2026-01-04T04:18:51.321Z",
    "updatedAt": "2026-01-04T04:18:51.321Z",
    "author": "Morgan Ngetich",
    "readingTime": 6,
    "seo": {
      "title": "Number Of 1 Bits | Crackmode Documentation",
      "description": "Number of 1 Bits Difficulty: Easy LeetCode: 191. Number of 1 Bits --- Problem Given a positive integer n, write a function that returns the number of set bits...",
      "keywords": "number, bits, easy, string, tree, graph, leetcode, algorithm, count, rightmost, return, hammingweight, shift, crackmode",
      "robots": "index,follow",
      "jsonLd": "{\"@context\":\"https://schema.org\",\"@type\":\"Article\",\"headline\":\"Number Of 1 Bits\",\"description\":\"Number of 1 Bits Difficulty: Easy LeetCode: 191. Number of 1 Bits --- Problem Given a positive integer n, write a function that returns the number of set bits...\",\"url\":\"https://crackmode.vercel.app/docs/problems/number-of-1-bits\",\"datePublished\":\"2026-01-04T04:18:51.321Z\",\"dateModified\":\"2026-01-04T04:18:51.321Z\",\"author\":{\"@type\":\"Person\",\"name\":\"Morgan Ngetich\"},\"publisher\":{\"@type\":\"Organization\",\"name\":\"CrackMode\",\"logo\":{\"@type\":\"ImageObject\",\"url\":\"https://crackmode.vercel.app/group.png\"}},\"mainEntityOfPage\":{\"@type\":\"WebPage\",\"@id\":\"https://crackmode.vercel.app/docs/problems/number-of-1-bits\"},\"wordCount\":203,\"timeRequired\":\"PT6M\",\"inLanguage\":\"en-US\",\"isAccessibleForFree\":true}"
    },
    "socialMedia": {
      "ogTitle": "Number Of 1 Bits | Crackmode Documentation",
      "ogDescription": "Given a positive integer n, write a function that returns the number of set bits in its binary representation (also known as the Hamming weight).",
      "ogImage": "https://crackmode.vercel.app/api/v1/og?title=Number+Of+1+Bits&description=Given+a+positive+integer+n%2C+write+a+function+that+returns+the+number+of+set+bits+in+its+binary+representation+%28also+know...&section=Documentation&theme=crackmode",
      "twitterTitle": "Number Of 1 Bits | Crackmode Documentation",
      "twitterDescription": "Given a positive integer n, write a function that returns the number of set bits in its binary representation (also known as the Hamming weight).",
      "twitterImage": "https://crackmode.vercel.app/api/v1/og?title=Number+Of+1+Bits&description=Given+a+positive+integer+n%2C+write+a+function+that+returns+the+number+of+set+bits+in+its+binary+representation+%28also+know...&section=Documentation&theme=crackmode"
    }
  },
  {
    "id": "problems/number-of-good-pairs",
    "title": "Number Of Good Pairs",
    "content": "Number of Good Pairs Difficulty: Easy LeetCode: 1512. Number of Good Pairs --- Problem Given an array of integers nums, return the number of good pairs. A pair  i, j  is called good if nums i     nums j  and i count   new HashMap    ; for  int num : nums  count.put num, count.getOrDefault num, 0    1 ; int pairs   0;    Calculate pairs for each unique number for  int freq : count.values    pairs    freq    freq - 1    2; return pairs;      --- Step-by-Step Walkthrough Let s trace through nums    1,2,3,1,1,3 :    Step 1: Count frequency of each number count   1: 3, 2: 1, 3: 2 Step 2: Calculate pairs for each number Number 1 appears 3 times: - Pairs: 3    3-1    2   3   2   2   3 - These are:  0,3 ,  0,4 ,  3,4  Number 2 appears 1 time: - Pairs: 1    1-1    2   1   0   2   0 - No pairs possible with just one occurrence Number 3 appears 2 times: - Pairs: 2    2-1    2   2   1   2   1 - This is:  2,5  Step 3: Sum all pairs Total pairs   3   0   1   4     Let s try another example: nums    1,1,1,1 :   Step 1: Count frequency count   1: 4 Step 2: Calculate pairs Number 1 appears 4 times: - Pairs: 4    4-1    2   4   3   2   6 - These are:  0,1 ,  0,2 ,  0,3 ,  1,2 ,  1,3 ,  2,3  Step 3: Total pairs   6     --- Why This Approach Works Mathematical insight - Uses combination formula: C n,2    n  n-1  2 Efficient counting - Single pass to count, then calculate pairs No nested loops - Avoids checking every possible pair individually Clear logic - Count first, then use math to find pairs --- Alternative Brute Force Approach If you want a more straightforward approach  though less efficient :  python def numIdenticalPairs_brute_force nums : count   0 n   len nums    Check every possible pair for i in range n : for j in range i   1, n :   j must be greater than i if nums i     nums j : count    1 return count   This is O n   but very easy to understand! --- Mathematical Explanation Why n    n-1    2? When you have n identical items, you want to choose 2 of them to form a pair. This is the combination formula:   C n, 2    n!    2!    n-2 !    n    n-1     n-2 !    2   1    n-2 !    n    n-1    2   Visual example with 4 identical numbers: - Position indices: 0, 1, 2, 3 - Possible pairs:  0,1 ,  0,2 ,  0,3 ,  1,2 ,  1,3 ,  2,3  - Count: 6 pairs   4   3   2   --- Common Mistakes to Avoid 1. Forgetting the order constraint: Remember i   j is required 2. Double counting: Don t count  i,j  and  j,i  as different pairs 3. Wrong formula: Make sure to use n  n-1  2, not n n 2 4. Integer division: Use    in Python or proper integer division --- Complexity Analysis Time Complexity: O n  Single pass to count frequencies Single pass to calculate pairs from frequencies Space Complexity: O n  HashMap to store frequency of each unique number In worst case, all numbers are unique --- Test Cases to Try  python Test your solution with these: print numIdenticalPairs  1,2,3,1,1,3      Should return 4 print numIdenticalPairs  1,1,1,1      Should return 6 print numIdenticalPairs  1,2,3      Should return 0 print numIdenticalPairs  1,1,2,2,2      Should return 1 3   4 print numIdenticalPairs  1      Should return 0 print numIdenticalPairs        Should return 0    --- Pattern Recognition This problem teaches an important pattern: - Counting   Combinatorics: When you need to find pairs combinations within groups - Frequency mapping: Count occurrences first, then apply mathematical formulas - Optimization: Turn O n   brute force into O n  with smart counting You ll see this pattern in problems like: - Counting pairs with specific differences - Finding anagram groups - Counting subsequences",
    "excerpt": "Number of Good Pairs Difficulty: Easy LeetCode: 1512. Number of Good Pairs --- Problem Given an array of integers nums, return the number of good pairs.",
    "url": "/docs/problems/number-of-good-pairs",
    "canonicalUrl": "https://crackmode.vercel.app/docs/problems/number-of-good-pairs",
    "section": "Problems",
    "tags": [
      "easy",
      "array",
      "leetcode",
      "optimization",
      "complexity",
      "pattern"
    ],
    "headings": [
      {
        "level": 1,
        "text": "Number of Good Pairs",
        "id": "number-of-good-pairs"
      },
      {
        "level": 2,
        "text": "Problem",
        "id": "problem"
      },
      {
        "level": 2,
        "text": "Simple Explanation",
        "id": "simple-explanation"
      },
      {
        "level": 2,
        "text": "Solution",
        "id": "solution"
      },
      {
        "level": 1,
        "text": "Example usage:",
        "id": "example-usage"
      },
      {
        "level": 1,
        "text": "nums = [1,2,3,1,1,3]",
        "id": "nums-123113"
      },
      {
        "level": 1,
        "text": "count = {1: 3, 2: 1, 3: 2}",
        "id": "count-1-3-2-1-3-2"
      },
      {
        "level": 1,
        "text": "pairs from 1: 3*(3-1)/2 = 3",
        "id": "pairs-from-1-33-12-3"
      },
      {
        "level": 1,
        "text": "pairs from 2: 1*(1-1)/2 = 0",
        "id": "pairs-from-2-11-12-0"
      },
      {
        "level": 1,
        "text": "pairs from 3: 2*(2-1)/2 = 1",
        "id": "pairs-from-3-22-12-1"
      },
      {
        "level": 1,
        "text": "Total: 3 + 0 + 1 = 4`",
        "id": "total-3-0-1-4"
      },
      {
        "level": 2,
        "text": "Step-by-Step Walkthrough",
        "id": "step-by-step-walkthrough"
      },
      {
        "level": 2,
        "text": "Why This Approach Works",
        "id": "why-this-approach-works"
      },
      {
        "level": 2,
        "text": "Alternative Brute Force Approach",
        "id": "alternative-brute-force-approach"
      },
      {
        "level": 2,
        "text": "Mathematical Explanation",
        "id": "mathematical-explanation"
      },
      {
        "level": 2,
        "text": "Common Mistakes to Avoid",
        "id": "common-mistakes-to-avoid"
      },
      {
        "level": 2,
        "text": "Complexity Analysis",
        "id": "complexity-analysis"
      },
      {
        "level": 2,
        "text": "Test Cases to Try",
        "id": "test-cases-to-try"
      },
      {
        "level": 1,
        "text": "Test your solution with these:",
        "id": "test-your-solution-with-these"
      },
      {
        "level": 2,
        "text": "Pattern Recognition",
        "id": "pattern-recognition"
      }
    ],
    "publishedAt": "2026-01-04T04:18:51.321Z",
    "updatedAt": "2026-01-04T04:18:51.321Z",
    "author": "Morgan Ngetich",
    "readingTime": 4,
    "seo": {
      "title": "Number Of Good Pairs | Crackmode Documentation",
      "description": "Number of Good Pairs Difficulty: Easy LeetCode: 1512. Number of Good Pairs --- Problem Given an array of integers nums, return the number of good pairs.",
      "keywords": "number, good, pairs, easy, array, leetcode, optimization, complexity, pattern, count, return, print, crackmode, algorithm",
      "robots": "index,follow",
      "jsonLd": "{\"@context\":\"https://schema.org\",\"@type\":\"Article\",\"headline\":\"Number Of Good Pairs\",\"description\":\"Number of Good Pairs Difficulty: Easy LeetCode: 1512. Number of Good Pairs --- Problem Given an array of integers nums, return the number of good pairs.\",\"url\":\"https://crackmode.vercel.app/docs/problems/number-of-good-pairs\",\"datePublished\":\"2026-01-04T04:18:51.321Z\",\"dateModified\":\"2026-01-04T04:18:51.321Z\",\"author\":{\"@type\":\"Person\",\"name\":\"Morgan Ngetich\"},\"publisher\":{\"@type\":\"Organization\",\"name\":\"CrackMode\",\"logo\":{\"@type\":\"ImageObject\",\"url\":\"https://crackmode.vercel.app/group.png\"}},\"mainEntityOfPage\":{\"@type\":\"WebPage\",\"@id\":\"https://crackmode.vercel.app/docs/problems/number-of-good-pairs\"},\"wordCount\":182,\"timeRequired\":\"PT4M\",\"inLanguage\":\"en-US\",\"isAccessibleForFree\":true}"
    },
    "socialMedia": {
      "ogTitle": "Number Of Good Pairs | Crackmode Documentation",
      "ogDescription": "Given an array of integers nums, return the number of good pairs. A pair (i, j) is called good if nums[i] == nums[j] and i < j.",
      "ogImage": "https://crackmode.vercel.app/api/v1/og?title=Number+Of+Good+Pairs&description=Given+an+array+of+integers+nums%2C+return+the+number+of+good+pairs.+A+pair+%28i%2C+j%29+is+called+good+if+nums%5Bi%5D+%3D%3D+nums%5Bj%5D+and...&section=Documentation&theme=crackmode",
      "twitterTitle": "Number Of Good Pairs | Crackmode Documentation",
      "twitterDescription": "Given an array of integers nums, return the number of good pairs. A pair (i, j) is called good if nums[i] == nums[j] and i < j.",
      "twitterImage": "https://crackmode.vercel.app/api/v1/og?title=Number+Of+Good+Pairs&description=Given+an+array+of+integers+nums%2C+return+the+number+of+good+pairs.+A+pair+%28i%2C+j%29+is+called+good+if+nums%5Bi%5D+%3D%3D+nums%5Bj%5D+and...&section=Documentation&theme=crackmode"
    }
  },
  {
    "id": "problems/two-sum",
    "title": "Two Sum",
    "content": "Two Sum Difficulty: Easy LeetCode: 1. Two Sum --- Problem Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. You may assume that each input would have exactly one solution, and you may not use the same element twice. You can return the answer in any order. Example 1:    Input: nums    2,7,11,15 , target   9 Output:  0,1  Explanation: Because nums 0    nums 1     9, we return  0, 1 .   Example 2:   Input: nums    3,2,4 , target   6 Output:  1,2  Explanation: Because nums 1    nums 2     6, we return  1, 2 .   Example 3:   Input: nums    3,3 , target   6 Output:  0,1  Explanation: Because nums 0    nums 1     6, we return  0, 1 .   --- Simple Explanation Think of this like finding a pair of numbers that add up to your target! - You have a list of numbers:  2, 7, 11, 15  - You want to find two that add up to 9 - 2   7   9, so return their positions  0, 1  The Key: Use a hash map to store numbers you ve seen and their indices, then check if the complement exists. --- Optimal Solutions numMap   new HashMap    ; for  int i   0; i numMap   new HashMap    ;    First pass: build the hash map for  int i   0; i  include class Solution public: std::vector twoSum std::vector  nums, int target     Hash Map Approach std::unordered_map numMap;    value: index for  int i   0; i twoSum_bruteForce std::vector  nums, int target     Brute Force Approach for  int i   0; i twoSum_twoPass std::vector  nums, int target     Two Pass Hash Map std::unordered_map numMap;    First pass: build the hash map for  int i   0; i --- Step-by-Step Walkthrough Hash Map Approach for nums    2,7,11,15 , target   9   Step 1: i 0, num 2 complement   9 - 2   7 7 not in numMap Store: numMap 2    0 numMap   2: 0 Step 2: i 1, num 7 complement   9 - 7   2 2 found in numMap at index 0 Return  0, 1      Brute Force Approach for nums    3,2,4 , target   6   Step 1: i 0, j 1 nums 0    nums 1    3   2   5   6 Step 2: i 0, j 2 nums 0    nums 2    3   4   7   6 Step 3: i 1, j 2 nums 1    nums 2    2   4   6   6   Return  1, 2    --- Why Hash Map Works Constant lookup - Hash map provides O 1  average time for lookups Complement search - Instead of checking all pairs, find what s needed: target - current Single pass - Build map and search simultaneously in one iteration Index preservation - Store both value and index to return positions, not values --- Algorithm Comparison Hash Map vs Brute Force:   Hash Map Approach: - Time: O n  - single pass through array - Space: O n  - hash map storage - Best for: Most cases, especially larger arrays nums    2, 7, 11, 15 , target   9 Iteration 1: Check if 7 exists   No, store 2 0 Iteration 2: Check if 2 exists   Yes! Return  0,1  Brute Force Approach: - Time: O n   - nested loops - Space: O 1  - no extra storage - Best for: Very small arrays or memory-constrained systems nums    2, 7, 11, 15 , target   9 Check: 2 7 9   Return  0,1   Would check 2 11, 2 15, 7 11, 7 15, 11 15 if needed    --- Edge Cases  python Test cases: print twoSum  2, 7, 11, 15 , 9      0, 1  - normal case print twoSum  3, 2, 4 , 6      1, 2  - middle elements print twoSum  3, 3 , 6      0, 1  - duplicate numbers print twoSum  -1, -2, -3, -4, -5 , -8      2, 4  - negative numbers print twoSum  0, 4, 3, 0 , 0      0, 3  - zeros print twoSum  -3, 4, 3, 90 , 0      0, 2  - sum to zero   --- Common Mistakes to Avoid 1. Using same element twice: Make sure indices are different when complement equals current number 2. Wrong return format: Return indices, not the actual values 3. Hash collision handling: Use proper hash map implementation, not naive approaches 4. Index out of bounds: Ensure you re not accessing invalid array indices 5. Assuming sorted input: The array is not necessarily sorted --- Complexity Analysis Hash Map Approach  Optimal : Time: O n  - Single pass through array Space: O n  - Hash map can store up to n elements Brute Force Approach: Time: O n   - Nested loops check all pairs Space: O 1  - No extra space used Two Pass Hash Map: Time: O n  - Two separate O n  passes Space: O n  - Hash map storage --- Pattern Recognition This problem demonstrates key patterns: - Hash Map for Lookups: Trading space for time complexity - Complement Search: Finding pairs by searching for target - current - Index Tracking: Storing both values and positions - Early Termination: Returning as soon as solution is found You ll see similar patterns in: - Three Sum   Four Sum problems - Subarray sum problems - Finding pairs with specific properties - Anagram detection - Frequency counting problems --- Real-World Applications - Financial Systems: Finding transactions that sum to specific amounts - Inventory Management: Pairing items to meet weight value targets - Gaming: Finding combinations of items skills that reach targets - Data Analysis: Identifying correlated data points - Recommendation Systems: Finding complementary products content --- Visual Representation   Array:  2, 7, 11, 15 , Target: 9 Hash Map Approach Visualization: Step 1: num 2, complement 7 numMap: 2: 0 Step 2: num 7, complement 2 Check numMap: 2 exists at index 0 Found pair: indices  0, 1  Index: 0 1 2 3 Array:  2, 7, 11, 15                 Sum   9   Time taken: 2 iterations instead of checking all 6 possible pairs    --- Follow-up Questions Q: Can you solve it in less than O n  time complexity? A: No, we need to examine each element at least once, so O n  is optimal. Q: What if the array is sorted? A: Use two pointers  left 0, right n-1  moving towards each other based on sum comparison. Q: What if there are multiple valid pairs? A: The problem guarantees exactly one solution, but you could return the first found or all pairs. Q: What if no solution exists? A: Return empty array or throw exception  problem states solution always exists .",
    "excerpt": "Two Sum Difficulty: Easy LeetCode: 1. Two Sum --- Problem Given an array of integers nums and an integer target, return indices of the two numbers such that...",
    "url": "/docs/problems/two-sum",
    "canonicalUrl": "https://crackmode.vercel.app/docs/problems/two-sum",
    "section": "Problems",
    "tags": [
      "easy",
      "array",
      "arrays",
      "searching",
      "leetcode",
      "algorithm"
    ],
    "headings": [
      {
        "level": 1,
        "text": "Two Sum",
        "id": "two-sum"
      },
      {
        "level": 2,
        "text": "Problem",
        "id": "problem"
      },
      {
        "level": 2,
        "text": "Simple Explanation",
        "id": "simple-explanation"
      },
      {
        "level": 2,
        "text": "Optimal Solutions",
        "id": "optimal-solutions"
      },
      {
        "level": 2,
        "text": "Step-by-Step Walkthrough",
        "id": "step-by-step-walkthrough"
      },
      {
        "level": 3,
        "text": "Hash Map Approach for nums = [2,7,11,15], target = 9",
        "id": "hash-map-approach-for-nums-271115-target-9"
      },
      {
        "level": 3,
        "text": "Brute Force Approach for nums = [3,2,4], target = 6",
        "id": "brute-force-approach-for-nums-324-target-6"
      },
      {
        "level": 2,
        "text": "Why Hash Map Works",
        "id": "why-hash-map-works"
      },
      {
        "level": 2,
        "text": "Algorithm Comparison",
        "id": "algorithm-comparison"
      },
      {
        "level": 3,
        "text": "Hash Map vs Brute Force:",
        "id": "hash-map-vs-brute-force"
      },
      {
        "level": 2,
        "text": "Edge Cases",
        "id": "edge-cases"
      },
      {
        "level": 1,
        "text": "Test cases:",
        "id": "test-cases"
      },
      {
        "level": 2,
        "text": "Common Mistakes to Avoid",
        "id": "common-mistakes-to-avoid"
      },
      {
        "level": 2,
        "text": "Complexity Analysis",
        "id": "complexity-analysis"
      },
      {
        "level": 2,
        "text": "Pattern Recognition",
        "id": "pattern-recognition"
      },
      {
        "level": 2,
        "text": "Real-World Applications",
        "id": "real-world-applications"
      },
      {
        "level": 2,
        "text": "Visual Representation",
        "id": "visual-representation"
      },
      {
        "level": 2,
        "text": "Follow-up Questions",
        "id": "follow-up-questions"
      }
    ],
    "publishedAt": "2026-01-04T04:18:51.321Z",
    "updatedAt": "2026-01-04T04:18:51.321Z",
    "author": "Morgan Ngetich",
    "readingTime": 6,
    "seo": {
      "title": "Two Sum | Crackmode Documentation",
      "description": "Two Sum Difficulty: Easy LeetCode: 1. Two Sum --- Problem Given an array of integers nums and an integer target, return indices of the two numbers such that...",
      "keywords": "easy, array, arrays, searching, leetcode, algorithm, return, target, complement, twosum, crackmode",
      "robots": "index,follow",
      "jsonLd": "{\"@context\":\"https://schema.org\",\"@type\":\"Article\",\"headline\":\"Two Sum\",\"description\":\"Two Sum Difficulty: Easy LeetCode: 1. Two Sum --- Problem Given an array of integers nums and an integer target, return indices of the two numbers such that...\",\"url\":\"https://crackmode.vercel.app/docs/problems/two-sum\",\"datePublished\":\"2026-01-04T04:18:51.321Z\",\"dateModified\":\"2026-01-04T04:18:51.321Z\",\"author\":{\"@type\":\"Person\",\"name\":\"Morgan Ngetich\"},\"publisher\":{\"@type\":\"Organization\",\"name\":\"CrackMode\",\"logo\":{\"@type\":\"ImageObject\",\"url\":\"https://crackmode.vercel.app/group.png\"}},\"mainEntityOfPage\":{\"@type\":\"WebPage\",\"@id\":\"https://crackmode.vercel.app/docs/problems/two-sum\"},\"wordCount\":196,\"timeRequired\":\"PT6M\",\"inLanguage\":\"en-US\",\"isAccessibleForFree\":true}"
    },
    "socialMedia": {
      "ogTitle": "Two Sum | Crackmode Documentation",
      "ogDescription": "Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. You may assume that each input would have exactly one solution, and you may not use the same element twice. You can return the answer in any order.",
      "ogImage": "https://crackmode.vercel.app/api/v1/og?title=Two+Sum&description=Given+an+array+of+integers+nums+and+an+integer+target%2C+return+indices+of+the+two+numbers+such+that+they+add+up+to+target...&section=Documentation&theme=crackmode",
      "twitterTitle": "Two Sum | Crackmode Documentation",
      "twitterDescription": "Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. You may assume that each input would have exactly one solution, and you may not use the same element twice. You can return the answer in any order.",
      "twitterImage": "https://crackmode.vercel.app/api/v1/og?title=Two+Sum&description=Given+an+array+of+integers+nums+and+an+integer+target%2C+return+indices+of+the+two+numbers+such+that+they+add+up+to+target...&section=Documentation&theme=crackmode"
    }
  },
  {
    "id": "problems/unique-number-of-occurrences",
    "title": "Unique Number Of Occurrences",
    "content": "Unique Number of Occurrences Difficulty: Easy LeetCode: 1207. Unique Number of Occurrences --- Problem Given an array of integers arr, return true if the number of occurrences of each value in the array is unique or false otherwise. Example 1:    Input: arr    1,2,2,1,1,3  Output: true Explanation: The value 1 has 3 occurrences, 2 has 2 and 3 has 1. No two values have the same number of occurrences.   Example 2:   Input: arr    1,2  Output: false Explanation: The value 1 has 1 occurrence, 2 has 1 occurrence. Two values have the same number of occurrences.   Example 3:   Input: arr    -3,0,1,-3,1,1,1,-3,10,0  Output: true Explanation: The value -3 has 3 occurrences, 0 has 2, 1 has 4, and 10 has 1. All occurrence counts are unique.   --- Simple Explanation Think of this like checking if everyone in a group has a unique number of items! Just like in real life: - If Alice has 3 apples, Bob has 2 apples, and Charlie has 1 apple   All unique   - If Alice has 2 apples and Bob has 2 apples   Not unique   Key insight: Count how many times each number appears, then check if all these counts are different! --- Solution  include  include using namespace std; class Solution public: bool uniqueOccurrences vector  arr     Step 1: Count occurrences of each number unordered_map countMap; for  int num : arr  countMap num   ;    Step 2: Check if all occurrence counts are unique unordered_set uniqueOccurrences; for  auto  pair : countMap  if  uniqueOccurrences.count pair.second   return false;    Duplicate count found uniqueOccurrences.insert pair.second ; return true; ; , title:  Java , language:  java , code: import java.util. ; public class UniqueOccurrences public static boolean uniqueOccurrences int   arr     Step 1: Count occurrences of each number Map countMap   new HashMap    ; for  int num : arr  countMap.put num, countMap.getOrDefault num, 0    1 ;    Step 2: Check if all occurrence counts are unique Set uniqueOccurrences   new HashSet    ; for  int count : countMap.values    if  !uniqueOccurrences.add count   return false;    Duplicate count found return true; ,      --- Step-by-Step Walkthrough Let s trace through arr    1,2,2,1,1,3 :    Step 1: Count occurrences 1 appears:  1, _, _, 1, 1, _    3 times 2 appears:  _, 2, 2, _, _, _    2 times 3 appears:  _, _, _, _, _, 3    1 time countMap   1: 3, 2: 2, 3: 1 Step 2: Extract occurrence counts occurrences    3, 2, 1  Step 3: Check uniqueness uniqueOccurrences   3, 2, 1 occurrences.length   3 uniqueOccurrences.size   3 3     3     return true Result: true  all occurrence counts are unique    Let s trace through arr    1,2 :   Step 1: Count occurrences 1 appears:  1, _    1 time 2 appears:  _, 2    1 time countMap   1: 1, 2: 1 Step 2: Extract occurrence counts occurrences    1, 1  Step 3: Check uniqueness uniqueOccurrences   1    Set removes duplicates occurrences.length   2 uniqueOccurrences.size   1 2 !   1     return false Result: false  both numbers have the same occurrence count    --- Alternative Approaches Approach 1: One-Pass with Set Check  javascript function uniqueOccurrences arr  const countMap   new Map  ;    Count occurrences for  const num of arr  countMap.set num,  countMap.get num     0    1 ;    Check uniqueness while iterating const seen   new Set  ; for  const count of countMap.values    if  seen.has count   return false; seen.add count ; return true;   Approach 2: Using Array Methods  javascript function uniqueOccurrences arr  const counts   Object.values  arr.reduce  acc, num     acc num     acc num     0    1; return acc; ,    ; return counts.length     new Set counts .size;   --- Complexity Analysis Time Complexity: O n  First pass to count occurrences: O n  Second pass to check uniqueness: O k  where k   n Overall: O n  Space Complexity: O n  HashMap for counting: O k  where k is number of unique elements Set for uniqueness check: O k  Overall: O n  in worst case  all elements unique  --- Key Insights Two-step process - First count, then check uniqueness of counts Hash map pattern - Perfect for frequency counting problems Set for uniqueness - Set size vs array length comparison trick Early termination - Can return false immediately when duplicate count found --- Edge Cases - Single element:  1    Always true  only one occurrence count  - All same elements:  5,5,5    Always true  only one unique count  - All different elements:  1,2,3    Always true  all counts are 1  - Empty array:       True  no occurrences to check  --- This problem demonstrates the power of frequency counting combined with set-based uniqueness checking!",
    "excerpt": "Unique Number of Occurrences Difficulty: Easy LeetCode: 1207. Unique Number of Occurrences --- Problem Given an array of integers arr, return true if the...",
    "url": "/docs/problems/unique-number-of-occurrences",
    "canonicalUrl": "https://crackmode.vercel.app/docs/problems/unique-number-of-occurrences",
    "section": "Problems",
    "tags": [
      "easy",
      "array",
      "leetcode",
      "complexity",
      "pattern",
      "javascript"
    ],
    "headings": [
      {
        "level": 1,
        "text": "Unique Number of Occurrences",
        "id": "unique-number-of-occurrences"
      },
      {
        "level": 2,
        "text": "Problem",
        "id": "problem"
      },
      {
        "level": 2,
        "text": "Simple Explanation",
        "id": "simple-explanation"
      },
      {
        "level": 2,
        "text": "Solution",
        "id": "solution"
      },
      {
        "level": 2,
        "text": "Step-by-Step Walkthrough",
        "id": "step-by-step-walkthrough"
      },
      {
        "level": 2,
        "text": "Alternative Approaches",
        "id": "alternative-approaches"
      },
      {
        "level": 3,
        "text": "Approach 1: One-Pass with Set Check",
        "id": "approach-1-one-pass-with-set-check"
      },
      {
        "level": 3,
        "text": "Approach 2: Using Array Methods",
        "id": "approach-2-using-array-methods"
      },
      {
        "level": 2,
        "text": "Complexity Analysis",
        "id": "complexity-analysis"
      },
      {
        "level": 2,
        "text": "Key Insights",
        "id": "key-insights"
      },
      {
        "level": 2,
        "text": "Edge Cases",
        "id": "edge-cases"
      }
    ],
    "publishedAt": "2026-01-04T04:18:51.321Z",
    "updatedAt": "2026-01-04T04:18:51.321Z",
    "author": "Morgan Ngetich",
    "readingTime": 4,
    "seo": {
      "title": "Unique Number Of Occurrences | Crackmode Documentation",
      "description": "Unique Number of Occurrences Difficulty: Easy LeetCode: 1207. Unique Number of Occurrences --- Problem Given an array of integers arr, return true if the...",
      "keywords": "unique, number, occurrences, easy, array, leetcode, complexity, pattern, javascript, count, return, counts, crackmode, algorithm",
      "robots": "index,follow",
      "jsonLd": "{\"@context\":\"https://schema.org\",\"@type\":\"Article\",\"headline\":\"Unique Number Of Occurrences\",\"description\":\"Unique Number of Occurrences Difficulty: Easy LeetCode: 1207. Unique Number of Occurrences --- Problem Given an array of integers arr, return true if the...\",\"url\":\"https://crackmode.vercel.app/docs/problems/unique-number-of-occurrences\",\"datePublished\":\"2026-01-04T04:18:51.321Z\",\"dateModified\":\"2026-01-04T04:18:51.321Z\",\"author\":{\"@type\":\"Person\",\"name\":\"Morgan Ngetich\"},\"publisher\":{\"@type\":\"Organization\",\"name\":\"CrackMode\",\"logo\":{\"@type\":\"ImageObject\",\"url\":\"https://crackmode.vercel.app/group.png\"}},\"mainEntityOfPage\":{\"@type\":\"WebPage\",\"@id\":\"https://crackmode.vercel.app/docs/problems/unique-number-of-occurrences\"},\"wordCount\":168,\"timeRequired\":\"PT4M\",\"inLanguage\":\"en-US\",\"isAccessibleForFree\":true}"
    },
    "socialMedia": {
      "ogTitle": "Unique Number Of Occurrences | Crackmode Documentation",
      "ogDescription": "Given an array of integers arr, return true if the number of occurrences of each value in the array is unique or false otherwise.",
      "ogImage": "https://crackmode.vercel.app/api/v1/og?title=Unique+Number+Of+Occurrences&description=Given+an+array+of+integers+arr%2C+return+true+if+the+number+of+occurrences+of+each+value+in+the+array+is+unique+or+false+o...&section=Documentation&theme=crackmode",
      "twitterTitle": "Unique Number Of Occurrences | Crackmode Documentation",
      "twitterDescription": "Given an array of integers arr, return true if the number of occurrences of each value in the array is unique or false otherwise.",
      "twitterImage": "https://crackmode.vercel.app/api/v1/og?title=Unique+Number+Of+Occurrences&description=Given+an+array+of+integers+arr%2C+return+true+if+the+number+of+occurrences+of+each+value+in+the+array+is+unique+or+false+o...&section=Documentation&theme=crackmode"
    }
  },
  {
    "id": "problems/valid-parentheses",
    "title": "Valid Parentheses",
    "content": "Valid Parentheses Difficulty: Easy LeetCode: 20. Valid Parentheses --- Problem Given a string s containing just the characters    ,    ,    ,    ,    and   , determine if the input string is valid. An input string is valid if: 1. Open brackets must be closed by the same type of brackets. 2. Open brackets must be closed in the correct order. 3. Every close bracket has a corresponding open bracket of the same type. Example 1:    Input: s        Output: true   Example 2:   Input: s          Output: true   Example 3:   Input: s        Output: false   Example 4:   Input: s          Output: false   Example 5:   Input: s        Output: true   --- Simple Explanation This function checks if parentheses, brackets, and braces are properly matched and nested using a stack. The key insight: Use a stack to track opening brackets and match them with closing brackets in reverse order  LIFO - Last In, First Out . Solution stack   new Stack    ;    Mapping of closing to opening brackets Map mapping   new HashMap    ; mapping.put    ,     ; mapping.put    ,     ; mapping.put   ,    ; for  char c : s.toCharArray    if  mapping.containsKey c      It s a closing bracket    Check if stack is empty or top doesn t match if  stack.isEmpty      stack.pop   !  mapping.get c   return false; else    It s an opening bracket stack.push c ;    Valid if stack is empty  all brackets matched  return stack.isEmpty  ; , title:  C   , language:  cpp , code:  include  include  include class Solution public: bool isValid std::string s     Stack to keep track of opening brackets std::stack stack;    Mapping of closing to opening brackets std::unordered_map mapping      ,    ,    ,    ,   ,    ; for  char c : s  if  mapping.find c  !  mapping.end       It s a closing bracket    Check if stack is empty or top doesn t match if  stack.empty      stack.top   !  mapping c   return false; stack.pop  ; else    It s an opening bracket stack.push c ;    Valid if stack is empty  all brackets matched  return stack.empty  ; ;      --- Step-by-Step Walkthrough Example 1: s             char      : Opening bracket   stack         char      : Closing bracket, matches       stack      char      : Opening bracket   stack         char      : Closing bracket, matches       stack      char     : Opening bracket   stack        char     : Closing bracket, matches      stack      Final stack:     empty  Result: True   Example 2: s            char      : Opening bracket   stack         char      : Opening bracket   stack       ,      char      : Closing bracket, expects     but top is       False Result: False  mismatch detected    Example 3: s           char      : Opening bracket   stack         char      : Opening bracket   stack       ,      char      : Opening bracket   stack       ,    ,      Final stack:     ,    ,       not empty  Result: False   --- Edge Cases  python Test cases: print isValid        True - empty string is valid print isValid          True - simple pair print isValid            True - multiple pairs print isValid            True - nested brackets print isValid            False - wrong nesting order print isValid          False - unmatched opening print isValid          False - unmatched closing print isValid         False - single opening print isValid         False - single closing    --- Complexity Analysis Time Complexity: O n  - Single pass through the string Space Complexity: O n  - In worst case, stack can hold all opening brackets Example:         requires stack of size n --- Pattern Recognition This problem demonstrates key patterns: - Stack for Matching: Using LIFO structure for paired elements - Character Mapping: Dictionary lookups for fast matching - State Validation: Checking conditions at each step and final state - Early Termination: Return False as soon as invalid condition is found You ll see similar patterns in: - Balanced Binary Tree validation - Expression evaluation problems - Nested structure parsing - Undo Redo functionality - Browser history navigation ---",
    "excerpt": "Valid Parentheses Difficulty: Easy LeetCode: 20. Valid Parentheses --- Problem Given a string s containing just the characters , , , , and , determine if the...",
    "url": "/docs/problems/valid-parentheses",
    "canonicalUrl": "https://crackmode.vercel.app/docs/problems/valid-parentheses",
    "section": "Problems",
    "tags": [
      "easy",
      "array",
      "string",
      "tree",
      "leetcode",
      "complexity"
    ],
    "headings": [
      {
        "level": 1,
        "text": "Valid Parentheses",
        "id": "valid-parentheses"
      },
      {
        "level": 2,
        "text": "Problem",
        "id": "problem"
      },
      {
        "level": 2,
        "text": "Simple Explanation",
        "id": "simple-explanation"
      },
      {
        "level": 2,
        "text": "Solution",
        "id": "solution"
      },
      {
        "level": 2,
        "text": "Step-by-Step Walkthrough",
        "id": "step-by-step-walkthrough"
      },
      {
        "level": 3,
        "text": "Example 1: s = \"()[]{}\"",
        "id": "example-1-s"
      },
      {
        "level": 3,
        "text": "Example 2: s = \"([)]\"",
        "id": "example-2-s"
      },
      {
        "level": 3,
        "text": "Example 3: s = \"(((\"",
        "id": "example-3-s"
      },
      {
        "level": 2,
        "text": "Edge Cases",
        "id": "edge-cases"
      },
      {
        "level": 1,
        "text": "Test cases:",
        "id": "test-cases"
      },
      {
        "level": 2,
        "text": "Complexity Analysis",
        "id": "complexity-analysis"
      },
      {
        "level": 2,
        "text": "Pattern Recognition",
        "id": "pattern-recognition"
      }
    ],
    "publishedAt": "2026-01-04T04:18:51.321Z",
    "updatedAt": "2026-01-04T04:18:51.321Z",
    "author": "Morgan Ngetich",
    "readingTime": 3,
    "seo": {
      "title": "Valid Parentheses | Crackmode Documentation",
      "description": "Valid Parentheses Difficulty: Easy LeetCode: 20. Valid Parentheses --- Problem Given a string s containing just the characters , , , , and , determine if the...",
      "keywords": "valid, parentheses, easy, array, string, tree, leetcode, complexity, stack, opening, bracket, brackets, false, crackmode, algorithm",
      "robots": "index,follow",
      "jsonLd": "{\"@context\":\"https://schema.org\",\"@type\":\"Article\",\"headline\":\"Valid Parentheses\",\"description\":\"Valid Parentheses Difficulty: Easy LeetCode: 20. Valid Parentheses --- Problem Given a string s containing just the characters , , , , and , determine if the...\",\"url\":\"https://crackmode.vercel.app/docs/problems/valid-parentheses\",\"datePublished\":\"2026-01-04T04:18:51.321Z\",\"dateModified\":\"2026-01-04T04:18:51.321Z\",\"author\":{\"@type\":\"Person\",\"name\":\"Morgan Ngetich\"},\"publisher\":{\"@type\":\"Organization\",\"name\":\"CrackMode\",\"logo\":{\"@type\":\"ImageObject\",\"url\":\"https://crackmode.vercel.app/group.png\"}},\"mainEntityOfPage\":{\"@type\":\"WebPage\",\"@id\":\"https://crackmode.vercel.app/docs/problems/valid-parentheses\"},\"wordCount\":189,\"timeRequired\":\"PT3M\",\"inLanguage\":\"en-US\",\"isAccessibleForFree\":true}"
    },
    "socialMedia": {
      "ogTitle": "Valid Parentheses | Crackmode Documentation",
      "ogDescription": "Given a string s containing just the characters '(', ')', '[', ']', '{' and '}', determine if the input string is valid. An input string is valid if: 1.",
      "ogImage": "https://crackmode.vercel.app/api/v1/og?title=Valid+Parentheses&description=Given+a+string+s+containing+just+the+characters+%27%28%27%2C+%27%29%27%2C+%27%5B%27%2C+%27%5D%27%2C+%27%7B%27+and+%27%7D%27%2C+determine+if+the+input+string+is+valid....&section=Documentation&theme=crackmode",
      "twitterTitle": "Valid Parentheses | Crackmode Documentation",
      "twitterDescription": "Given a string s containing just the characters '(', ')', '[', ']', '{' and '}', determine if the input string is valid. An input string is valid if: 1.",
      "twitterImage": "https://crackmode.vercel.app/api/v1/og?title=Valid+Parentheses&description=Given+a+string+s+containing+just+the+characters+%27%28%27%2C+%27%29%27%2C+%27%5B%27%2C+%27%5D%27%2C+%27%7B%27+and+%27%7D%27%2C+determine+if+the+input+string+is+valid....&section=Documentation&theme=crackmode"
    }
  }
]